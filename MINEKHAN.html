
<!DOCTYPE html>
<!-- @MineKhan version Alpha 1.0.4
Notes and accreditation:
!!Willard is another person, not me!!
My credits (not Willard's)
* Red Monster (https://www.khanacademy.org/profile/monsterred) made the shapes for the blocks
* Shoos10 (https://www.khanacademy.org/profile/kaid_651789387350300127259402) created the Island World type
* Repeat (https://www.khanacademy.org/profile/kaid_730847189850789421961173) made a few fixes/changes here and there
* I created the survival mode
Willard's credits
* This program (MineKhan) was made by Willard (me). The original is https://www.khanacademy.org/cs/mc/5647155001376768 (just adding this so that spin-offs have it)
* Zushah helped me with some of the menus in the 0.6 update via GitHub. https://www.khanacademy.org/profile/zushah77
* Element118 helped speed up the process of adding new textures significantly. https://www.khanacademy.org/profile/element118
* Danielkshin made the current main menu background. https://www.khanacademy.org/profile/danielkshin
* This program originated as a spin-off of ScusCraft by ScusX.
* It's 99% different code at this point, but I still never would have made it this far without his code for reference.
* ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
* My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
* While porting the code from PJS to a webpage, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
* The textures are 100% copied from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association.
* The real Minecraft game can be bought and downloaded at https://www.minecraft.net/en-us/
* Chunks are kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<title>MineKhan</title>
<base href="https://minekhan.thingmaker.repl.co">
<meta name="keywords" content="MineKhan, survival, Alpha, nether"> <!--search "MineKhan" on Google-->
<meta name="description" content="MineKhan with survival and nether and many more features">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" id="themeColor">
<link id="vtfont" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>@font-face{font-family: 'VT323'; src:url('mojangles.ttf');}</style>
<link rel="shortcut icon" type="image/ico" href="favicon.ico?">
<link rel="manifest" href="manifest.json">
</head>
<style>
body {
overflow: hidden; /* Hide scrollbars */
}
#errorScreen {
position: absolute;
top: 0px;
left: 0px;
width:100vw;
height:100vh;
z-index:10;
background:blue;
color:white;
padding:8px;
font-family:sans-serif;
overflow:auto;
box-sizing:border-box;
}
button, #onscreenControls, canvas, #loader{
/*get rid of user select*/
-webkit-tap-highlight-color: transparent;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
}
button{
margin:0;
border-radius:0px;
background:rgb(120,120,120);
border-color:rgb(200,200,200) rgb(80,80,80) rgb(80,80,80) rgb(200,200,200);
border-width:2px;
border-style:solid;
color:white;
outline:none;
cursor:pointer;
font-family:VT323;
font-size:12px;
}
button:hover{
background:rgb(100,120,200);
border-color:rgb(200,200,255) rgb(100,80,160) rgb(100,80,160) rgb(200,200,255);
color:yellow;
}
button:active{
/*background:#9a9a9a;
border-color:#888 #aaa #aaa #888;*/
background:rgb(100,120,200);
border-color:rgb(100,80,160) rgb(200,200,255) rgb(200,200,255) rgb(100,80,160);
}
button[disabled]{
background:rgb(60,60,60);
border-color:rgb(20,20,20) rgb(130,130,130) rgb(130,130,130) rgb(20,20,20);
cursor:default;
color:white;
}
.world-select {
width: 99vw;
min-width: 300px;
height: calc(100vh - 220px);
position: absolute;
bottom: 120px;
overflow-y: auto;
background-color: RGBA(0, 0, 0, 0.6);
justify-content: center;
margin: 0 auto;
}
.world {
width: 50%;
height: auto;
border: 1px solid black;
font-size: 13px;
font-family: 'VT323', 'Courier New', Courier, monospace;
color: rgb(180, 180, 180);
margin: 0 auto;
margin-top: 15px;
padding: 5px;
cursor: pointer;
position:relative;
}
.world .thumbnail{
float:left;
margin-right:8px;
width:64px;
height:64px;
}
.world .thumbnailHover{
position:absolute;
left:5px;
top:5px;
background:#fff8;
opacity:0;
width:64px;
height:64px;
background-image: url("https://data.thingmaker.repl.co/images/world_selection.png");
background-position: 0 0;
background-size: 800%;
image-rendering: pixelated;
}
.world:hover .thumbnailHover{
opacity:1;
}
.world .thumbnailHover:hover{
background-position: 0 -64px;
}
.world .ping{
float:right;
}
.world .ping .img, .pingImg{
width:20px;
height:14px;
image-rendering:pixelated;
background-image: url("https://data.thingmaker.repl.co/images/ping.png");
background-position: 0 0;
background-size: 40px 600%;
display:inline-block;
}
.world-select .message{
font-size: 15px;
font-family: 'VT323', 'Courier New', Courier, monospace;
color: rgb(180, 180, 180);
margin-top: 15px;
text-align:center;
}
strong {
color: white;
}
a{
color:#37f;
text-decoration:none;
}
a:hover{
text-decoration:underline;
}
.selected {
outline: 3px solid white;
}
input[type=text] {
background-color: black;
caret-color: white;
border: 2px solid gray;
color: white;
font-size: 24px;
padding-left: 12px;
}
input[type=text]:focus {
border: 2px solid lightgray;
}
#boxcentertop {
z-index: 1;
width: 80vw;
max-width: 400px;
height: 50px;
position: relative;
top: 30px;
display: block;
margin: 0 auto;
}
#uploadWorld {
z-index: 1;
color:white;
position: relative;
display: block;
left: calc(50% + 220px);
}
#editworld{
z-index: 1;
width: 80vw;
max-width: 400px;
position:relative;
top:90px;
margin:0 auto;
}
#editworld input{
width:100%;
height: 50px;
display: block;
margin: 10px 0;
}
.hidden {
display: none !important;
}
#onhover {
background-color: rgba(0, 0, 0, 0.9);
color: rgb(200, 200, 200);
font-family: VT323, 'Courier New', Courier, monospace;
font-size:13px;
word-wrap: normal;
width: auto;
max-width: 400px;
position: absolute;
z-index: 1;
padding: 10px;
cursor: default;
}
#quota {
display: block;
position: absolute;
width: 99vw;
margin: 0 auto;
bottom: 110px;
z-index: 1;
background-color: RGBA(0, 0, 0, 0.6);
justify-content: center;
text-align: center;
color: white;
}
#messagesHolder{
position:absolute;
z-index:2;
top:0px;
left:0px;
background:#000a;
color:white;
font:14px 'VT323';
overflow-wrap:anywhere;
max-height:100vh;
overflow:hidden;
}
#messageInput{
border:none;
background:transparent;
width:100%;
min-width:100px;
color:white;
font:14px 'VT323';
}
#messages{
/*display: flex;
align-items: flex-end;*/
max-height:100vh;
overflow:hidden;
}
#controls{
width: 99vw;
min-width: 300px;
height: calc(100vh - 130px);
position: absolute;
bottom: 80px;
overflow-y: auto;
background-color: RGBA(0, 0, 0, 0.6);
justify-content: center;
margin: 0 auto;
color:white;
font:15px VT323;
}
#controls table{
width:100%;
}
.control td{
padding:5px 4px;
}
.control button{
float:right;
width:100%;
min-height:30px;
}
#controlDetect{
width: 100vw;
height: 100vh;
position: absolute;
top:0;
left:0;
background-color: white;
justify-content: center;
align-items:center;
display:flex;
font:20px VT323;
z-index:1;
}
#narratorVoiceSelect{
position:absolute;
box-sizing:border-box;
left:calc(50vw - (100vw / 6));
top:calc(50vh + -65px - 20px);
width:calc(100vw / 3);
height:calc(40px);
}
#help{
position:absolute;
z-index:2;
top:50px;
left:0px;
width:100vw;
height:calc(100vh - 50px);
background:#0000;
color:white;
font:15px VT323;
display:flex;
flex-direction:row;
}
#help > .nav{
width:20%;
background:#0008;
}
#help > .nav > a{
display:block;
padding:8px;
width:100%;
text-decoration:none;
color:white;
cursor:pointer;
}
#help > .content{
width:80%;
padding:10px;
overflow:scroll;
background:#0004;
}
#help > .content > div{
margin-bottom:100px;
}
#help > .content pre{
font:15px VT323;
}
#help h1{font-size:25px;}
#help h2{font-size:18px;}
#help img{max-width:100%;}
#onscreenControls{
position:fixed;
font-family:monospace;
bottom:10px;
width:100%;
}
#onscreenControls button{
min-width:calc(100% / 13);
min-height:40px;
}
#onscreenControls #buttonsRight{
position:absolute;
bottom:10px;
right:10px;
}
#onscreenControls #buttonsTop{
position:absolute;
top:10px;
left:10px;
width:calc(100% - 20px);
display:flex;
align-items:center;
}
#loader{
background:#111;
color:white;
position:absolute;
top:0;
left:0;
width:100vw;
height:100vh;
font-size:30px;
font-family:Arial;
display:flex;
justify-content:center;
align-items:center;
flex-direction:column;
z-index:2;
transition:1s linear;
}
#loader .name{
width:433px;
/*
font-size:60px;
font-family:VT323;
*/
}
#loader .name > img{
width:100%;
}
#loadingImg{
width:42px;
image-rendering:pixelated;
}
#loadBar{
border:2px solid #eee;
width:40%;
padding:2px;
}
#loadBar div{
height:10px;
width:0px;
background:#eee;
}
.darklinks a{
color:blue;
}
.collapsible{
color:black;
}
.collapsible .title{
background-color: #777;
color: white;
cursor: pointer;
padding: 18px;
border: none;
text-align: left;
outline: none;
font-size: 15px;
}
.collapsible .title:hover {
background-color: #555;
}
.collapsible .title:after {
content: '\02795'; /* Unicode character for "plus" sign (+) */
font-size: 13px;
color: white;
float: right;
margin-left: 5px;
}
.collapsible .title.active:after{
content: "\2796"; /* Unicode character for "minus" sign (-) */
}
.collapsible .content {
padding: 0 18px;
background-color: #f1f1f1;
max-height: 0;
overflow: hidden;
transition: max-height 0.2s ease-out;
}
.recipe{
background:#7f7f7f;
border:1px solid black;
padding:10px;
margin:20px;
display:inline-block;
}
.recipe .grid {
display:inline-block;
outline: 2px solid black;
}
.recipe .grid > img, .recipe .grid > div {
outline: 1px solid black;
display:inline-block;
}
.recipe .result{
outline: 1px solid black;
display:inline-block;
position:relative;
}
.recipe .result .number{
position:absolute;
color:white;
bottom:0;
right:0;
font-size:14px;
}
</style>
<body>
<div id="errorScreen" style="display:none;"></div>
<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
<input type="file" id="uploadWorld" class="hidden" accept=".minekhan" title="Upload a world">
<div id="quota" class="hidden"></div>
<div id="editworld" class="hidden">
<input type="text" id="url" spellcheck="false" placeholder="Enter thumbnail url">
</div>
<div id="onhover" class="hidden"></div>
<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
To save your world, copy/paste the saveString<br>
from this box into the code on line 189.<br>
var loadString = "Your Code Here";<br>
Then save the program as a Spin-off.
</p>
<div class="world-select hidden" id="worlds"></div>
<div class="world-select hidden" id="servers"></div>
<div class="world-select hidden" id="marketplace"></div>
<p id="message" class="hidden darklinks" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
<datalist id="cmdList"></datalist>
<div id="messagesHolder" class="hidden">
<input id="messageInput" class="hidden" list="cmdList">
<div id="messages"></div>
</div>
<div id="controls" class="hidden"></div>
<div id="controlDetect" class="hidden" tabindex="0">Click or press a key</div>
<select id="narratorVoiceSelect" class="hidden"></select>
<div id="help" class="hidden">
<div class="nav">
<a onclick="scrollToEl('help_about')">About</a>
<a onclick="scrollToEl('help_loadsave')">Load save menu</a>
<a onclick="scrollToEl('help_controls')">Controls</a>
<a onclick="scrollToEl('help_health')">Health</a>
<a onclick="scrollToEl('help_inventory')">Inventory</a>
<a onclick="scrollToEl('help_crafting')">Crafting</a>
</div>
<div class="content">
<div id="help_about">
<h1>About MineKhan</h1>
MineKhan is a sandbox video game just like Minecraft.<br>
MineKhan has things Minecraft doesn't.<br>
MineKhan doesn't have some things Minecraft has.<br>
If you want to suggest stuff, you should go to my website: <a href="https://www.thingmaker.repl.co/website/posts.html" target="_blank">https://www.thingmaker.repl.co</a>
<h2>Where MineKhan came from</h2>
One upon a time, there was a game on Khan Academy called Scuscraft.<br>
One day, Willard spin-offed Scusraft and made MineKhan.<br>
After many days, he ported it from a pjs program to to a webpage.<br>
Then, when Willard made his own website (willard.fun), thingMaker copied the code and programmed it more so soon it became this.<br>
The End.
</div>
<div id="help_loadsave">
<h1>Load save menu</h1>
The load save menu is where you load and create worlds.<br>
<img src="https://data.thingmaker.repl.co/images/help/loadsave.png" style="border:1px solid white;"><br>
To select a world, you click it.<br>
The create new world button takes you to the Create world menu.<br>
The play selected world button loads the selected world.<br>
<span style="color:yellow; font-family:fantasy;display:none;">"Congratulations, you graduate!" - Iruka Sensei<br></span>
The edit button takes you to the Edit world menu.<br>
The delete button deletes the selected world.<br>
The export button puts the save code of the selected world in the input box.<br>
The cancel button takes you back to the main menu.
</div>
<div id="help_controls">
<h1>Controls</h1>
<b>These controls are used only when playing in a world.</b>You can change them by going to options and clicking controls<br>
<pre> * Right-click (or ctrl + left-click): place block
* Left-click: Remove block
* Middle-click: Pick block
* Q: Sprint
* Shift: Sneak
* W: Walk forward
* S: Walk backward
* A: Walk left
* D: Walk right
* E: Open inventory
* B: Toggle super Breaker
* Z: Zoom
* L: Toggle Spectator mode
* Enter: Toggle slab/stair mode
* Arrow Keys: look around
* P or Esc: pause/unpause
* 1-9 navigate hotbar
* Spacebar: jump
* Double jump: toggle flight
* Shift (flying): fly down
* Space (flying): fly up
* T: Reload textures
* ; (semicolon): Release the pointer without pausing (for screenshots)
* Backspace or delete: drops the item you're holding right now
* / to open chat
* H for Hyper builder
* O to toggle third person mode</pre>
</div>
<div id="help_health">
<h1>Health</h1>
Health is a feature only in survival.<br>
A heart looks like this: <div img="heart"></div><br>
A half heart looks like this: <div img="halfHeart"></div><br>
When you create a new world, you start with 20 <div img="heart" amount="10"></div> health.<br>
When you have 0 <div img="deadHeart" amount="10"></div> health, you die.
<h2>Losing health</h2>
There are many ways to lose health inluding fall damage, being attacked by other players, and touching cactus and lava.
<h2>Effects</h2>
There are effects that change how the hearts look.<br>
When you are withered, it looks like this: <img src="https://data.thingmaker.repl.co/images/witherHealthBar.gif"><br>
When you are freezing, it looks like this: <img src="https://data.thingmaker.repl.co/images/freezeHealthBar.gif">
</div>
<div id="help_inventory">
<h1>Inventory</h1>
When playing a world, press e to open the inventory.<br><br>
<h2>Creative inventory</h2>
<img src="https://data.thingmaker.repl.co/images/help/inventory.png" style="border:1px solid white;"><br>
<h2>Survival inventory</h2>
<img src="https://data.thingmaker.repl.co/images/help/survival_inventory.png" style="border:1px solid white;"><br>
More info will <s style="color:red;">come soon</s> not come anytime soon.
</div>
<div id="help_crafting">
<h1>Crafting</h1>
You can access the crafting grid from the inventory or by right clicking a crafting table.<br>
The inventory crafting grid is 2&times;2.<br>
The crafting table's crafting grid is 3&times;3.<br>
Some things require a crafting table to be crafted.<br><br>
<h2>Recipes</h2>
Click the collapsible to see crafting recipes
<div class="collapsible" title="Recipes" id="recipes">
oh wait, it's kinda hard to show the recipes 'cause i don't have images
</div>
Crafting recipe types:<br>
Fixed: You have to put the items in the grid the exact way.<br>
Shaped: The ingredients have a certain shape and the shape can be moved around.<br>
Shapeless: The ingredients can be arranged on the grid in any way
</div>
</div>
</div>
<div id="onscreenControls" class="hidden">
<button style="visibility:hidden;">&nbsp;</button><button id="controlW">W</button>
<br>
<button id="controlA">A</button><button style="visibility:hidden;">&nbsp;</button><button id="controlD">D</button>
<br>
<button style="visibility:hidden;">&nbsp;</button><button id="controlS">S</button>
<div id="buttonsRight">
<button id="controlSpace">space</button>
<br>
<button id="controlShift">shift</button>
</div>
<!--<div id="buttonsTop">
<button id="controlPause">Pause</button>
</div>-->
</div>
<div id="loader">
<div class="name"><img src="https://data.thingmaker.repl.co/images/minekhan.png"></div><br>
<img src="https://data.thingmaker.repl.co/images/loading.gif" id="loadingImg"><br><br>
<div id="loadBar">
<div></div>
</div>
<div id="loadProgress"></div>
</div>
<script>
// Code edits will erase the world.
// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
var loadString = ""
</script>
<!--url for parkour map: https://www.khanacademy.org/cs/i/4676725830008832-->
<script type="x-shader/vertex" id="blockVertexShader">
attribute vec3  aVertex;
attribute vec2  aTexture;
attribute float aShadow;
attribute float aSkylight;
attribute float aBlocklight;
attribute vec3 aTint;
varying vec2  vTexture;
varying float vShadow;
varying float vFog;
varying float waterFog;
varying vec3 lightTint;
varying vec3 vTint;
uniform mat4 uView;
uniform float uDist;
uniform vec3 uPos;
uniform float uTime;
uniform vec3 skyColor;
uniform bool isInWorld;
uniform bool flicker;
void main() {
float x = aTexture.x;
float y = aTexture.y / 8.0;
vTexture = vec2(x,y);
// If you are going to change this final lightlevel calculation
// you have to change line 4487 as well since it calculates lightlevel of entity based on this
vShadow = aShadow * min(max(aSkylight * uTime, aBlocklight) * 0.9 + 0.1, 1.0);
vTint = aTint;
gl_Position = uView * vec4(aVertex, 1.0);
float range = max(uDist / 5.0, 8.0);
vFog = clamp((length(uPos.xz - aVertex.xz) - uDist + range) / range, 0.0, 1.0);
waterFog = min(gl_Position.z / 150.0, 1.0);
lightTint = vec3(1.,1.,1.);
if(isInWorld){
vec3 blockLightColor = flicker ? vec3(0.98, 0.95, 0.87) : vec3(1.,0.98,0.9);
float blight = max(aBlocklight - aSkylight * uTime, 0.0);
lightTint = mix(lightTint, blockLightColor, 1.0-(abs(0.5 - blight) * 2.0));
lightTint = mix(lightTint, skyColor*0.5, aSkylight * (1.0 - uTime) * 0.4);
}
}
</script>
<script type="x-shader/fragment" id="blockFragmentShader">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D uSampler;
uniform float uTime;
uniform bool uTrans;
uniform vec3 skyColor;
uniform int inWater;
varying float vShadow;
varying vec2 vTexture;
varying float vFog;
varying float waterFog;
varying vec3 lightTint;
varying vec3 vTint;
vec4 blueShift(vec4 color) {
color.rg *= 1.0 - waterFog;
color.r = color.r * (50.0/255.0) * max(waterFog/2., 1.);
color.g = color.g * (210.0/255.0) * max(waterFog/2., 1.);
color.b += (0.9 - color.b) * waterFog;
return vec4(color.r * 0.9, color.g * 0.9, min(color.b + 0.3, 1.0), color.a);
}
vec4 redShift(vec4 color) {
return vec4(mix(color.rgb, vec3(255.,0.,0.), min(waterFog*12., 1.)), color.a);
}
void main(){
vec4 color = texture2D(uSampler, vTexture);
if (color.a != 1.0) color.a = mix(color.a, 0.0, vFog);
color = vec4(mix(color.rgb * vTint * lightTint * vShadow, skyColor * uTime, vFog), color.a);
if (inWater == 1) color = blueShift(color);
if (inWater == 2) color = redShift(color);
gl_FragColor = color;
if (gl_FragColor.a == 0.0) discard;
else if (!uTrans && gl_FragColor.a != 1.0) discard;
else if (uTrans && gl_FragColor.a == 1.0) discard;
}
</script>
<script type="x-shader/vertex" id="skyboxVertexShader">
attribute vec3 aVertex;
uniform float time;
uniform mat4 uView;
varying vec3 position;
mat4 no_translate (mat4 mat) {
mat4 nmat = mat;
nmat[3].xyz = vec3(0.);
return nmat;
}
void main(void) {
position = aVertex;
gl_Position = no_translate(uView) * vec4(aVertex * -100., 0.0);
}
</script>
<script type="x-shader/fragment" id="skyboxFragmentShader">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform float time;
varying vec3 position;
vec2 rotate2D (vec2 p, float angle){
return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));
}
float rand2D(in vec2 co){
return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
float rand3D(in vec3 co){
return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);
}
float simple_interpolate(in float a, in float b, in float x)
{
return a + smoothstep(0.0,1.0,x) * (b-a);
}
float interpolatedNoise3D(in float x, in float y, in float z)
{
float integer_x = x - fract(x);
float fractional_x = x - integer_x;
float integer_y = y - fract(y);
float fractional_y = y - integer_y;
float integer_z = z - fract(z);
float fractional_z = z - integer_z;
float v1 = rand3D(vec3(integer_x, integer_y, integer_z));
float v2 = rand3D(vec3(integer_x+1.0, integer_y, integer_z));
float v3 = rand3D(vec3(integer_x, integer_y+1.0, integer_z));
float v4 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z));
float v5 = rand3D(vec3(integer_x, integer_y, integer_z+1.0));
float v6 = rand3D(vec3(integer_x+1.0, integer_y, integer_z+1.0));
float v7 = rand3D(vec3(integer_x, integer_y+1.0, integer_z+1.0));
float v8 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z+1.0));
float i1 = simple_interpolate(v1,v5, fractional_z);
float i2 = simple_interpolate(v2,v6, fractional_z);
float i3 = simple_interpolate(v3,v7, fractional_z);
float i4 = simple_interpolate(v4,v8, fractional_z);
float ii1 = simple_interpolate(i1,i2,fractional_x);
float ii2 = simple_interpolate(i3,i4,fractional_x);
return simple_interpolate(ii1 , ii2 , fractional_y);
}
float Noise3D(in vec3 coord, in float wavelength)
{
return interpolatedNoise3D(coord.x/wavelength, coord.y/wavelength, coord.z/wavelength);
}
float noise (vec3 p, float frequency) {
float sum = 0.0;
for(float i = 0.0; i<5.0; i++) {
sum += Noise3D(p * frequency * pow(2.0, i), 1.0) / pow(2.0, i);
} return sum * 0.5; }
vec3 SUN_POSITION (float ftime) { return normalize(vec3(sin(ftime), cos(ftime), sin(ftime))); }
const vec3 skyColor = vec3(0., 0.6, 0.9);
const vec3 sunColor = vec3(1.0, 1.0, 0.6);
void main (void) {
vec3 sun = SUN_POSITION(time);
float sunset = 1.-abs(dot(sun, vec3(0., 1., 0.)));
vec3 horizonColor = mix(vec3(0., 0.8, 0.8), vec3(0.8, 0.4, 0.), sunset);
vec3 dir = normalize(position);
float horizonal = 1.-abs(dot(dir, vec3(0., 1., 0.)));
vec3 col = mix(skyColor, horizonColor, horizonal);
col = mix(col, sunColor, smoothstep(0.96, 0.98, dot(dir, sun)));
float night = smoothstep(-1.0, 0.0, -sun.y);
gl_FragColor = vec4(col * night, 1.0);
}
</script>
<script type="x-shader/vertex" id="entityVertexShader">
attribute vec3  aVertex;
attribute vec2  aTexture;
varying vec2  vTexture;
uniform mat4 uView;
uniform bool isTextureAtlas;
void main() {
float x = aTexture.x;
float y = aTexture.y;
if(isTextureAtlas){
y = aTexture.y / 8.0;
}
vTexture = vec2(x,y);
gl_Position = uView * vec4(aVertex, 1.0);
}
</script>
<script type="x-shader/fragment" id="entityFragmentShader">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D uSampler;
uniform float uLightLevel;
uniform float harmEffect;
uniform vec3 tint;
varying vec2 vTexture;
void main(){
vec4 color = texture2D(uSampler, vTexture);
color.rgb *= tint;
color.rgb = mix(color.rgb, vec3(255.,0.,0.), clamp(harmEffect/255., 0., 1.));
gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
if (gl_FragColor.a == 0.0) discard;
}
</script>
<script type="x-shader/vertex" id="particleVertexShader">
attribute vec3  aVertex;
attribute vec2  aTexture;
varying vec2  vTexture;
uniform mat4 uView;
uniform bool isTextureAtlas;
void main() {
float x = aTexture.x;
float y = aTexture.y;
if(isTextureAtlas){
y = aTexture.y / 8.0;
}
vTexture = vec2(x,y);
gl_Position = uView * vec4(aVertex, 1.0);
}
</script>
<script type="x-shader/fragment" id="particleFragmentShader">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D uSampler;
uniform float uLightLevel;
varying vec2 vTexture;
void main(){
vec4 color = texture2D(uSampler, vTexture);
gl_FragColor = vec4(color.rgb * uLightLevel, color.a);
if (gl_FragColor.a == 0.0) discard;
}
</script>
<script type="x-shader/vertex" id="2dVertexShader">
attribute vec2 aVertex;
attribute vec2 aTexture;
attribute float aShadow;
varying vec2 vTexture;
varying float vShadow;
void main() {
vTexture = aTexture;
vShadow = aShadow;
gl_Position = vec4(aVertex, 0.5, 1.0);
}
</script>
<script type="x-shader/fragment" id="2dFragmentShader">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D uSampler;
varying vec2 vTexture;
varying float vShadow;
void main() {
vec4 color = texture2D(uSampler, vTexture);
gl_FragColor = vec4(color.rgb * vShadow, color.a);
if (gl_FragColor.a == 0.0) discard;
}
</script>
<script>
let errorScreen = document.querySelector("#errorScreen")
// If there is an error, show error screen
const errors = []
function logError(e){
errors.push(e)
var html = "<h1>Error!</h1>"
errors.forEach(e => {
html += "<br><div style='border:1px solid black; padding:8px;'>"+e.message
if(e.lineno || e.colno) html += "<br>Error occured at "
if(e.lineno) html += "line "+e.lineno
if(e.colno) html += " column "+e.colno
html += "</div>"
})
html += "<br><br><button onclick='errorScreen.style.display=\"none\"'>Hide</button>"
errorScreen.innerHTML = html
errorScreen.style.display = "block"
}
window.addEventListener("error", logError)
</script>
<script type="application/javascript">
"use strict";
const urlParams = new URLSearchParams(location.search)
window.canvas = document.getElementById("overlay")
window.ctx = canvas.getContext("2d")
window.canvas2 = document.createElement("canvas")
window.ctx2 = canvas2.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.uploadWorld = document.getElementById("uploadWorld")
window.saveDirections = document.getElementById("savedirections")
window.message = document.getElementById("message")
window.worlds = document.getElementById("worlds")
window.servers = document.getElementById("servers")
window.marketplace = document.getElementById("marketplace")
window.quota = document.getElementById("quota")
window.messages = document.getElementById("messages")
window.messageHolder = document.getElementById("messagesHolder")
window.messageInput = document.getElementById("messageInput")
window.url = document.querySelector("#editworld #url")
window.editworld = document.getElementById("editworld")
var hoverbox = document.getElementById("onhover")
window.controls = document.getElementById("controls")
window.controlDetect = document.getElementById("controlDetect")
window.narratorVoiceSelect = document.getElementById("narratorVoiceSelect")
window.help = document.getElementById("help")
window.onscreenControls={
w:document.getElementById("controlW"),
a:document.getElementById("controlA"),
s:document.getElementById("controlS"),
d:document.getElementById("controlD"),
" ":document.getElementById("controlSpace"),
"shift":document.getElementById("controlShift"),
}
window.onscreenControl_Element = document.getElementById("onscreenControls")
canvas.width  = window.innerWidth
canvas.height = window.innerHeight
canvas2.width  = window.innerWidth
canvas2.height = window.innerHeight
ctx.imageSmoothingEnabled = false
window.loadProg = document.getElementById("loadProgress")
window.loader = document.getElementById("loader")
window.loadBar = document.querySelector("#loadBar div")
window.themeColor = document.getElementById("themeColor")
let touchScreen = "ontouchstart" in document
if(!touchScreen) onscreenControl_Element.style.display = "none"
function MineKhan() {
window.console.log("%cWhat are you doing?\n%cHacking?\n%cDON'T DO THAT!\n%cIf you are not a developer, %cGET OUT OF HERE!!!", "font-size:20px;font-weight:bold;", "background:lightgreen;padding:10px;", "color:red;font-weight:bold;", "text-decoration:underline;","text-decoration:underline;color:red;font-weight:bold;")
// cache Math object
const { Math, performance, Date } = window;
const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2 } = Math;
const rand = function(a,b){
if(arguments.length === 2){
return (Math.random()*(b-a))+a
}else if(arguments.length === 1){
return Math.random()*a
}else return Math.random()
}
const avg = function(){
var res = 0
for(var i=0; i<arguments.length; i++){
res += arguments[i]
}
res /= arguments.length
return res
}
Math.PI2 = Math.PI / 2
Math.PId = Math.PI * 2
// Shh don't tell anyone I'm override native objects
String.prototype.hashCode = function() {
var hash = 0, i, chr;
if (this.length === 0) return hash;
for (i = 0; i < this.length; i++) {
chr   = this.charCodeAt(i);
hash  = ((hash << 5) - hash) + chr;
hash |= 0; // Convert to 32bit integer
}
return hash;
}
var tickSpeed = 20
var tickTime = 1000/tickSpeed
var fileReader = new FileReader();
uploadWorld.onchange = function(){
var file = uploadWorld.files.item(0)
if(!file) return
fileReader.onload = function(){
var res = fileReader.result
try{
JSON.parse(res)
}catch(e){
alert("Invalid JSON\n"+e)
}
boxCenterTop.value = "JSON"+res
}
fileReader.onerror = function(e){
alert("Error loading file\n"+e)
}
fileReader.readAsText(file)
}
let setPixel, getPixels;
let spawnEggOverlay, spawnEgg
function textureUpdated(){
spawnEggOverlay = getPixels("0g0gj000í8WéSZCóWDAHK;Z÷-ZåOYGlH?$YEGZðoHnéZHTZ?÷WIcWEEYÚGZâlH0000000000000000000000000000000004w04000000õï0cÝ00001h90k000000lw00000000000L000000Bë3Ä00004(-00000004E0f0010000023ÆmGë00000Ø8nEë00000001g000000iù00000000000000")
spawnEgg = getPixels("0g0gg000éSZÚGZnéZ?$YŒEYSKW?÷WlÚYRHZSnHOCHÒþHËâZIsHÎðW00000000000000000001w0000003T0000000U0000000Ô20001ë6ÿQw001ådE4w00jE5ë4R000EûIQ{000ãÀIQd001î0400001?0400000yQQr00000wf00000000000")
}
function lerp(t, a, b) {
return a + t * (b - a);
}
function mix(r,g,b,r2,g2,b2,amount){
r = lerp(r,r2,amount)
g = lerp(g,g2,amount)
b = lerp(b,b2,amount)
return [r,g,b]
}
function fillTextureArray(textures){
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
return textures
}
var grassColor = {/*r:145/255,g:189/255,b:89/255*/r:71/255,g:206/255,b:49/255}
var foliageColor = {/*r:119/255,g:171/255,b:47/255*/r:26/255,g:191/255,b:0}
var leafColor = {r:72/255,g:181/255,b:24/255}
const semiTransTextures = []
window.semiTransTextures = semiTransTextures
const textures = {
grassTop: n => {
/*for (let x = 0; x < 16; ++x) {
for (let y = 0; y < 16; ++y) {
const d = Math.random() * 0.25 + 0.65;
const r = 0x54 * d;
const g = 0xa0 * d;
const b = 0x48 * d;
setPixel(n, x, y, r, g, b);
}
}*/
const pix = getPixels("0g0glþÇHIcWJPWðoH÷-ZéSZCåZóEYDAHÞIWCóWAÖYí8WEEYEGZâlHGlHGŒYåOYE?WHTZ0QMùC(eOcA1k5eÙ#ÀwùÔÁaOAR1Anhùäj1$C#82t5ÃsI-rô?ðü?È?ð0boeIsëFùx(OoNnw4w?Þl33ðiEeRNlMiaÆxII3wR%EoXL{õÇëðSícùis4rðCc[0òFüdIoâIß-÷ÃySÐÌyeìÀAgtEÂîFG2E0+Aroeá$2Ba?Io");
const c = grassColor
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, (pix[i] / 255) * c.r * 255, (pix[i + 1] / 255) * c.g * 255, (pix[i + 2] / 255) * c.b * 255, pix[i + 3]);
}
},
grassSide: n => {
/*const pix = getPixels("0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ");
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
const { random } = Math;
for (let x = 0; x < 16; ++x) {
const m = random() * 4 + 1;
for (let y = 0; y < m; ++y) {
const d = random() * 0.25 + 0.65;
const r = 0x54 * d;
const g = 0xa0 * d;
const b = 0x48 * d;
setPixel(n, x, y, r, g, b);
}
}*/
let pix = getPixels("0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ");
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
pix = getPixels("0g0gdEEYJPWþÇH÷-ZCåZE?Wí8W000óEYðoHEGZâlHéSZ1z12A4ÄR31Å6Â138DÇ7n4!çDGGnGI,GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
const c = grassColor
for (let i = 0; i < pix.length; i += 4) {
if (pix[i+3]>0) {
setPixel(n, i >> 2 & 15, i >> 6, (pix[i] / 255) * c.r * 255, (pix[i + 1] / 255) * c.g * 255, (pix[i + 2] / 255) * c.b * 255, pix[i + 3]);
}
}
},
leaves: n => {
const { floor, random } = Math;
for (let x = 0; x < 16; ++x) {
for (let y = 0; y < 16; ++y) {
const r = 0;
const g = floor(random() * 30 + 100);
const b = floor(random() * 30);
const a = random() < 0.35
? 0x0
: 0xff;
setPixel(n, x, y, r, g, b, a);
}
}
},
/*oakPlanks: n => {
for (let y = 0; y < 16; ++y) {
const a = 3 === (y & 3)
? 0.7
: 1.0;
for (let x = 0; x < 16; ++x) {
// these conditions are weird; can some comments be added here?
const mid = x === 8 && (y & 7) > 3 && a === 1
? 0.85
: 1;
const rit = x === 15 && (y & 7) < 3 && a === 1
? 0.85
: 1;
const r = (Math.random() * 0.1 + 0.9) * a * mid * rit;
setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
}
}
},*/
oakPlanks: "0g0g7GVZE*HiãWýLWCkZéîHÒRZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
hitbox: "0g0g100W",
/*n => {
for (let x = 0; x < 16; ++x) {
for (let y = 0; y < 16; ++y) {
setPixel(n, x, y, 0, 0, 0, 0xff)
}
}
},*/
crack10: "0g0g3000?kH?$ù444S9Æ4SiCÆùB9CgÈ@kkCQoÖ0UBíÁdp0DiÎ04KSQ]gÀAùlcgg×^BBëýa6À×À4CSC",
crack9: "0g0g3000?kH?$ù04001Æ4SiCÆùB9Cgq@kkwQgÖ0UBí1dp06iÎ04SRQ]gÀAùlcgg×^wBëý06À×À8CSC",
crack8: "0g0g3000?kH?$ù00000À000CÀ059Cga@kk0QoÖ0UBí1dp06iÎ04KRS8ùÀë0lc0g×^0Bël0aS×S0ëëë",
crack7: "0g0g3000?kH?$ù00000g000AÀ009C00@gk0QgÕ0UBë1dp062Ï04SS08ùS00lë00×S00ëü000E00000",
crack6: "0g0g3000?kH?$ù0000000004À009C006gk0QgÕ0UBë1dq062K080S00gS00lë00×S00ëù000w00000",
crack5: "0g0g3000?kH?$ù0000000000S001ë006gg04gK0UBë1dq022K000S000S00lë00!S000ë000000000",
crack4: "0g0g3000?kH?$ù0000000000000100060004gS0kBë0Fo002K000S000S005ë00a00000000000000",
crack3: "0g0g3000?kH?$ù000000000000000004000400045009q002K000S000S001ë00200000000000000",
crack2: "0g0g3000?kH?$ù000000000000000000000400040009g002K000S000ë000000000000000000000",
crack1: "0g0g3000?kH?$ù0000000000000000000000000000010002S000ë0000000000000000000000000",
none: "0g0g1000",
/*n => {
for (let x = 0; x < 16; ++x) {
for (let y = 0; y < 16; ++y) {
setPixel(n, x, y, 0, 0, 0, 0)
}
}
},*/
dirt: "0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ",
stone: "0g0g4÷-ZéSZâlHÖDY0ÖGVÇýÅoÜedVÀ?5×þDSB?VØGü8!VeGÈý1k5ÄÁÀk1?ea×VTV4×@ÿr6þcÐÖVV0VÈTÒ",
string: "0g0gÛ000ZZilÚñK|,Zn[ZZIŒHsÁð=lésZZhItQlËåJÖj?ÒGgl>kJ>TVGnê=?$HŒEðZn@ŒEG?K40Îï.*/PÒtn÷.ZZiIsç?Òš002001005?ÒTŒHŠ?ÒGZZIK|.OCêl|=OCGOEGl|4l|:E?9ÁþH<?;.*<?Òh?$HŒEgZZiíEðnéš?÷40Á>?Vg?CåI$òÁðéGTT<?900I*AŠVDYI$gSnGSK48Cð?VGlÚY|ðW<?-l|5Yc9lËêTVgEl^lËåIsQkc@.)šIsH?CHlËèOEH<?GJå?n÷/kû6<?.<?<<?WPãW?VHþóc?$g0í60wðlËHK;Znê<0Á@TV@<?å<?=<?ækl@0030T300000000080000000000008oS0000000000ao-ëC00000004ëk$K?h000000yS0uSòyK4ë001Rcë00ÊIû@h000?Idëïa4š4Ddë0li)9iD}cwü7Uï0dÈICþEÌIôCÚqG0nIÿ}N<0Št8Fx>02AÄMciJCUgûÔ~005a$FÃdUý×shg0003LÚÉgãSt8Ýë00000fÏHøCUåë00000000Kc}eK0000000001eÖN000",
logSide: "0g0g6âÐH{rHúiW-cYËyYa?Y50kcyX6hœcy4eSœ4i4{SQgNkQSiESÀSXTegÀëïwT0ÀìXy1Tg5kyh?g0kwhko0x3gko4x3C/8C5jE(wCX1Àg0SCj4iëSCh42X",
logTop: "0g0g9ËyY{rHâÐHGVZE*HiãWéîHýLWCkZ1210x0g0jO))U>OM3ÓGñIIGÀ3ÒÃO)O,(4àQQQQ-Sjî[äñá,T4á@QQá[(4î[]XX-S4î[]áá,Skî[QQX[T4à[ãäX-S4îQQQQ,Sjî)OO*,T3ññGGGG(3OQ)?QO(1010x0i0",
bedrock: "0g0g5ÎðW(IWVVHþÇHwíW4JA|iów(I%IÁ(APÒAk{5j]J^ïJ^A+1FyúMyÎÙw?TE?Pkú(üRdCÂdðlQióxiÆ1ù?ïG9òyÀÚ0NQùòcJ^c*hCkr1iòTG^(A?ERÀ",
glass: "0g0g5lEYe|Yí80ægHôcZ0000019AJPAú9wJPAû94JPAû8CJPAû9AJPAü9AJPAû9AJPAü9AJPAü9AJPAü9AJPAü9AJPAüFAJPAk9AJPwüFAJPAúCpAJP9",
cobblestone: "0g0g6ÚGZÎðWDAHÁ?WGlHóoY5C^óal!È?Äe?!CVÐmÕCíÕCl_K?öCAdì_TãI?UlÕA!cGbTeh|6wdþLÆMÁSGîÁCó_wmüCi$QgBmwÏÐr?MÈVmíÕ^ó8GlP)úT4?Ð",
mossyCobble: "0g0gbÎ?WÁàYDAHÇGWæ*HßlWÎðWóoYGlHÚGZÁ?W1yMj?6äBiñÞ)ÀÞÔÿÏßúÀ3úhåÓåMàågÀhdÎnÐÓâV3ì?ßþdwÝ,DgDåMnåiGhnúV1ÿÔúkÀgÝÀ+djÃ0aG(j1å0MhpûgÂÞjj4ÁÎßDj?ú?5þGÿ47ÞÀÿåhåâååpGþn1nÓûhmÔíÝ",
stoneBricks: "0g0g7óEYCÖZÇÒYéSZålYÖGYÎðW4JPAù2$(0dGixðlÙ8L&(sÎIyNiIß.ÈigAõ^?GlÚGl×?%JÉÚGAJR4JPë0Lxë3dð?&8rK,!Mi?ÚG?i(?J?ÏdiNGl×GlÚlÚJ_ÚG",
mossyStoneBricks: "0g0gcóEYCÖZÎ?WßlWæ*HÁàYéSZÇGWÇÒYålYÖGYÎðW1z)>xQ3?m7>R6ÓÏDgÔNNÓ(ãEmþÝ.KÖÖäpFþCÏ+AÕ9ßÖazDãýAGddyGaÔgïgIïVÉgQMh81hjQw06ÕgK036KÓAmùùCK6ÏÐpÖÓÝÓÓJA3@6aadyA4ÖþÖEGFÕÿådAgVÉIïVgV",
bricks: "0g0g9eXZaUWòGHIcWCnZö>ZéjHÝSWEÆZ0iO(0k(0hUÒhhUÎhÔäGVÔáâÓy]RyA]RyO0gk(0giÎhlÑÒVVÑÒmÓäGÒÄáRyA]Qyy]0kO(gkO0hUÁhhÑÁhÓáÓVÓäÒVA]Ryy]Ryg0gi(0gkÎhhUÁhhÑãÓÓäãÓÓäRyy]QyAI",
lapisOre: "0g0ge÷-ZéSZâlHÖDYËâZpÉZxÕYloZglZCóWhqZ?hZ×ÍHg?Z1gixzyg0h)>w1jQiiÄÅ)Rwñh19aDEhùyxiAR1Q2hgj?cjÕzwx]Hg1H0h!ga4Opw1bI1/?GkRpúM/Ég/OMOCzôh#Îhé?ga1ceiadOçeAE0iHÁHòFúixÉåpúyxhh9úhhh0",
redstoneOre: "0g0geJ-ZéSZâlHÖDYÖâZügHigHt0WTâZigHü0WtEYHPWsÞZ00ixzyhhhxxhhjNiiOzQyxhhhi*VOyiyxCÄäAiRhgwÿghhÚwxhc?2ighA>zyhAQh%ï1g5ÒÕLl?h01ihIMxyOx$?yhj)Qhh0giBLlTmkN0gôhyg2wixc1hh00hhhyg1ih",
emeraldOre: "0g0gc÷-ZéSZâlHÖDYÁcWltYnãW1nY*ÐZ>iHuÏYnkH00ixzyhhhQg01QNikÄyhAÄhhhÔhT0Ô2yxh4ìg02hgg9ARzzwx-ýæìxkTA]ÿeXy?Î?ÎG0yhmßmÝ0h1Q(1(xgjpANyhhh1åÅcgiyQiçæEN0kÄiEC2wixÔ1(1g0hh0yg0ih",
diamondOre: "0g0ga÷-ZéSZâlHÒþHv|HGaWyÇY÷gWlZHCóW1gixzyg0hx(01iOxiOSjNzÄh01Ý*Ô1Ýyxhz(Þx2hgi-Ãiïzwy8U@Þ@hh3(åGO7ga*[1zïxh2nÞMB@Ô9úMxR(G3Nyhhg02*K1i3M2ÆU@20âÐxþ[ÝhiD01gÞyxhhhwhhh0",
goldOre: "0g0ga÷-ZâlHéSZÖDYaiWËâZoÝZZGYCóWZTH00hijhyyyiRzyz*xxO3UMlURw2*@TB@TizUÔ>0ÓíwzÔåÎjIgiwðã]hyyhOoÕíhmR3@8]0yNxxÔíë2VÃ2(I1OlQÐMyO(2)Óÿ>xQÎAoÔäì4Ôÿ8i@ìgxðÝyyI0Kywíhw2xy",
ironOre: "0g0g9÷-ZéSZâlHÖDYâüZòlHE,HLgW?aY1hixzyy0hzMg1?UiiÄÂjylÎhlÔ1zOxiyw0z*ÄÒOxghÄGñÎBKxg0ÔÝig1yjN01zMh0*ÐNkÄRig@ÔÝgÔ01M0ä3x0iyhh0ghkÀgiNÄ2?ÔãÂ5Ïgi6äK1gUxhg01hh0hyh0ih",
coalOre: "0g0ga÷-ZéSZâlHÖDYËâZAJH-SH)lH$EZPzZ00ixzyhhhxxQTj)iiOAÄáxñhkyoÔAÁiyBßy]VRyhg1x02A>wwiRyiÕÑhAAÄXh@ú02lÖäiiyigAñRw1kTM2Qiiy?ÐhQAhxQyykÇâÀ4þÂO2@UyAâRxiyhähTh0hyx2g1ih",
coalBlock: "0g0g5sÞZkÁHc(Z4gHECY0ü_ÑD?ACaÒ)SFGòÚEP|c1AEÃÚg9FEa$J^ÚGòÕiûÖiPÑü?y2ÃÒCI4ülÚkTF(ÉEC^ÚJú5NúFG]ÚüX5g9ÚCxÙíÃÚgÃÕJaQJòQül",
ironBlock: "0g0gbl;ZIcWSKWRHZŒEYOCHGŒYE?WnéZ?÷WlËH1g0001hgiyyO)VVÁlVVVVVVÄäIIIaAEdiyyzOVVÄlVVVVVVÄäIIaaEEdizOOVVVÄlVVVVVVÄäIIIòaEdiyyzO*VÄlVVVVVVÄäIIòaAEdiyzO*VVÄlVVVVVVÄhhhmÎÓÓÓ",
goldBlock: "0g0g9SNHšrWLÃWZŠWZTZZGZZÐZZXYjNH00h01hg23QVO*ÄÐN4ÓàVKh7N4Ô*ÅK0GÂlâVã0ÔãÂlVÅK6VKo3VGãÒÄ1o3ÅGÓGK18lGãÔãK0ÏlGÓGÓÓ7ÏmãÒÄÓÓÅ8gÓVK65Ä8gÒÄ1gGKÏhGKh6Ó0ßgg1gÓ0ÔÆyíEIyIyI",
diamondBlock: "0g0g9_HHW÷HncHlZHZZZctYÔNWàRWeŒZ00h01hg23QVO*ÄÐN4ÓàVKh7N4Ô*ÅK0GÂlâVã0ÔãÂlVÅK6VKo3VGãÒÄ1o3ÅGÓGK18lGãÔãK0ÏlGÓGÓÓ7ÏmãÒÄÓÓÅ8gÓVK65Ä8gÒÄ1gGKÏhGKh6Ó0ßgg1gÓ0ÔÆyíEIyIyI",
redstoneBlock: "0g0g5?ëYHëYCKYÝ(WüÀW0000004íÂQí]4XAPyI4czßCI0ds}Q05@lÚEI5ÐlÚI8a@lÚGù9olÚI859q÷]I5]ldië4dsÛ]i5BAJAù0iköyI4ù9]J]000000",
netheriteBlock: "0g0gN)EZ(CY-IH(CZ$CYwÎY?4WV?WV?H|kHwÎZV*WSsWP4HPkH|AY|AZ?4HPkYwÞZQsWT4H|kYSSZ;?Y|kZPAZ-lH)IH;sW?kY;?Z-IW?kHT4W-?Y-lY)IWwßW-?Z(JY$íW$JHAßW;lZPkWwÞYEJH$JYsÎY0gí8wí8wî8x5gÎIsß8sÞIsÞó8ed-sg?zö*zû8âl)Òþ?ÒöËXÃ8à{pÐÇTDÁËej8áVolÀx6JËI4ÙáËMmÇSñú?îj8áaéCÇÒü{VSûëáþÒýcïEðNMXëágx3cMllpìXdÑm-?tM?rüxDüG|Æ?Ña?r2ìD4o6?jAÚshDcØgoreTsgT!E3QgÎÿ(löÊÐ|qlrHGl~1jgM4|MÞ",
lapisBlock: "0g0gdB×YxPZ*aWMIYtFHxEYsOWt8Ho?Ho?Yt7ZFÆZkIW100gzkkkljÁÄâÓâÆ5MnVâåÒæ7ÁVÒÁãÔæ5ÞÅGÒrãÈbVVGÔgÄä5gââåÔÅ×7ÅÔGgþÔADÔããÅãýÈDÓÞÄãÓþÆ7ÖÒlÔÅÖÆnâaÔÓlãä5ãÇþÖâÅÙlÅÓÓþÔGÆ@ÅGÓãÓâÊoIIñõa??",
emeraldBlock: "0g0g6nkHqeHîLZ>iHnãWuÏY0000019AAÖ]n800w0Ëc)ûJ@Ë8w00mV8wJÚoÒcwaúA?c(AúA?8(?4gÒc(?CgÒchAim?giPAþ?cB01GÒgJPAJËg]4ù8l+lÚGlÖ",
tntTop: "0g0g7?eYO1Y÷-ZEÂHVVHùeWgTZ4ë]4ë]FNûFNû!ÂD?ËýÛIeÜÓR4œ]4N]FNeó;û!]G?ÇýÛl+L[e4òGlc]!{GL;û!Ãþ?ÖlÛ?EøÄR4hÝ?i]!NcMOjFÂýFÂýÛLRÛLR",
tntSides: "0g0gaO1Y?eYEÂHùeWZZZK;ZnÚY)lHoÐZH?W0i0i0i0ihzhzhzhzhzhzhzhzhzhzhzhzhzhzhzhz?ÓVÓÒÄÓÑ@GðâÆÔäUÖÆVGÅÄãÓ?ÔÓãGVïþ@ÆÄâÆVðUaaaaaaaayOyOyOyOhzhzhzhzhzhzhzhzhzhzhzhzyzyzyzyz",
tntBottom: "0g0g4EÂH?eY÷-ZùeWkkkkØØØØØØØØZZZZkkkkØØØØØØØØZZZZkkkkØØØØØØØØZZZZkkkkØØØØØØØØZZZZ",
acaciaLogSide: "0g0g6ÖïYÇQYåiYÁAWÇUZ÷nH50kcyX6hœcy4eSœ4i4{SQgNkQSiESÀSXTegÀëïwT0ÀìXy1Tg5kyh?g0kwhko0x3gko4x3C/8C5jE(wCX1Àg0SCj4iëSCh42X",
acaciaLogTop: "0g0gbÖïYVQYÁ)HPjZgîHeàWIeZöNYaRYcÃW?3Y1xizNj1g4Q??ÒUQTAGIAaaIÏkãÑQ?Q]>cXVVVVPÂ)üÆòAï]Á*ïÅVVïÆTBüÆÇýýPÀ5üÆÇïï]À5üÆVVýÆÁlXÆñòýPÂBüVVVV]Â)ü?QQ@]Ã)AAIIII>CQV?ÄVQTgNxg0iz(",
acaciaPlanks: "0g0g7gîHeàWIeZaRYcÃWöNYòiY4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂTAX40cùIzSaAAa4LgãllGSA4PkiA9cë0PNgÐ0IALRÉGËG",
birchLogSide: "0g0g8SHYn|HlÙZZZZHšZÎâH)LYRjY0C0Q4ëQ0rÎiÀÚJî04rÚ_gTGlSFÛdEEgwòTBãE4]ÚìL?+lÖviÎwnRglÙjZÚëù]+?1i?TGIÚsiB0ùfS&k6?QeGLCaÏl%9Àl5wù",
birchLogTop: "0g0gaZZZŒEHAÆWÁ)Hl8HilYlEZDÄHEGHGdH1xizNj1g4Q??ÒUQTAGIAaaIÏkãÑQ?Q]>BXVVVVPÂ)üÆòAï]Á*ïÅVVïÆTBüÆÇýýPÀ5üÆÇïï]À5üÆVVýÆÁlXÆñòýPÂBüVVVV]Â)ü?QQ@]Ã)AAIIII>AQV?ÄVQTgNxg0iz(",
birchPlanks: "0g0g7l8HilYlEZEGHGdHDÄHCCW4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
darkOakLogSide: "0g0g6;IZ(úW]nZEìW(úHÇiY50kcyX6hœcy4eSœ4i4{SQgNkQSiESÀSXTegÀëïwT0ÀìXy1Tg5kyh?g0kwhko0x3gko4x3C/8C5jE(wCX1Àg0SCj4iëSCh42X",
darkOakLogTop: "0g0gb(úH;IZ]nZEìW(úW{IY]eHÀnY(ÝZ-úW;cW1xxMi1iS?VÄÄãÒVÁBIadEEaßlñâVÄVÇÃmýÓÓÓÓÈÏ*cÖAdþÇÎCþÕÓÓþÖUmcÖ×DDÈÏmcÖ×þþÇÏ@cÖÓÓDÖÎmýÖAADÈÐCcÓÓÓÓÇK*cÄVVÅÇKBddaaaaÁlVÓÄÔÓVU4xjxjiRg",
darkOakPlanks: "0g0g7{IY]eHÀnY-úW;cW(ÝZEKZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
jungleLogSide: "0g0g9ÇhYÖNWéßHÀRHS?W;IWVMYâJHÎÏW1y3OOhg004S404VQQ@ä?US4xh0hy33O(Sh04Q6ñK03OÕÑ??Vh10OO02x??V1g>O(0iwQÁy00QOñðQO)Väë0hhgÕñ4?U>(>UhQ0xh6KQQjÕÓ3)Q010Q?ÀhTg01g>O00OO",
jungleLogTop: "0g0g9éßHÎÏWS?W;IWGmHdOHH+YýCHaiY1xiOyi1g4Q??ÒUQTAGGñIIGÏkãÑQ?Q[>BáVVVV]Â)XÅäñâ[Á*âÅVVâÅTBXÅÆïï]À5XÅÆââ[À5XÅVVïÅÁláÅGäï]Â*XVVVV[Ã)X?QQ@[ÃAññGGGGRAQV?ÄVQTgzxg0izw",
junglePlanks: "0g0g7GmHdOHH+YýCHaiYåÃHÖiZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
spruceLogSide: "0g0g6-úW(ÝY{IH$ÀY$ÝYUnZ50kcyX6hœcy4eSœ4i4{SQgNkQSiESÀSXTegÀëïwT0ÀìXy1Tg5kyh?g0kwhko0x3gko4x3C/8C5jE(wCX1Àg0SCj4iëSCh42X",
spruceLogTop: "0g0g8UnZQiWÇiHìîYåÐHòûYÎyZÞRZ4wSQ20%gsE+?d%HZTÐdÈlÞgAj.AJ[NLggT[cj]CûPAjgDlINjgDl[COgCûIcj.EnINjgAJ[CLgrÚlcfRGlÚAdgsþ@?40SQ2ë",
sprucePlanks: "0g0g7ìîYåÐHòûYÎyZÞRZÇiHUnZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
sand: "0g0g6OaYl/W?ØWlpHLoYREY4C??CAÑELõr8@+9AE?FNlPCIÓþóEþ^$üúÒNÇKgÇÛi?$þ_%EbÒiAÖüÇ5JÉ(EÃ(CiBoiÙüÇPGÇÒDôlmi?laECÇEEú?oò?kó$üÁ",
gravel: "0g0g8ÒÒYó7Zþ-ZÞDYþÇHìSZEóWEGZ5,$âl#þg_EÂ{gíIþA?GlÊG/ÚÓ?ngôdlCIÿIØ$#èßgRù?ÒcgÎðÅÖ$ÇncY#üLJáiÆEeKGj<Ùl#ElÙ..$BôFELO(LÉÐþcGDÚ)lË",
blackConcrete: "0g0g48wZ8MW4wZ8xWmesSÑØI?9ŠósKøS;îNÓyÀCKÃGX^æCsŒE<~R<GL4?tRNeøÌiKõ;SkNeEcNRgGr,?i",
blackWool: "0g0gfcMWcTH8MWgÁYoÎZcMHkÎZ8wZkÁY8xWAJYgTH4wZsßWwíH1w)5ÑßIFIEQg9Éir|gRô|Qo]ì|e<bnìeô8QGÆÂQDDd717rýbEQOG^ØE]hE@n5|ÕnQBL1ÉÇ:yÉGGG8EGEnQe@LGîEwIhQ0ÆGGhGND)XEò@oLôç|gLRô?XCVXgù?1NeÚ0|",
blueConcrete: "0g0g3$gW$GZ$IWlÀ?ÑT?QA]0@VUUh?Ckkw55kUÒoTlV0UhhgÑ0VUR0gÁ?QghX54UVS4Á0UýÁlÀUükÄ",
blueWool: "0g0gj$IH(?H$IW)?Y-šW(IH)oW$gW)OZ)?Z<:W-šH(?Y$GZ.aH<aY-oW<qY.aY0Q1ùcMeAwR^kcúõ0óiI$ÉA,gczc8ÐI]]o4Û#s?ï}>aJgO!ayg[hi?A1FiIkcÂþTöIÈõIEI8UCpj1]?xjA4Åoc#axER#oeaI!kcI^àI?-ðß?XcPhÀëXù1^îaI8}G;[ph5F2ìCdhc-NodièJIx4ÂiUSwhÊë5?K{NlÛ",
brownConcrete: "0g0g3ÊnZKrWKnZqÖlÄÄÄAþÏcVÄÈTÈÏADEÄÒÒýÑaaÈÒVÒlÄVJaúÒþïAýÓóÇaIAEaýÖþVaÖDþIÄdAÁVc",
brownWool: "0g0giÒ2WÖ2HÑrWÞiHåNZÖ2WâyYKrWÞyYÞiYìÃWéNZÚiHKnZéRZì>WåyYÚ2H0QxùcMeAw[PücúõhiiI$ÉAIgczc7Ðð]]o4Û#s?ï}OaJgOa2yg[hi?A1FiIXÁÂþTöIÈõIEI8UCpjg]?pjA4nocb2ÞERbyeaðFüDT^àI?-ðß?îcPh{KXùhRÐCC8}G;[ph5EIìCdhc:woMiçLIwiÂikSy.Êì5KK{nlÛ",
cyanConcrete: "0g0g3l?YloYl?H1IÀpE?SmkÀw6PÁB?S4k299úkÄRPÒÎwC?A2ÑIA8püUiSÒgý95Eòak?ý?1RÀFÀKSÒù",
cyanWool: "0g0gelsYm8ZmFWmPHlsZm.WloYmÖZmÇHmoZl?YmÇYmÖYm.H10zTÃKy6BGîa6pDpôa?F:nI*x:ú#PgxçÇROÓimO6Ó_@1@pÎ1GîyJñÇGNhG*g1:Vg<ÎgTpmF6poÓý?GaGgOç*GJÂ24Vh<4lÓlhÓHÓz%GÄlIeFÖlag?FEÃäh%gÑE1HúÉ4ô",
grayConcrete: "0g0g2)?Z-?Z00000000090000000000000000S100gg",
grayWool: "0g0gd-sW<4HTAZTkYTAY)?Z<kY-?Z?*W?AZ?)Z.4W-SZ00i0)ÀÓ7jIüh71Å1AhóÎ^QI>g!rq1EgòM1yV6cy5âa5051À1IyhmAMI@0I>d0!OdQÝûb15hc1pVj3IkIAQó>dmM10ObA03VjEVAIiÑI*>IüÎÁ^hÐIhDNò0ÑEÝþbÐg.0A",
greenConcrete: "0g0g2PÏHPßHh;EÉÙOßÆðM!lCÇylE|arÈëÀl?SdøcKæÙ",
greenWool: "0g0gh|íWÁúZÁcYÇ?H|úZVIYÇIYPßWVeYÓhYÁcZPÏHËnHËRHÇnHPßH|ßW0S1c4F÷4w7TÂúa^1icA!rkDMaOcÓCIS@I4{2Ai5&!ëìõRy91õ7.hh;13icù1^@M9]q^CCi8Âûl÷16iý÷M÷[k1yIÞEgyí,a]1ÂýpFàcÑEIKLíI80gëXÓ08ÃAB8ÌGNfgkÑCdMÈÿpaæõIFòÐgDwc]iQow-së5öÀ^N0Ù",
lightBlueConcrete: "0g0g3C$Yy$HysHiVUS1kklk?ÀgVKk4ÂlVTVlÁhS5UhhlxTTÁkVÁ9ÁhVgFSÀ1ì5Ò5VÎkh??TlV4VlSl",
lightBlueWool: "0g0gq&ÙZNaW!ÊZ/JY@tW&éW&öW=RZRTZC;Y!ÙZC{Y~uH[eW+eHy$H!{Y+hH_eH/nYRRZRtWNaHC$YNöW=nZ0Q1ùD/icö_p?icj2?OhMÙam^ÛQd@M7oØDÆß#cxïJ;^NV,h?yhPí_yN1%iOAmÐ9Á÷zØeoMj8ÆiuÂ1ezCÂ?xòsGIõeGRIELc?F?i?õüùðP7ûÊOö>Áàù?ü1ÝáDIEÂa(Åp7@(Œc?IwÛ{ÖEi{ÑðOcSÐ|òLhÇÒ(È{I~wlE",
lightGrayConcrete: "0g0g2éSHéSWàgGsaLÊlnZÍrYSGHn<O?:|GcŠGlTTÔTs",
lightGrayWool: "0g0giðnYðnZí7Y÷-HþÇWJ]YþÆZéSHí7HCåHAÖWóEWéSWó-H÷-YJÆZóDZAÖH0QxùxF÷xõ]pÂýpØi2Gw#ÂþLd?NCsCIo{ch×aLcï!!iNoO8iyg[TiCA19iG4_^]ÎöÐÂ^GCj8Âûl^g{Cþ!Oklk(aiìERaLcaÒ9ÂþhFU{ÑÐIóþNõ>g^ÀhøgRÃaÒë}âA[p6sCÐåÂýoØ:ÌcgP{@gcD^ín=2SUnTPÆ^c5^",
limeConcrete: "0g0g3ÌcYÏcYÌúY402ë00ë88ùEwg1204000ëëëAwëw2A0ó2Cì4A14gh00020wEë01g00oCìS081C820",
limeWool: "0g0ggÓeY×IYÏeYÛ?Yç1YÓIYãRYÏcYßnYÛnYßRYñNH×?YÌcYH1YHhZ1w)VÓßIyAg@?2ÊLj}ItõÛÓT×úÛI=ÊrúGcÇ@éÆÂQDDÌË1ËsB1g@O-_ÙgÕhgÓ?5Û×sÓB@ÁÊÂ;yÊkliÈg+g~ÓHÓsicFBIh@5Èéqhl~%)ðgCÓT@õlÛOŒZAoDGVðgB]1RMÑ5}",
magentaConcrete: "0g0g4ÐIZÐiWÐgZCgZ5ÒSüVÁPTÀUÆVÇ@?ì2Î^áÇISKÊ@n3Ä?45Ä@9ÎVoRtÞä4VVx}eãÁxQâ11Àhïxl50Î?",
magentaWool: "0g0gsEoHGšYELHELHgbWI:YEoYI#HI#YÐiWhrWELWhbWIrHlöWI:ZGšZGšZÐIZgaZI{W?ÙYhrHI#YI_ZGoYEiWJÊH0QNki/iBE_ÐÊOChqJp$Oéz/L??gógdKÜ]Xü)F@5?Ù?inFiõyüPÈ|>A1N>toÞàcßi×çø7.m8Ê?uApe>GARnAsI?|CSR?ysDdOÊOcjIgñÁ7c?Dù{hAkXÐpELD%8ÂAUPxUñ.GToœxÁ{?Pj÷E?aFgàJawzÇeÎðýA~ìas",
orangeConcrete: "0g0g2nëWnëWRgguhKoCiù124Sw0x8QùG2Áe1ÄSSSo40",
orangeWool: "0g0gmOCHREYOùHOCHRIWŠRYOCYSnHSnYnëWR?WOùWšRYš1ZRhZREZšiWšNHR?HŠRZS?HšyH0QNki/iBE_x?icKq?sI&Ùu]i~QgðM7w_7HùOc25ö:õRýFNõyüPi|3A1NRSAÜÐCÂhiØeoMi8Æiudpô3CdR4ÓAKO?E-ROCLcLM?ixõÙgðT7îÌcùQhdSHÐpõácOäÂþiPxUð(ŒT?ic~Ph7icö]oEOÐ{Öx?ÇaxHcÝ}?aE",
pinkConcrete: "0g0g3lAZlaW?AZ5QSÀ14gkgk01gQ1À0gQ4000ghÀS0?0]9kgk41Q42T4g01hÁ105k4S4hS00gggQÁS",
pinkWool: "0g0gvO?YRšWnIHr!YsçYOOZOOZsÉWsØH?dWnIYs/ZngHr/Ys?YsôZrqHraHlaWsAWsHHs^Zs?HsçHraWsaZ?aWOŠZsôYsEWs_W0Q1ùD/ice{ÖNOCh3dp((è?/}eQkô.7ÕÜ-Nà$D+ï?;aLË/L?ihPÏ_No1&îmooàgÞ÷bçø7.l8Ê?uå1eOcgRpHAGN{Ih{N(TCuFNncjKÀñ|7Œ?eö|ÁéNNI1ãád7háA?Apmñ-œTœœcÞk?-eÛcr9ESàJGc0ÎàÀÏãë~ùlS",
purpleConcrete: "0g0g4ÑòZÑåZKåYÑåYlm100?þTNVQgp5820Áe0S2RV1Àlhgìg4pLjok0ÆT)S?lüUìlLRS1ý0TTp0T]Q4T1",
purpleWool: "0g0gmÙóWÝAHÕóWáAYëgWÙAWèEZÑòZäEYÕòZýcZXgWáAHÑåZX?HI?YäEZèGZõlZXgHÙAHI?H0Q1ù5MeAwPTücúì2^mCzÉí,G1zcpEðS]NXÛ3s?5Ã(hígOCaJg[PhNs11ijü1ÂþTõÕÈõIEù8UCpl1]?plAÃPA1C^ÞEPc2eað1ücI^aI?-ðßiîc]gcKXú0EÐAC8}åhDphlEIòCdú1-?nöiéÀIwiÂ?]Qw]D05Lo|(1Û",
redConcrete: "0g0g1õíW",
redWool: "0g0gdüíWAJWùíWAJWÐCWCCWCJWGLZÐCHõíWEEHECHAíW1w)0VwÓ2*GïM21JjójEÎÈVdVM^h/3EMçÃ3QFi2Q2ya919hw1GQO+ñÃGÄhGVe0^VeV$g1I2OyIoJ+5G*GGVæVÐmÃ30Óh?0IylhJGF)ÒGÂVdgÎûÈOdEODUäcÒgwG1EMÉ0ó",
whiteConcrete: "0g0g3KËHlËHK|H4?541S4k40ggh50g?À0Àk1wA0l4g04U0kQ?À4l00U01hÁ0044Àl0hÁ1QÀkTg4Á5h",
whiteWool: "0g0gnlêW?CHléZléZŒEYSnHl÷Wn÷WSKWSnHlÚYŒHZlÚYRKWZZZTRYOCYlËHlÚZOEYRHZlËYSRY0QNkIRU*EÙÉÊOD1reoiOçI,=ì_Lÿ.%Æ^rXø)uSïKÙ?EýV/Kyü×J÷SU1*RmsÎàEÂiØçú7.)8Ê?cRpis*R^ÑGCI-}iSÂ;2šEdOÊOcjçLÿ<EçiGùØpAkXdp÷lE%8×dGVxÄÿ.E^sOcÎELŠJràÿ7ecàjæAzÎcTïrAÀRaR",
yellowConcrete: "0g0g4rIHreHrIYreHlV01zs@S1àÁá?hn4S9551ÿOÄúKV14ÁVÁN[lÃÆsÁllhhIIRlrh(0oUVUV{Á{0SlQh",
yellowWool: "0g0gjsnZsRZs?YsnYTiHZ>WTyYTNZrIHr?YZÐZS2WT2WZÃHZÃYTyHZNZZ>HsrW0QNk0MkygPxüCaØqSGA$#ÄI*Œ:}GEowKlXö2LL5ÁO0RI890yü]^0kw122GëßÂô2hX!õgER8Ucaeowlpe.LoA1ahJ$Ra?UxÓ1üDt^ô}â)oÖÄ>gQgcKXdo2Ñy@8ÀIG]x]âEI.AÐAô>eLMEàIGùkÁSnAz]yRïEK|hëe",
bookshelf: "0g0gtE*WCkZaLWéîZ$ìW)cHAÞWMÕZF,YSIYùTWEKYòrYMóWáhHHÁHãMWGlHóEYi+YjþZKCHËhZdcWHÓWVCYPAY;SZÖÃW0RxcRgRgIw18RüXx^ÐCë1ÂýFF^?þCCiAOdFXÑDCÏcNOdCí?DCá3nÅgEENoCK2Eý.m#w?ungMóÂA0Mõ020XgõygRh8K1^Ðm?FcÂAë3LÄCmÂÃÙCCkÒãCmÃIb}?clãcÉàlb@U3nãcÉ!cb}NaaiuL?ýÙn06M^Ã06Mõ00",
netherBricks: "0g0g7oMW;ßHQJYwTH(ÎZEÁY-ÎZ000000BmÂQþòþÎCJKÑAÅBEÅA0+h0+hÒAãÑA}7PAbPAæP%æ_cÙ03Ù03?cA?eCùÖ2ùÖ6eOuýIudEldEl?ÔJ_ÓþJTCaTAJ?AJTA",
redNetherBricks: "0g0g7$0WÕTHÝÁY)0WQgH-gHUMW000000BmÂQþòþÎCJKÑAÅBEÅA0+h0+hÒAãÑA}7PAbPAæP%æ_cÙ03Ù03?cA?eCùÖ2ùÖ6eOuýIudEldEl?ÔJ_ÓþJTCaTAJ?AJTA",
netherQuartzOre: "0g0gcÀÁHUíWÀÎYÑCYÝIWSÁHeiYl#YGAZï4WŒaZÚÑW12NQOÃ)MjMBzQ5Ow>>l@äwN)ü)^GÑT3zPQdÑûQAM4@ôPÔØO>3QGGäE)ÑT5CðG>!òN)óKOQæÑzPdR))ÐEk,ôÂ@QGÂN@E5×SRi3>A-ä4-(k)P@ímòSzQûxÒ))Oy)R)lzQO",
netherrack: "0g0g7ÀÁHUíWÀÎYÑCYÝIWSÁHï4W4CCÛgp%ýÃIÄk÷ORÒ6A?iõßglA)oj?phú+úD?e#sö7)XU?2)sÖiùÛ@s}ÕoÞi2MioA?×Ö@ïÁóóe*o][oMIC]gC}{?VIrPiA*.r",
netherWartBlock: "0g0g6Æ0WÕgWä0WHIWüÎYEíW5waPi8PEkQëúEJJTwC5A8h4ElA2EJúh#0PwÀxAìP)2QyhFRiS0úPwiTAòògí5w]C4ú92aQX?^2ù]ki?2íSAíP4í]FR])X]B2",
quartzBlockBottom: "0g0g3REHRaZŒöY05Èë?ÈÐ1ÄEù5Ec0ÄcÈþEÄEÈdV0EV01VU1×À0þù05006E05EC0ÇÒ0Vc05DÀ1ÄS01E",
quartzBlockSide: "0g0g6SHZREHRaZŒöY?éWnÙY0000005AaÚJ{9+lÕJV%GLACý%AaÖ+N9+lPGN9yPÚGý4J^PAý4Cl]J|9+òAJV4JPB+N4JÂÚGJ4üA|y|9CLAJV%)òACüJlAJ_Ú",
quartzBlockTop: "0g0g6SHZREHRaZŒöY?éWnÙY0000005AaÚJ{9+lÕJV%GLACý%AaÖ+N9+lPGN9yPÚGý4J^PAý4Cl]J|9+òAJV4JPB+N4JÂÚGJ4üA|y|9CLAJV%)òACüJlAJ_Ú",
quartzPillar: "0g0g4?éWREHSHZŒöYh&Ntiu&%urLn&n?rr%xNn%%&nrnyL???Nyr%urunrNhLnNLinL??nuyr%&%Rtrt?",
quartzPillarTop: "0g0g5?éWnÙYŒöYREHSHZ54Aó6ÁP4ù90úFDs÷)JÎ.rJ@ë1hJP8ióQ?údi^*i^FjògkíF2^?k×D4×?i2CL^QlúdkThJP8h1.AJ@îPDAJ)úF0J90J8ek|yò",
chiseledQuartzBlock: "0g0g6nÙYREHRaZŒöY?éWSHZ4Ja]+]5BrÙi]9,A0iÀdGk4üüd9wJ0N9_PFE?i2Ñ1E0GJÎxA|ACIÀJPi@ëùa4kíPB.{4ìwJ0]Xû]mJ]òDw0iÀd*%AAù4û9CC?",
chiseledQuartzBlockTop: "0g0g5nÙYREHSHZ?éWRaZ4CLMJChE4ë6NgB1ìENgD2ì-zg+Tí0biiR÷RK002öE0(CÂJiJJPAJPA00põ039kÈöpz8,2ö+wÑ@RëEwÝRìík8hG1ìEgiRLúJC",
chiseledStoneBricks: "0g0g7CÖZóEYÖGYéSZÇÒYÎðWålY00]0ëRdGlÖ+N&?AGlü!090óáe2NÚEÊe7J?oÊ!nCïE)&cCìok!nCñE)aÿIBÐ)eð?LEáeõEI!ÊdÉÑJÈáA2S0Js:;eç$üÂPAJPA",
smoothStone: "0g0g7éSZâlH÷-ZEEYCóWE?WCåZ42ÂByg&,ÚeOqOÖsJ+?m?lGgy|Isãlp*GlÛÖC|lÒei?ÃÖClPÕmG?Úio%G?GgÕ&.+úi?dgÚgg×Â[ÙßÚqlileG?N:Øãgx5wiSJg",
soulSand: "0g0g6ÇjYSiH)CW]LZÖQHåïW4A3{c4ëhÕBCyÁIFcCnMItöþiTiJõG]dIUdhpÖ(KÙq3ÚC3ÏÈRc+IKPRì(qyIoÖIh}No{RCÑwlRIwÒðAëIÐAGAÐ^T$4Iö-pTÿd",
glowstone: "0g0g8TÔHjlHïRYÚiWZZZZJYòcYÞNH5+T%^ÄCY?äLb??cTEÌKgÃrãsè?_mcÐÕÈ2weKRùb~?>rGÍä$acÓHÂñiCEe+ÿEFùÂÑDSÜDï?Hgsnœ5ojiÈr#ò_iícÜycNloÍGt",
andesite: "0g0g6éSZâlHCåZóEZÖDYEdY4DIò61aELei2BGõwAh]iLV+peC0ÚE^Úðj6Rlc!ìóDlTed|ðLÙüÃÖëeÒ+ë4LlÙ({*ChïE!S+rÖ)AÙg?dGlVESÚiiÎëo$m3c)A",
diorite: "0g0g6óEYDóWHtWŒEYK;ZåOY4üIPAa)yR×,gÎ+E?GóÒGbÕX_{oî|i?ö+N]CiÖo?hGFM2óöGTQLÉúpbcEjKÐNNxRò+lÚóAA(Ã&njÝü^wÐìÞi?X6iöCcÒ+NNgÉ",
granite: "0g0gaGÖWacYúïWéUH{LZGDHdLHË3HiÆW?aZ1xMihTÁmiãoMjMjNnhiCMûnlnihÅmÏNhNjzGwÎyjh+ÏjÞygMMmÐhjÓÏOjh1A,ÓMylxjÓÐNhMÓCM+ÐljmÓ2ÞMEh,+ÓnÎj>h+RRNMhMzhFiÓMDNÓxhoÓzãiÓgMÓh2yMMh+",
polishedAndesite: "0g0g9DaZGiZó.ZðEHésWÞlWÖgWÇâYóPW11hhh1gijQ>OÃ)Ñ,jOO)SIO[3Õ8Q)Oî,jO*NîQQ,k>)Q*OQ@jOX-Iy)Åk>QQÄUO+jEÃO-ë8ñj>)>)>N,j-ëXQIO,mOOOIOIÅjIí)QÑ(ñjOQQOíQ,kQ]îO)>,ðGGGGÓGG",
polishedDiorite: "0g0g8O÷HlÚYGœW?$YEGYåsWÎþWó-Y0i00J25+_5@VAkòKEC$gz%)ýxiA!)I5CiiC}cùTÛyC92I$dmMEÉQ-a$þû%CdB]ôÕE}cIl1üadíLdjm9þA!(þtCIÖþaSÉãLRÛ",
polishedGranite: "0g0g9iÆWGÖWGDHdLHacYúïWéUHË3H{LZ00gwy2zz4VQU)QV?kk>)QÑR[4QÑVUOV@4QQ>VQQÄCUVQQÁU@5>)ÂQQQÅ4QQ@U>)@B@ÒQOQVBAQ?U?UQ@lQQQQAV@4TVQÑQ@Å4OQQ>)V[BU?ÏQU>+AQUQVQT[ÔGIGäGGI",
portal: "0g0guS7YU8YQ7Z-6Z-6Y(6W)6H(4Z(5Y;7H(5H(4H(4Y)4W)6YS7H(5Z{8H-7WÀ8Y(5W]8WÆ8Z(4WÊ9W;7WKpHÀ8H)3ZKpW0QNkIxk4dÙg0B)EèwýtaT0âþNa[.tDÇÐEðGRo:eŒcmÆIŒÇÆEQØPÊgÁÐë?egpdcÃgPkD*eyN?ÒygkjõEïtwÒÀsFcÆNøòÃq$œÎI4üû*gt?Ð!sgÂðNmIj8M$zGL|CI6&âCcAhárðCdJÕG×DÞeq$Eí-Ûì5?TJlFp_k?I",
obsidian: "0g0g540Y00WgMZ-ýHAàZ4Jg&1s4yìÕ8kBGQòl8&B28ùìMAPAë8Pië1h9]EN6g]5)óAJnBiüëAJIüASCëSg20ücE4RdiJdCJö4kú0a]0K(4w9g]SCkQ00",
redstoneDust: "0g0g4ù0=00=?$HI0=1UlS5UlÀlÀ1UÄC2cÄC2cÄ00cU00B1Á?01h40ÁÁ?5U1)BÄ00BÄë0cmë!C5ÀlÀ1UlS",
redstoneDustOn: "0g0g500=s0=?$H?0=G0=001w00001w00009Aë00AôÑCë0AòACë0yPXCë0ilõJëAûzúJPAþnùiP0þÑðiS0m?ÒJë0yÇXJë0APAüë0APFAë009w00001w00",
bufferMiddle:"0g0g5TRH8wHÝwHIwHEwH001w00001w00001w00001w00001w00001w000JPAJS0kAöi00iûÕù002ÂÕë000ÃQë000_Ñ00009A00001w00001w00001w00",
bufferTop:"0g0g8TRH8wHëwHùwHCwH?wHEwHhwH001w00001w00001w00009A0000^Që002ÂÕù00iüÚiSAýBúCP0ügeAP0idòiS02C]ù002ÂQë000^A00009w00001w00001w00",
soup:"0g0garwHI[=I{HŒDHTRHShHØDHic=ÃBHThH0000gw003(00000000000w2000020000300S00w00(00000033050000060000wÝ300000w006800À000000000000À5200036ÀùÂ00030804000000000w000000000",
soup2:"0g0gys0=ÃyHÁó;I{He!HÃ!;KJHwc;íðHÐz;eóHÐ%HÐ!Hic=y3;Ï|;i|;I[=!QHdíHeyHÏ@;Þö;eîHo8Hs52ß|;E@;TIHEAHsweGëHšRHß1H00RcSîkKïsìI0wëARPAÎiwìIEe@(h4AÏRw3[gÎ÷(>4;2RS(7AÏ_$wQQÑ9TAJgÐbAû4p(üPÃ[Aúb$EðoEû|Ã[giPogôoKë|Ã[oÎðÊIXAÒcÎ+7ÆCðÊÏQki{ÁÃ>ECÿ(Ï?(Ï{0+[$GíoK_oT2g0oVÄ?-ÎðgT4kMNVLXhÁJPÅí0+oUTùkïv<wC1ìNX(Ill7ÁDËÎìN",
soup3:"0g0gsk>ó000Æ}EFAcÆ}óFh;Gw)GB)ÈrEFw;ÀJþG!GFA(E>óÆ}÷ÃÛþEB6GKEG%ðFîóG$)ÃÚþFCAGwEE36?h;GB6Nrð0QMXQg^zox8QxAx!ixF^o@hòKTùiE!hLhìiàXC0ì0Xxù!çNíí!]iOcPÐíE?j^Äzõ?C?,E1æÂß8àÐ?EEx_õ*8ÒÒRpALÈSA8{ßnÑJ62È?ì>tE*4+äuòEgpÓÇG%hßi*npÌüAÝiÆaL%oLícbr6iÒãp@aTqagï(ãaÌØœw",
soup4:"0g0gaßë;ßh;IL;ML;00;lë;I0;r0;iÓ;rC;000000000g0yh0hg0gwhw00(0g0000(004T21gO005Á06hj30VÁ063h00VÀ0ãÝ300VÀgGÝ000VVgGÝ100lVÀ10h0801g9ùg00000aag0hìë0aa0g80h09ù0h0ë100000",
randomSoup:function(n) {
let r = 0, g = 0, b = 0
for (let x = 0; x < 16; x++) {
for (let y = 0; y < 16; y++) {
r = Math.random()*255
g = Math.random()*255
b = Math.random()*255
setPixel(n, x, y, r, g, b)
}
}
},
redStain:"0g0ggs0;s0)s0$s0Cs0us0ms0cs08s02s0as0ks0qs0ws0As0Es0g1z?ÔòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?1z?SòeJ?",
invis:"0g0g20003Rë0000(0=0>ëëëìHc;YnTKsëSNZëtÿKn60",
"poision potion":"0g0g4000ch;00;rf;0000000001S009K008w00bN00bN00L-00Yj00Yj00Yt00Ls00aC0000000000000",
darkLeaves: function(n) {
var r = 0, g = 0, b = 0, a = 0;
for (var x = 0; x < 16; x++) {
for (var y = 0; y < 16; y++) {
r = 0;
g = Math.floor(Math.random() * 10 + 100);
b = Math.floor(Math.random() * 10);
if (Math.random() < 0.35) {
a = 0;
} else {
a = 255;
}
setPixel(n, x, y, r, g, b, a);
}
}
},
redBerryLeaves: function(n) {
var r = 0, g = 0, b = 0, a = 0;
for (var x = 0; x < 16; x++) {
for (var y = 0; y < 16; y++) {
r = 0;
g = Math.floor(Math.random() * 30 + 100);
b = Math.floor(Math.random() * 30);
if (Math.random() < 0.35) {
a = 0;
} else {
a = 255;
}
if (Math.random() < 0.10) {
r = 255;
g = 50;
b = 0;
} else {
r = 0;
}
setPixel(n, x, y, r, g, b, a);
}
}
},
blueBerryLeaves: function(n) {
var r = 0, g = 0, b = 0, a = 0;
for (var x = 0; x < 16; x++) {
for (var y = 0; y < 16; y++) {
r = 0;
g = Math.floor(Math.random() * 30 + 100);
b = Math.floor(Math.random() * 30);
if (Math.random() < 0.35) {
a = 0;
} else {
a = 255;
}
if (Math.random() < 0.10) {
r = 0;
g = 0;
b = 255;
} else {
b = Math.floor(Math.random() * 30);
}
setPixel(n, x, y, r, g, b, a);
}
}
},
autumnLeaves: function(n) {
var r = 0, g = 0, b = 0, a = 0;
for (var x = 0; x < 16; x++) {
for (var y = 0; y < 16; y++) {
r = 250;
g = Math.floor(Math.random() * 80 + 100);
b = Math.floor(Math.random() * 30);
if (Math.random() < 0.30) {
a = 0;
} else {
a = 255;
}
setPixel(n, x, y, r, g, b, a);
}
}
},
pinkLeaves: function(n) {
var r = 0, g = 0, b = 0, a = 0;
for (var x = 0; x < 16; x++) {
for (var y = 0; y < 16; y++) {
r = 255;
g = 205;
b = 226;
if (Math.random() < 0.30) {
a = 0;
} else {
a = 255;
}
if (Math.random() < 0.30) {
r = 255;
g = 185;
b = 196;
} else {
r = 255;
g = 225;
b = 236;
}
setPixel(n, x, y, r, g, b, a);
}
}
},
flowerOftheValley: "0g0g8000H5YÏiZZZZŒEYÂRYlÚY+0Y0000000000000000000000000ië0001hE0001n?0000750À02Ôø2C02K5nw0007sC0007OÝ0007Eë0007Åë0007t00007000",
poppy: "0g0gd000GgYK0Hõ0WkgY-0WQ0Wù0HsgZhhWhëWmgWhEW00000000000000000000000000000000000000000000h000000iMS00004?ÔÝ00008XG000000PC0000000E0000000E0000000E000009EEg00000ùI0000009d000",
dandelion: "0g0g7000KÀWSNWGrWJSWewW5ëW00000000000000000000000000000000000000000000000000À|00009À0000ûùë0005C00005l0001e?0000*h00005h00",
blueOrchid: "0g0gj000q|HtkZOWY!ZZ!YY=(Hu|Hq|W=wY=(Y!YZpkYmgWCYYtkYmwWiwWqgW0000000000000000000w000000008K002k5w03sC000C5E0Jë0000FR0ihE000iE0gq2ë000[003iÀ000000042ë00000002ë000000004Q000000000A000000000i000000000q000000000X0000000000000",
pinkTulip: "0g0gc000SÍWotYNeZ@NWÄJZMkZÄíZRhZ*rZ}ÏWÂRZ0000000000000000000gg000000xw000000N(0000003000004À6400000ä55S0000ñ55ù0000Abaù0000üüÇ00000bUg000009ïù000000aù0000009000000000000",
orangeTulip: "0g0gg000OhZnnZlcWn?YJÝYnIZ?KZÄCZ%kY@NW}RY+0YÂíY}ÏWRxY0000000000000000000gw000000)(000000ÄÀ0000007000000ë9a00000ÐbbC0000Jc8h0000jE?h0000Kióh0000bšH000008sh000008Th000000c000000000000",
redTulip: "0g0gd000LCWLkZiCWkhYhùWÂÏZÈîHÏlH=MHÌeHÈCZ^ÂH0000000000000000000gw000000)(000000ÂÀ000000300000067800000Ô98K0000Aÿaù0000Aÿaù00006ðA000009ãI000000Ai000000ÿi0000009000000000000",
whiteTulip: "0g0gd000SKWŒEYnéZl|WRxYFhHÂíH^NH}ßH%NH/1H^ÁY0000000000000000000gg000000xw000000N(000000400000056070000Å80ý0000da9G0000ÐÐcC0000câeC0000aïG000000dg000000ÐE000000a000000000000",
azureBluet: "0g0g7000lêHSIZOeWÄÂZ@iH<?Y00000000000000000000000000000000000000100000Aw0000Òd000CbÝë00-MU000dEìC000líg000?ù00004C00004000",
cornFlower: "0g0gb000ßWW?EYÏeYF;HSgY%CHöHWÄ)ZÈâW<?H000000000000000000000000000000000011z00000xiNw00003QÂS000006Ý0000008ë0000000K00000ë0ë0000080ù00000aëù000000Ðù0000006ù0000000K000",
purpleFlower: "0g0g8000AfZ{nYL~ZgLY6wW1ëWÇ3W000000000000000000000000000000001w0000aÞë000lE0000cPë000th0000700000<000006C00000H00007h00000h00",
oxeyeDaisy: "0g0gb000SnHnéZRHZŒAZlxYÂRZÄJZMkZ@NW*rZ000000000000000000010000001xx000003?R00000hVÁg00002?>000001xx0000001K0000007ë00000060000008Ö0000000ò80000007ë0000006ë000000a0000",
allium: "0g0gg000hnYgcYiWYhYYNRYgÜYivYLeY?fYÓGHôCWÛLZH5Y×IZÌûZ0000000000000000000ig000003AÂ00000llCÝ0000ÓïDK00009iÁ000000×l000000b0000000c0000000a0000000c0000000d0000000b0000000e0000000f0000",
lilacTop: "0g0gj000LdHNÍWgeWaòZgeHaóWÂÏYÄEYcóW@RW^NWdrWLdW^RW9rW?ÍWÂEHÂEY0000000000000000000002w0000(ë006hë004hë000xù00i(00002k01ð000000t0^ë0000001ÙÀ00000000o0cM)03Qg083c1ë002O07Ki00000ÔC1À06X0004E(o0hc000003wiS00006ë0(où0000?00úh000",
lilacBottom: "0g0gl000geWLdHdrWÂÏYgeH9rWcóWÄEY^NWaóWNÍWÂEY^RW?ÍH@RWaòZLdW?ÍW@NWhrW00h43w0h8000Ãs8]kBë0003öXr{C000000}äe0000000(E00000000gÀ0h&w001]0ä6CI0002ACSK0000XgtSw0000kÄcë8A000002jöE00000008s402Eë000004åNli00000doj00000000C000000000C0000",
peonyTop: "0g0gq000oKWRvZ?øHŒvZtÎZ?ÍHScZ?~Wp1ZxìZl1ZoKHxÏWcIH?ÍWN~Wg?YpiWtìZp2WxíWgIYgIHRLZoKH0000000000000000000000000000000000000000000000200000x800Qg0002(ùSFXÞI004ha9Â?wX002x(IÃÊSë0013.!ÙÑ9G0002G%CÉÈ003VÉ^OôÐg000E?gcáÖÇü0006(ÏiUÁ(0000I[*OÞ800006fácw00",
peonyBottom: "0g0gv000tÎZxíWg?YxÏWp2Wg?H?ÍWRvZl1ZxìZpiWoKHoKYp1ZgIHoKHoKW?ÍHtÎY?øHScZtìZxÎZcIH?~WxJWtìYTcZRLZN~W000IÑE?Ý00084AÒÂ?Ý0004m*Izh00002ÀX>{hg000BMüøíFg000fDcÛýÀôg00IØEÑiEI0006<dÐÉIK0000gHîÆip0015Gà5wiwë00siyTrEME000I?ÒIgN00000;øR;000000$Ñ{o0000000Ørë0000000Ðo0000",
roseBushTop: "0g0go000HßWhíHhßHœEYAÎWáÝWT3ZpiWBiH@RWp2WxÎZÝÝWAÎWhßW^RWœCYxiHHßHMxZBEHxÏW$RY000000000000001g00000000ÑF00000000IwS00004g16(0h001aSìw0cRù00]Ý1_K0ß400qN1?0moë000ù4ïoiE000p00Rù1000004E6Æ0ýë0000$0î04E00001Ù]00%w09(ëbÆ04ë01aÂqù0#0000C>íkGi000",
roseBushBottom: "0g0gx000áÝWpiWBiHxÎZp2WtÎZMxYliWhßHHßHœEY^RWAÎWáKWT3Z@RWÝÝWHßWÄEYhßWœCHœCYÂEYBEHœEHAÎWÝKWl2WhíHxÏWxÁZ@NW001803g1@0000000À3sN9EE0000k(5(Â_)Ch035c15cÃø$eS00ck35cUeQk01wggUIlO5000EEJ{UkÁ1>TQë)lÄËíÇ<CgÀrJAelTà_]GÿÀGÈQý]ÎOö%CcÞdS0g0kie4x3lN0004lX?cÃ3k00000kOvkhIc0000ccÀ?kT>N00000(MQkIQK00003KM{kI>c(0",
witherRose: "0g0ga000{?W00Ww0W8hWh0W4CW4kW4EW8kW00000000000000000000000000000000000000000001i000000ii(00000yNw000002y0000000w0000000?K00000Ò@V00005ÄÝ5000050S0000000ë0000007ò000",
TallGrass: function(n){
var pix = getPixels("0g0g7000CóWGlYí8WâlHJPWÚGZ00000000000002110S00R1200gícX042ì4wg18TÕgë10ÕÐ(ë1T{âSSwkXwiwyùK&íx$jKEó?c?ÒõlØggËÝioesnæilesRå?A")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
warpedDoorTop: "0g0gcy?ZCAZ/8WtVWFiHCÖH/-Z%âWËÓY]SWt4Wg?H0gg11102iyNy4>ÂAg4)TQ>?gÔÞVnRzà,í[Å[R>yzJAk>y>ÓÐÏwNzÓ>ÓÑw4+ÔÓzÏwÑ[+ÑÏzÞ7nQ+Ñy>ná4y+ÏS3á?2yNAlSQU2Ó+K[à1>ÏÓ+KGO,àßÓNxáCÓcíÏN?QGAg",
warpedDoorBottom: "0g0gb]SW/8Wy?ZCAZtVWFiHCÖH%âWg?H/-ZËÓY1z?ÔV]IáJVÓGhU?kBV[naUÇüBhTnaUÇÿxa?ÅaUÁnMaTnhUylMlPÿhßVMýOPÿVAá[NlBnÅ)VllGBVGÑÁldVRBãQß,5VQ>ÑáBàúh[áâU,V.hTllÐâk.aTlmUÁkU??Q?ááQ",
spruceDoorTop: "0g0gcaiWìàHÇiHUnZåÐHÖ>W{IHÒNY)lH;SZÖDYÚGZ120w20w2hjTM>TAÄ1RhMÂTAÄ1Rl,ÂUB@òCAFCAFDgÂâ,Ââ,Ä5jÁxjÁAã5jUBjÁMã5jQDÃ?MÄ4>?DÂ[)ÄkÃQBàn)@1ßk*àlB@1ÂlxßkDm1RlMÂkD@TiÅMih,ÄòcA.CA.D",
spruceDoorBottom: "0g0ghÚGZÒNYÖ>WÇiHCóW÷-Z{IHìàHUnZaiWåÐHCåZåOYðoH)lH;SZÖDY0Q(IÎgiRX@-÷îò1/8kko]ü*91-Lá(o]÷MF2-iL4o]÷OÐ×Àiks@]÷Od7gLAs@/XïsÔikÞI@/XìsÔaeC8CPiëA×a4kECÁiëIÏ8ikECàNñhÜív4=60Q(ò1i2xX@^÷OAÎgLÞAo^÷Oa1-LÞa@/üOa2-LCs@(Rëï18ik4C",
oakDoorTop: "0g0gbGVZD4ZýLWÒRZÀrH000íFHG*WéîHÚGZÖgY1g0100g2iyyyyyyz2>ON>ONz2*VÁ*VÁAÏ*VÅ*VÅEJ*VÁ*VÁziìGhìGhz2>ON>ONA2*VÁ*VÁEi*VÅ*VÅz2*VÁ*VÁz2ìGhìGhA2hiIhiIE2>ON>ONziNyxNC×zÏNyìN!]A",
oakDoorBottom: "0g0g9ÖgYýLWÒRZéîHG*WÀrHD4ZGVZíFH1xj)xlUjÎ+Q@+Q@iÎÓhOhjMiÞÂyxÂyClÞxhmxhmjÞxh)xh)iÞxj)xj)iÞ+Q@+Q@*ÎÓÎOmÎOOÞÂyxNyCiìxhmxhmi1xh)xh)lÎxj)xj)jÎ+Q@+Q@NàMÓjMÓjNBVVVVVVV",
jungleDoorTop: "0g0gei@YLÿYÖiZýCHeSYGmWciYåÃH000)lHÚGZÖDYPAY(IW0hh0hhg23?ÃVV*UÏmVÔ,àãV[lU,äíz?ÅýÃä-îñ*Åc,IoìIâÅkÅIoìIâÅj[IÆëIáN7G1Àl1ßyg0ÓGGÓ036V>II)UR6V,Æë)ÄÂ4VÔS5)UÅlÒÔQQ)V[lâ[)?çJ[ý*>VVé)R",
jungleDoorBottom: "0g0gaÚGZGmWeSYýCHÖiZLÿYciYi@YåÃH)lH1hzhh>h)Âizhh>hÑßyÐyy@hAßyEOOíhEãxEGGMhoàhAxCNCoàhÑxmízEÃhÑhiðCEÃh)miîhAûx-zi>hÑ6ÓÐEh@ÓÑÆQîÓiOXXàh-MiNh-ÞÎAMm@moÄ+ÑÓÐðÐÕÆIQ]IXQI",
ironDoorTop: "0g0gblÚYl|WK$YCóWE?W000|)ZOCHí8WHTZT4W1g0100g2iyyyyyyz2)QR)QRz2?VÁ?VÁzÏ?VÅ?VÅzí?VÁ?VÁziúGhúGhz2)QR)QRz2?VÁ?VÁzi?VÅ?VÅz2?VÁ?VÁz2úGhúGhz2hiahiaz2)QR)QRziRyxR!IzÏRyTR!.z",
ironDoorBottom: "0g0ga$EZK$YE?WHTZOCHCóWl|WlÚYDAHT4W1xj)xiAlÎ+Q@+Q@lÎÓhOhjMlÞÂyxÂyClÞxhmxhmlÞxh)xh)lÞxj)xj)lÞ+Q@+Q@*ÎÓÎOmÎO-ÞÂyxNyClúxhmxhmo1xh)xh)lÎxj)xj)lÎ+Q@+Q@-àMÓjMÓjÆBIIIIIII",
darkOakDoorTop: "0g0gfÇ2Z)ìWÀ?Y]IH;cWScWEKZÎ2H)lHÚGZÞyH(ëZZùWjÀWckW000000012zOyyyO)2ÄÓÏBÓÓ)3ÑQàCQ[)îÑUàC?[)JÑVàC?ÅA2ÒVàCVÅ)2Ò*c+ÃÈA2ÐOc+O/A2ÐOc+O/)3ÐNC+O!)3ÐyC+N!)3EyC:y!)3Eyc:y!A3gæà#GdAîNOyy;NA",
darkOakDoorBottom: "0g0gcÚGZ]IHÀ?YjÀW;cWÇ2ZScWEKZÎ2HÞyH)lH(ëZ1yyyyjhAÁÔGÞCGGAÁáQìDQ]AÁáÑìD@]AÁáÓìD@ÕkÂãÓìnÓÕkÂãmúnÎÖkÁÞhúnhpkÁÞhJnhpAÁÞiJnhFAcÞyJDiFk1EyJ#yFkÁEyú#yFkÂGòìrIAkÁhhhyihk#ggggggG",
crimsonDoorTop: "0g0gaèOHeDWú6WÕLYÊiWXSYÖÓW]ûHÀsHQîW1ixhyihzzO>OO)O)g*S(()3UgÀSVÀUV3ÑQQQQQQ[íyÂyyyyzwV0VV5VUgV0VV*VUg0>5À(3OjOQOQQQQ7GGGGGGGAQáQQ[Q[j)àO>[O[gOà3O)O,À0S0(ßwáÒ0S00J3ü",
crimsonDoorBottom: "0g0gaÀsHXSYÊiWèOHÕLYQîWú6W]ûHeDWÖÓW1hzjM?VyÎÎxÐh,ONÎÓCÎÎ,OÏÓÓCÓÓnÓÔÂyyyyyyDðÓmÓÓÓÓÐìhOhhMhkÎhOhhThkhOAMj>)QAQyQyyyyÿGGGGGGG4QáAQDARîQzQORQNìOx+hNMihÎxÓmiÎÏNRßQRDDD",
birchDoorTop: "0g0gelEZl^Wl8HDÄHGdHCCWSJZReZ?×ZQeHÆRZRaHZNHZrH1hhhhhhgiw02y02zi?VVOO)ziÄÓãÔÓÕzJÄÓãÔÓÕzCÉggçgG3gÄ???HÎ3gÊ?iÙHI3g:gÔãgG3g;IÔãèi3g;lIèéi3g:gggçG3i+ØiÙGÕ3i+ØiÙGÎBg,ØiÙGÞýù,ØiÙGÞc",
birchDoorBottom: "0g0geÆRZlEZDÄHReZRaHZNHl^WilYCCW?×ZSJZGdHl8HQeH1z)VV>+äÎAQQQQPoÎBEU?EÇoÎBOC^OÇoÎgaaÓaaäÙènÞÞnniÔÞGÞènèiÔIèÞ?n?iÔhÞInIsiÙhIhn?hi?sIInÞhi1sÞÞIÞsoÎnÞèÞèsiÙn?GÞGniÔ?sèèGIääIIIIIIí",
acaciaDoorTop: "0g0geILZIiYìyYeÐYeàHgàYaàZÙnZýÐH000)lHÚGZÁ?WÞIW1h000hhijQ?U?UQ@3GEGEGE@3åúåúåúRcFúFúåúReFúòúFúÂÃòúòúòúÂÃòùFùòùÂ3FùFùFùÂ3òùFùFù[5òùòùòù[lòùòùòùÅ5FùòùòùÂ5FùòùFùÅkòùòùòùÂCM0M0MEL",
acaciaDoorBottom: "0g0gcÚGZeàHÙnZìyYýÐHVVHgàY000IiYILZ)lHeÐY1y)y)y)ÃÓDäDäDÞ>ÓDäDäDãjð,ä,ä,äjþ[ä[ä[äÏú,å,å[åÏú[å,å[åÏþ[å,å[åÏþ[å[å[åÐð[å[å,åÐc[å[å,åk1,å,å,åkÎ[å[å[åjÓGaGaGajðÓhmÓhhj)yyOOOQ>",
crimsonDoor: "0g0g7000QîWXSYÊiWÖÓWeDWÀsH0000000000000kAPC00kAPC00_ÚGL00ÑJPA00mlÚG00kAPC00QA^L00ÑA]ü00kAPC00kAPC00_ÚGL00ÑJPA00mlÚG00iPAJ0",
warpedDoor: "0g0g9000%âW/-ZFiHCAZy?ZËÓY]SWg?H000000000000000001y)zy(001BÂzy(006ÂÂzAS007yÂByS001BNÃU(004RN>y(006yN>Q(007y)zI(001V)zy(004yÂzU(006yNByS007QNÃy(004y?zAS001hhhhg0",
acaciaDoor: "0g0g5000ìzWeüW)lHÁ?W0000000000000kJPA00kí8A00)í8A00kí8A00kí8A00kí8A00)JPi00kí8A00kí8A00kí8A00)í8A00kí8A00kJPA00iPAJ0",
jungleDoor: "0g0g8000åÃHE5Z)lHclHýCHPAY(IW0000000000000kJPA00kúBA00)õgC00rQgÈ00kE^C00kÐ2C00)E_á00kE^C00kE^C00keGC00)E^C00r×^L00kE^C00iPAJ0",
birchDoor: "0g0g7000A@HlEZlFYTNWlÚYÆRZ0000000000000kLPA00lBEA00ÒÚGC00l$þA00l$þA00lÚGC00Ò$þÑ00l$þÑ00lÚGC00lBEA00ÑJPA00kJPA00kJPA00iPAJ0",
darkOakDoor: "0g0g7000(ëZÀ?YÚGZQeHZÒYjÀW0000000000000kJPA00kPQü00)Ñ@Q00kÑ@Q00kÑ@Q00kÑ@Q00)J^?00kPQü00kÑ@Q00kÑ@Q00)Ñ@Q00kÑ@Q00kJPA00iPAJ0",
ironDoor: "0g0g7000þÇHK;Z|)ZT4WE?WIcW0000000000000kJPA00k0S400)0S400kJPA00k0S400k0S400)J^Q00lÚÄL00lãÅÑ00kJPA00*ÚÄL00lãÅÑ00kJPA00iPAJ0",
spruceDoor: "0g0ga000ÇiHåÐHÒNY(IWÁ?W;SZCóW÷-ZåOY000000000000000001zzzzw001zzzzw004ÄÄÄÄÀ001zzzzw001zzzzw001zzzzw004ÄÄÄäÀ001zzzòw001zzzzw001zzzzw004ÄÄÄÄÀ001zzzzw001zzzzw001hhhhg0",
oakDoor: "0g0g7000ÖÃWCkZÖgYíFHéîHýLW0000000000000kJPA00k0S400)0S400kJPA00k0S400k0S400)J^)00lÚÄL00lãÅÑ00kJPA00*ÚÄL00lãÅÑ00kJPA00iPAJ0",
torch: "0g0gd000ZKWt(WZŠHZZZaSWÚÃHýLHViZSLW;IZ-eY)cH0000000000000000000000000000000000000000000000000001w0000003S0000005K0000007ë0000005ù0000005ë0000007ë0000006C0000005E0000006h000",
soulTorch: "0g0gd000OEZ2AZçRZZZZaSWÚÃHýLHViZSLW;IZ-eY)cH0000000000000000000000000000000000000000000000000001w0000003S0000005K0000007ë0000005ù0000005ë0000007ë0000006C0000005E0000006h000",
lantern: "0g0gc000<5W?+HöRZëRZwcYIìZrQHTCHZTHZsZTBZ1yg000003Q(002h0iyx00150@GÑ00150,Ià005l0-Aî00000-dî00150[Iá005l0iyx00000hgh00000rye002h0Ey#00150Ey#00000rye00000hgh0000000000000",
soulLantern: "0g0gb000<5W?+HwcY2ÇYD%WvcHÜYWSRZIZZTBZ1yg000002hw002h0iyx00130kVT00130CGÏ003j0Dòß00000DAß00130mGÎ003j0iyx00000hEh00000qyc002h0Cy!00130Cy!00000qyc00000hEh0000000000000",
beaconGlass: "0g0g5lEYe|Yí80ægHôcZ0000019AJPAú9wJPAû94JPAû8CJPAû9AJPAü9AJPAû9AJPAü9AJPAü9AJPAü9AJPAü9AJPAüFAJPAk9AJPwüFAJPAúCpAJP9",
beaconObsidian: "0g0g540Y00WgMZ-ýHAàZ4Jg&1s4yìÕ8kBGQòl8&B28ùìMAPAë8Pië1h9]EN6g]5)óAJnBiüëAJIüASCëSg20ücE4RdiJdCJö4kú0a]0K(4w9g]SCkQ00",
beacon: "0g0gaZZZ!ŒW#$WKYW_ÊZÜöZcjZIZZlZZRZZ000000001hhyyyhj1iyARyxj1yQ?QQyj2AQVVQRz2A?ÔãURz1AÄäñÒRz1QÅòAâUz2?ÅòAâQj2AÄäñÒRz2A?ÔãURz2AQVVQRj1yQQUQyj1yyARyyj1hhyyhhjOOOOOOOO",
cactusTop: "0g0g9000.ÎYTJWCþZÁrHÈNYÓÐWGŠHTúZ000000001yxyNixg2QRQQQQg2?NVÒBUw2?ÑÅÒ@Uw1AÄÒÒáQg2*ÒÄÓVUw2@Ñ@ÓÓÑw2@Ô@ÒÓUw2?ÓÓÔU)w1QÄÒÓUQg2?ÑVÓ?Uw2?U*VB)w1QRkQXQg1ixyyixg00000000",
cactusSide: "0g0g9000.ÎYÈNYÓÐWPiWÁrHTJWGŠHCþZ1zAÃNi*g6ÂÅÂNjNÝäÂÁVN>Ng1yxÂNí*K1z+Ã*lBg1OxÃ*lyÝÞOÁÅ*lNg1OxÃBiNg1zÄÂVj*K1ÃCÃVj*K6ÃEzBjBñ6ÂxzBjVgäÂxzNÐBg1ÃÁz*ÐBg1ÃxÂNßBg1zMVyl*g",
cactusBottom: "0g0g700091WdìY?,Wl[Y÷iYCsH0000005AòFA]9G?Úg8a:ãLLkaÓ?úGk5L?úgg9LNeh89O)þ<86Ö)A{i6Ötj{kaÔAöHk9L?ÚHk9hãL?k5G?JP84CóPA]000000",
glassPaneSide: "0g0g5000lEYe|YôcZægH001S00002K00002K00001K00001S00001S00001S00002S00002S00002K00002K00001S00001S00002ë00002K00001K00",
glassPaneTop: "0g0g5000lEYe|YôcZægH000000000000000000000000000000000000000000FiJQJúÛALPCL000000000000000000000000000000000000000000",
ladder: "0g0g7000ýLWÀrHéîHG*WÒRZ-eZ0C002ëeOcJoNllÚGdÕ1K005ë0C002ëiOA(ANllÚGdÕ1K005ë0C002ëiOAJo?llÚGdÕ1K005ë0C002ëiOcJoNllÚGdÕ1K005ë",
vine: function(n){
var pix = getPixels("0g0g5000ÏOZÈjHígZÛÑY0k?Ào?il04loÛy01iëÝC0dië0C09oSgü1E8ÂÂphëRëwo?ímh05o0oh02ë2lw08ë0C01RCdC0ÂlwekaeAwgkügC01i10c8EF0")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
Water: "0g0g100W",
Lava: "0g0gp?cY?SZ?SYn?WoîZn?WiNHnrH?cHN2HoîYlSZ?NZZdHriYirHS*Z?NHncH?rYiNY?NYSBZoNZncY0QNgc(Rg03-0jCÎ8LgtP^SgAx8eleE]2EH30Rg.j0Rgï$o0gEœ2igöõ8iÝë30S0gë88ùëN0SkG7(SEXx3Agaë9õg?TÐ85X6*mO4zÒÊ0AiMìÔ8w826UM(RëHx8Ri.Ó8@joEâi00I8igA4îJhXl8S6K$Fi@0C8íãAw",
craftingTableTop: "0g0g9oÀZcwHSëZÝ?WHÓWaÐWecZU?H]cY1gzOON10kRÄÓÓÒATkCÓÓÓÓÏT2ÔñGIIãwBÔÄãÕÓãÂ+ÔÓïÔÄãÐ+ÔäGñäãÐ+ÔÓãÔÓãÐ+ÔÓãÔÓãÐ+ÕIäñäãÐ+ÕÄðÆÓãÐBÔÄðÕÄãÂ2ÔäGGGãwkCÓÓÓÓÏT4RÄÓÓÒAS0gzOON1g",
craftingTableSide: "0g0ghoÀZE*HGVZiãW-ìHÝ?W]cYýLWCkZAìWéîHÒRZSëZEÝYlÚYGlHg(Y0QMùDM]MõS0íjCðM2h900XwIF^ggIS2üàdK2þceS0kMõÓ(iwï00XiM4wRx8S22kGAwXgc02LdFK2LctS0iNGÓ(iMõS0QR;Ay2ëc00íkx4wRkwS2LàdÝí÷c%K24MI@(iìIK0QAwAwXh4w2gh54wíXx02ügÐN2þceK",
craftingTableFront: "0g0ghoÀZE*HGVZiãW-ìHÝ?W]cYýLWCkZéîHÒRZSëZEÝYGlHZZZlÚYg(Y0QMùDM]MõS0íjCðM2h900XwIAyggIS2ÂàcS2Ugew0kMõÓ(ihe00XG54wRi(S22hXAwXLg02JIcS2JOhw0ihXÓ(iOHS0ÌSIAy2ñh00ASx4wRn;S2JàcÀí}ühS24MI@(iìGK0QAwAwXh4w2gh54wíXx02ÂcAN2UýFS",
crimsonNyliumTop: "0g0gbï4Wè0WÑíWÝEZüTWEÎYÑJHä0WÝIWhEZHEZ0iO?ÎBÅ>Tj0Qk)QVEgûì?M?[NÎìh>3[Q8mUÎëùM/ìkzTBá30koSâU(oxìî4Uc.NkSì[[Åî3Îhko(@okÆTò38mi]híS-hÑkÅXkVQá(ì?NhTë>08QToC]kù)äÎ(Míh(?Rk",
crimsonNyliumSide: "0g0glüTWEÎYä0WHEZè0WÕ0WhEZÆ0WÀ(ZUÎYUÞZÑJH;(ZáIWÑíWÝEZáEZ{ÁHÝIWï4W{(Z0Sg8z00g4Îw2M0zoSMX5F4202FQÎgdxiÂkX.S>üOTiàAd/a>a8RgáAOÂeàcFRÄ@*&^÷ïBKí^äGiFÑ?J}áÊS@BxNSlL:c,gñàNsÀd{sSgñün8eúá~D?côn@?M>CÃIiõÀl<i{sSJoõÂOJoôCŠGFôsS<jõÊSIk_yOhj",
warpedNyliumTop: "0g0gfÄlWdïY<*HTcWdsHaäHdsY?cWe8Y?gWa?Y6äHa?HTgWe?H0iO?xBÁÔìj0ÓmãQVFgdÞØÞ?TNxÞhñ3ìÑ7iGxÝCMèÞoDì#m30onKlUÝtxÞà6UŒæßoKÞìÎÁà3xhmn(Ïnmgìè33iiñhßK,hEoÁäoÉÓo(M_ßhìÝñ07Ñìnyñmh+nx(MßhÝÒÏm",
warpedNyliumSide: "0g0gndsHaäHe8Y<*He?HdsYdïYa?H$?W<*YdïZÀ(ZE?WUÎYÑíW;(ZáIWÝEZáEZ{ÁH{TWï4W{(Z0ShcA00g4ìpRTIAwSR4D(ixI>MðÞõi^6ÎAÖRX)F8ÈkXx]ÏLüxØÈLIgc×kð%eÉÊÿIEØÆGg?ûUIGÂÂCoC}ánD}ó_BnFLÐcÆgoáap%{ÙaogœýÐFhSâpD|ÜAËÔJeÉCDP?Al7??ÙaEL#ALoL#acqGÚann?jAnoJLØooIj",
warpedStemTop: "0g0gkSÏZScZdïY]îWe8YQýY6äHQcZ+]Z+oH+oWNåW+-ZpVWFáZxiH]îHSýZNòWQýZ02xõïMh(gwagXBaÈJXM1yql.rçNS.Ñ2qgeõÏAi.0íÊIF^ÂüD<(2uI.KçAC.w/Êc*!ÂÊc.hNCI.LæCD<@!ÌI.LßÊC.ByCI.F^Cc.QqÊI.JàND<zqÌIF^ÂüD.ziuðFcÐoG.yauOgjàAO.12gXc9UJüM002xõï)I0gw",
warpedStemSide: "0g0gpSÏZScZeÅW]îHdïYa6H9GYUcZ]îW66HQýYaÔWSÏYQýZ9DYScYaÅWdïZdoH;gZSàW;IZi+ZdoWScH02xõìES(ow02ÀcìE@(ùw9IgõC(e0XIg6Së1(}N4c8ji4Îw@ÝAc1ji4?92(4I9eÝùÔ-]gAz(jëù8.iR58(0g4ì0ii0OaSÎCAwSR4?ÂLmsN9q?cÙ]@0õO18n01(kSEÔÁ24dóauKù3Oh(Io0Êg?CaUìdx0BMëüeeëow",
crimsonStemTop: "0g0ghSÏZÀSHè0WüTW{SHEÎYISYëlHXSYèlHùsWÆGWÕiYüsWý6WÊGWÆeZ02w0ÑES0cw9õÐt9Â}ÐwIq05eôÐoIec1ëoc8RÀî$h1LXcF^Âü(N1AXhÙÏLü$N9LüëOPLüEI!ÆXh$ÏÆüMBx?Xe$ÇLü$?qÆXEO/Æüez1LXeNçoü(N1?XcF^Âü$NioÑB8Rgl%y9a6%ØÈLgEI1õîa7_÷àwh02w0ÑES0cw",
crimsonStemSide: "0g0gjSÏZÀSHEíW]îHè0Wü(ZIgHUcZ]îW{SHGíWA(Zä0Wù(ZUSHSÏYÐíWùMWÀSY02xõìES(ow02ÀcìE@(ùw9IgõC(e0XIg6Së1(}N4c8ji4Îw@ÝAc1ji4?92(4I9eÝùÔ-]gAz(j(ù3.iR58(0g4ì0ii0O9SÎCAwSR4?^þgsN9iQõKE@0õO18j01(ihëÔP25C98iKù3(S(IC0{ghw9ÂMcÎ0qnëøázwow",
warpedWartBlock: "0g0g7dsHhGYhðHaäHe?He8YdsY02I0w10ÿ24C1A208UoQ0ó{!wÀ0ýwJ1{8L04×E0h0{ù5ÂdwNë9A104ë809KlÀQ4^ñyFSyöAAU1C!pgÐ4yg50g0wg17g1SÃ10k",
shroomlight: "0g0gh?SWGCWOkWl(WtzHOhWtGZZæWtjH?(WZEWZoWtjWZlHtgWZóWtIW0Sxùï0RÐa38óÂõiwJcaQ18ÐFÓ(iîFÓP]ÐAoM{Óoig?ãaQpþeMIP{Sp3NLlAïp6*FINLloïxÌRüCq÷Ðliz÷GsoxUCcixUÓtDÁ]MhiFaïEiÁsÐkcxaCý^M^àhIxÌe-Cq{ãACqþÔl^ëNÑgCFcRý@waÂü1F@ÂCd8SAëx",
polishedBlackstoneBricks: "0g0g6(eH|BH;?HkMWAìZsTY4CÁEüî8wÂi0j8CCúEûT42T9Ð]0g0_Ðì#0þ_3ú8AþI3ggÉÛlÚEüûeiÁ14j8AÂìkûëüùSwc]A2T8z?8wgPØ]_$þ?#2_ÚÛLlÛgÉ",
gildedBlackstone: "0g0gaAìZ(eHkMW;?HQKWLSZégZsTYZGY|BH1g0whjkTiÄRwhjMTBÝ7xlîgßKhh1jÕG7ÞjO3.ùÅ4OûgÞ00Ô4jM04h0SGÝ04Î7h7ÞG1ijnÄS1hnDgáÞg401ÒG1ûMmÞj,ëG.ûlhOMÀGGjKOa06004SOúG4DGxng7G201T0",
chiseledPolishedBlackstone: "0g0g6|BH;?HAìZ(eHkMWsTY0g002RcEÉÚþ?eLEP!teë00Xd6íPBü|B6ÉÚüt6E00Gd5hSk)d5MT)GtdNPAGË56LPAd5i_BGt&CýÄLtÙ0S0ít|EIÚGL^eAJIV",
blackstone: "0g0g6AìZ(eHkMW;?HsTY|BH4ëgAexF]ùAGÎÂ1h%EySJT%?4XGIãò4ÛEx094%ù4A8Aë0úgúxùiôM]1AI8ói20gC6G^XggúL?BGKJRNÛk401gÛa2ÂQ{wP20gS",
blackstoneTop: "0g0g5AìZ(eH;?HsTYkMW5yÆEëÑòirKñaICa%EìKI^TCÀ2]iik_0xpJR>ÎyõÎirÒk_]8I0c2AAa2+2QòrÂ2I]-IQiJiNíÀc1e4ùÎyoÛ2IÑCTQSSxETP]õ",
netheriteBlock: "0g0ga;IW(CYAÞZPkYÇVY|AZ-?YT4W|4W$CY1000010ijQQQQ?QÂ4Ð*VàIOÂ4àIV*ÆãÂ4,ïïVÃÝN4àä*?VÝM4GàVUO+N4,ÒVV,+Â4*VÃ*àãM4V?GàG+MlVïGGÓ0Â4ÆÆ+ÔÓ9ÂlÐOãÔKaÂlKÓKaaùÁlO*V*VVNiyxiyhyy",
basaltSide: "0g0g5|AZoûW-?YËâZ(IZ50IÙ(wðSIÙ(iN0lÙ(ëA6lc-ëQ(i1waÂ+icxaJ)kÙxgùQëÎI2ë(AÚiëë6rÚGaù6rdírù+rTEs0+2ìXkëQgëwLì6agAh46rÎXo",
basaltTop: "0g0g7ËâZâlH|AZ)LWóEY;sZoûW0üÉA636mLKÈLc+ëeIÀ{qì{AqihSÙJ&hìØ5ìS?dA0Gý%?Ð4Hd1C5DÙiGC?gJhSKocëÈ0AIwëO4aTPësi(×~Ó6JëeÑE]Kwe(wS",
polishedBasaltSide: "0g0g6(IZ-?Y|AZâlHËâZoûW5.júF8c-l÷B9c-?÷*99+lög95@?öGúB]?öGú5QlòiI1AlÖiIc)?ÞDIc)?ÚiöC-?Úiï6]?ÚGïa-lÛ)I!-lÛ-ù!-l÷-ù!.j÷Ph",
polishedBasaltTop: "0g0g7(IZ;sZâlH|AZ)LWËâZóEY5C?^GianØLdÇ#$ýIÒÚâ/RÚGû+hGPC?.ËËEDe*HrIegÉ;SEDeGGSÖOû#*ÂPŒEâ*ËÛoeg)JÉÓúÖÄnâgû,ÑSÈLúFÒÂÈEd6eÈ^GI",
chain: "0g0g4000AeZP@H<lW1g00hÝ00i000Ìr003g001g00hÝ00i000Q000Ír003g001g00hÝ00i000Ìr003g00",
warpedTrapdoor: "0g0g7%âWtVW/-Z/8W+åWFiH0004J9wùPFiCJQk$60hìÇ8Ô+aœpFØm?Úo&RÓ?ŒgNnþLÓúiËþLKa!ÚuLKp!oEL×NeOãJRx$ÓsjRÎE×rK;gEaOEÀwaQ?JPo4J14ù1",
warpedPlanks: "0g0g7/8WFiH/-ZtVW%âWt4Wg?H4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
warpedFungus: "0g0gc000iÕHTùWm?HtþYlsHlïYorZ<*YQîW]ûHUeZ0000000000000000000000000000000000000000000000000000000001zON>g005jONxÀ006VDlVK006ÓGIÓK00009ù000000aù000000bC000000aE000000bC000",
magma: "0g0gaSÁHI(HÑCYÀÎYsiWOúWÝIWšcYšáHSRH1z3Aw2ÁzÓ(0Bz6TNGÄyÁNÕNUÄ)liUìzxÃxÁzyÒwNg2@(3N@zw+íÐ06ìUiÏXVzAihTlmxÂÁzBzÂwNki(ANR(3Bw2í6Xz0Bz2RjÏÂ(ANÐÂTNÃyÆUìxxV]XÓzÄN*iC@(Nkw5z3Bw2kÐÓ(0Òz2VNÅãCQNBNVÄ)oðlUÐxjxkÐyÕK+g2Ä(3+RÐwN>z02VTÂz?UÐxÄXQ?iÕðlzÒzÄw+?Â(ANi(3Òw2R2Áz0xz2Ä>yÂ(ÎNÐiÆN>Cïl?xÕTl]ÏzðNMÂym(+oK5z3Aw2TzC(0Ez2ìNÅãyTNENVÄ-lRUTzB>FhzyBwNë2Ä(3NÂzw+RÐ06TlÂzÁlzÕðUÁViBi]ÐAzÂwNlÄ(BNð(3xw2Â6ïÐ0Bz6@Ãy@(ÑNÏð?NÃCÆXÆÒxÁhÆÓÐ@N*RyÂ(Nlw",
crimsonFungus: "0g0gg000ilYCJYtþYTùWüÎYÝgYÀÎWhCH]0WÀÎY]LZÇjYÝIWï4WåïW00000000000000000000000000000000000hz000003TyÀ00004T>À00006VQK0007xiÔäK009ãÓGÓù000ÿåÿå00000aE000000ck000000er000000fN000000ek000",
warpedRoots: "0g0g5000m?HiÕHlsHlïY000000001E00001E00002Ýië0ü0ëih0þ8K,01GhT800SA14S0CIÎëë0M0Îëù0(hTíë0Ek@4010o8601ëNÙ601I0ß800T4í80",
twistingVines: "0g0g5000lsHiÕHm?HlïY000000000A00001Q00002Ò(0003Ûy0003×0000j×0000j^0006ôQ000kÉ(0001i(0001hw0000Çë0006?ë0006Lë0008Lë00",
twistingVinesPlant: "0g0g5000lïYiÕHlsHm?H02ûw0000ÂxS000ÈòD000aúë000aÁ0000bP(0001Ö(0001Pù0004{ù000sõë00QAÙë01dAÑ0000cA0006ûw0004aw0002?w00",
netherSprouts: "0g0g4000m?HiÕHlsH0000000000000000000000000000000000000000000001008TwS8ÎyS-EO];eOõ",
crimsonRoots: "0g0g5000ÑiHETZÀiYùjH00000000000000000000000000Sw00048wë00)Cwg00ïgëí00IÃí100RüwiëXCIï(IwxoT0gëSwR0Ng@9ëIo28?5ih1IIc-0",
weepingVines: "0g0g4000ÕgWä0WÆ0W0Õn00on00N600;a00(r000)000c0000000000000000000000000000000000000",
weepingVinesPlant: "0g0g8000ÕgWä0WÆ0WilYTùWCJYüÎY02I1g004A1pSj)ë1TCÿ)h1G01G00J00C00ü00dC0BC0DEëih06?04S00ù0Në00úmyS00P1J009O8ù00PY9Õ000?9ç002À5(0",
spruceTrapdoor: "0g0g9ÒNYìàHåÐHÇiHUnZÖ>W)lH;SZÖDY1zhTÃxNÀ1zlSÃÂ*w5ky(UBTÀÔîä,îä,ð0Ã5SÃ5SÀ5kÂ*kÁT05ky(UBTÀ2AB(ÃwRÀ2Uy*4gRw13i?4l*w1ÃlM3i(g1jÀTjhSÀÔXä[îä[ð1ÃlM3i(g1zhTÃxNÀ1zlSÃÂ*w",
oakTrapdoor: "0g0g7]rWÎRYòiWa?YÞàW000E*W000000FCl|CagiÐKûg$là@lúElà@lúElà@la6ÔaÃÙI%+l|G?%GûÖDúEiÐSûp$làÓla8ÉÉ@LkElà@la&<aÁRúFGl|G?000000",
jungleTrapdoor: "0g0gbÞ>HÖiZaiYGmHE5ZýCH000i@Y(IWPAYÖDY0h0100g02O>)>O>xjQRUBRUMi>@CÏÑ)x2)Ó@ÔÓ>w2+ÓãÑÓÐw2@ÓCÏÓÑw3,,,ààà(5RÂUB?áÀ2RÓCÏÓ)w2QÓãÑÓQw2QC@ÑÏQwi)QARQ>xi)G)QGOw2AEadíRw0g0gh01g",
ironTrapdoor: "0g0g8E?WGŒYIcWl;ZlËH00WnéZOCH4üJPi]%GNöG?$CcÒBp%ÉÐ×lp|ÉÐ×lq|Éà×lA|IH÷ÜLÁG?úG?ÁG?úG?{CCïBq|ÉÐ×lq%ÉÐ×lq%Éà×la%JTÛ|?%GNöG?4JJPi]",
darkOakTrapdoor: "0g0g8]IHÀ?YScWEKZ(ëZ;cWÞyHÎ2H0JTw009GnFGNelÞelÝeë(eëMg0Þg0ÞgiÞ(iÞjTgOTG4íPwJ80JT0iS9Gn9GnelÝ&lÞeëM&ëMg0Þ(0ÞgiÞ(iÝjTGOTG0iSAù0",
crimsonTrapdoor: "0g0g7ÊiW]ûHXSYèOHú6WÕLY0004J9wùPFiCJQk$a0mìÇ8ÚGlÙpEìTAëÆ%FA^Qk(ëPyëÁgÚGlÙpEÚGlÙpEJ8G2KddAÞCn$ëEAiÎEÚGlÙgEa5GÀwaQ?JPo4J14ù1",
birchTrapdoor: "0g0geCCWDÄHl8HlEZl^WReZSJZRaHZNH?×ZGdHQeHÆRZÖyW1h01h1hg2OOyOOyxj000000Mj?ÓÄÔÓÀMj@ÕäïðKMiÿVGâGÝM2þðãñÕKM3@IÆñIKx3þðÆÔÕKwjýÅGVGÀMjþðÆïÕK(jþÕäñðK(3ýÐQaþÀw3PüyyCSx2OyHlyO(0hg01hg1",
acaciaTrapdoor: "0g0gaòiYaRYeàWgcYöNY000IiWÁ?WÞIW)lH000000001izOOONw4QN4>wQ(1VÏ5ÄwV(1VÏ5ÄwV(1VÏ5ÄwV(1VÏ5ÄwV(1VÏ5ÄwV(1VÏ?ÄAV(1VÏ?ÄAV(1VÏ?ÄAV(1VÏ?ÄAV(1VÏ?ÄAV(2zÐy+NzK1+,IIàÐg009GGù00",
bedplanks: "0g0g7GVZE*HiãWýLWCkZéîHÒRZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
bedbottom: "0g0g4ECWGiYCJWH?WhVctgEntllZT7ZSáïVVUïVÀkcVV7xVÄ7]VUñhlVf?1VvsVU<ãlSüWZÂëïSgÂÐV5!",
bedtop: "0g0gdléZRHZI|WIcWZZZE?WÕTWùíWXÎYCJWH?WGiYECW0h0yy0h01zOOOONghN1hhgzhh(kQQT3hgMQQQQj10MQQQQj02N1hhgzwVVVVVVVVÓÓÓÓÓÓÓÓGGGäIIåÿaaGGGåEaGEeaaaÿGGEEEgGGGIGGIIIII?aa?IaA???gH?a?e",
bedlegs: "0g0g7ZZZÖÃWCkZaLWE*WéîZHÓW0iÃK000iÎK000iÃK00&@ÉPE0eÓØPk0&@PAù0000000000000000000000000000000000000000000000000000000000000",
bedbottomsides: "0g0gbùíWXÎYCJWÕTWaLWE*WHÓWÖÃWéîZCkZZZZ100yyyw1hhhg000hg0hhhhhhOOOOOOOOQUÄU?ÄÓUGGGGGGäPg2yyyw1hhg1hhhhghhg00000OOOOOOOO?ÓÒU?Ò?QüñGGGGGGEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
bedtopsides: "0g0ghléZRHZE?WÕTWùíWCJWGiYáÁYI|WXÎYaLWE*WHÓWCkZéîZÖÃWZZZ02gX2paÃscS2gì2paÂACRgXx2q]RaFgXx8RoiMõÐÂ?i%×Â?g%^×AShRçNShRF}Rúzg2gX0FeRczi0gX8xeRgîigXx8oiMõÐgXx8RÂþce×ÂLiM×çNShRçNSg|Xx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8RgXx8Rg",
bedfrontback: "0g0gfXÎYùíWCJWÕTWÙTWE*WaLWHÓWéîZÖÃWléZRHZI|WE?WZZZ01hiyyx000hhhh0000000000O)OOOOOOÄÒVÓÄVÄÒãIaaaaIÔEggggggEiEggggEE?iEEEEE?nnnnnnnnÄÒVÓÄVÄÒãIaaaaIÔrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr",
bedIcon: "0g0gb000ÞIWÝ0WHTZRHZAíWõ(Zë0W;IYÖ>WCkZ0000000000001h000002zQg0002BÂ)T002CÓVzQg0CÒÓÒÂ)g2ÒÄÓÓÔxë2ÒÓÓÔyFë2CÓÔyyòë8yÔyyI8ë9íyyI00008yI000000Ð0000000A0000000I0000000000000",
respawnAnchorTop1: "0g0glUSZ$CWE7YwÐWë&HsÂWKqY00WA4HA4YA4W(5Z)6W$5Y{7H(6WE5WA3ZA4Z;6YA3Y0Q00S0010w8i(XzoiicÎ0iÂücF^ÂüÏhóàAO.jàüw0iàAO.jàüw0iàAoPjàüw0^àa_Ð}àüí0^àcFàNàüK0iàE!üCàüKg^àC)CeàüK0iàAoújàüw0^àAO.jàüw0^àAO.jàüigiÂücF^ÂüK8iTXzo@gõÎ0SK000ë08w",
respawnAnchorTop2: "0g0grUSZ$CWE7YwÐWë&HsÂWKqY00WA3ZA3HA4ZA4WE3WA4HA4Y$5H$5Y(5Z)6W(6W{7HE5W]7W;6Y-6HA3Y$5W0Q00S0010w8i(XzoiicÎ0iÂücF^ÂüÏhóàAO.jàüw0iàa9^÷àüw0iàeöàNàüw0^áMÞüCSüí0^âgjCŒÐüK0iâebVÜîüKg^âcpJâOüK0iàeöÃ×àüw0^àaJE÷àüw0^àAO.jàüigiÂücF^ÂüK8iTXzo@gõÎ0SK000ë08w",
respawnAnchorTop3: "0g0gvUSZ$CWE7YwÐWë&HsÂWKqY00W-6HA4WA4H;6Y)6WA3ZA3HA4Z$5H(6WE3WA4Y$5YS6ZE5W(5Z{7H]7W(5YA3Y$5WS6YQ7W0Q00S0010w8i(XzoiicÎ0iÂücF^ÂüÏhóàa9Â÷àüw0iâeEàN?üw0iäD^AFÃüw0_ÓI,Òz7kí0_ÑEàiÚakK0iGcdéþòüKg_UggngrüK0iêD^æeÃüw0^âL×g;Iüw0^àaãg÷àüigiÂücF^ÂüK8iTXzo@gõÎ0SK000ë08w",
respawnAnchorTop: "0g0gvUSZ$CWE7YwÐWë&HsÂWKqYA3HA4ZS6Z-6HA4WA4HA3Y$5HQ7W;6Y)6WA3Z$5W(6WE3WA4Y$5YE5W(5Z{7H]7W(5YS6Y$6Y0Q00S0010w8i(XzoiicÎ0iÂücF^ÂüÏhóáB_ÐqOüw0iI@[/såüw0iA&EeEakw0_òVåöo?üí0_ïELlMHkK0?5E_@wekKg^ýC|ÛD{üK0ijEE>(Akw0^?C?inpkw0^IDoIteüigiÂücF^ÂüK8iTXzo@gõÎ0SK000ë08w",
respawnAnchorTopOff: "0g0g8USZ$CWE7YwÐWë&HsÂWKqY40Y50g048%E_ÙA?elÚGlÈÈZZZZ]eZZZZ]eZZZZ]6ZZZZÏ6ZZZZÆeZZZZÆ@ZZZZÆeZZZZ]6ZZZZ]6ZZZZß}lÚGlÆ%i_ÒJ?4K080I",
respawnAnchorSide3: "0g0ghUSZ]oWE7YKqY$CWwÐWsÂWTÔHjlHZZZZJY40Y00WgMZAàZ-ýHë&H0Sw018i0õwxQggiMI14CFRgAiMõgXc9RikITóSXc8^RüOÂaÂkx9mÂaØ/cÂEìÈLeo#S{ÒeØ92lAì9cEXìÐaSAw0]i*ejQRoXxcR)RÕXÁ)iMAiò÷ÐÄCòÚÉNoGÏÉNLSÏàNGöeàAG%öj[8M?Ðþ+e?ÆLIeô×?+%EÕþgòØ",
respawnAnchorSide1: "0g0gfUSZ]oWE7YKqY$CWwÐWsÂWTÔH40YZZZ00WgMZAàZ-ýHë&H1201jgjg?x4ÓÓSxUVhmÓÓÎhVlh?ÔðUhÁhUVåIV?hkïÄIIÒÆTIIÓoìÓIIkhðTkÕhTEUmg1T_g#A@QQÑ_yEB#ÓÓGEEeíEôöNgNölENJoeG?Goe#=oiEîGiîG/ÐGcÐHEIíI",
respawnAnchorBottom: "0g0g840Y00WE7YgMZ-ýHAàZKqYë&H4üoNìÒ4NúõØoC^?eS]Âgàfúú*)Gtë(Ü?hqÀhN:y6A^5itQ?FCVneql~nSÐ(rÖÛ20ÿö$DîiÄLiNae6AgõbÜAÕ)ÓEpü]K?tÕ0ë",
respawnAnchorSide4: "0g0ghUSZ]oWE7YKqY$CWwÐWsÂWTÔHjlHZZZZJY40Y00WgMZAàZ-ýHë&H0Sw018i0õwxQggiMI14CFRgAiMõgXc9RikITóSXc8^RüOÂaÂkx9mÂaa/cÂEìÈLeoES{ÒeØ92lAì9cEXìÐaSAw0]i*ejQRoXxcR)RÕXÁ)iMAiò÷ÐÄCòÚÉNoGÏÉNLSÏàNGöeàAG%öj[8M?Ðþ+e?ÆLIeô×?+%EÕþgòØ",
respawnAnchorSide2: "0g0ghUSZ]oWE7YKqY$CWwÐWsÂWTÔHjlHZZZZJY40Y00WgMZAàZ-ýHë&H0Sw018i0õwxQggiMI14CFRgAiMõgXc9RikITóSXc8^RüOÂaÂkx9mÂaØÈ?ÂEìÈLeo#Æ{ÒeØ92lAì9cEXìÐaSAw0]i*ejQRoXxcR)RÕXÁ)iMAiò÷ÐÄCòÚÉNoGÏÉNLSÏàNGöeàAG%öj[8M?Ðþ+e?ÆLIeô×?+%EÕþgòØ",
respawnAnchorSide0: "0g0gdUSZ]oWE7YKqY$CWwÐWsÂW40Y00WgMZAàZ-ýHë&H1201jgjg?x4ÓÓSxUVhmÓÓÎhVlh?ÔãUhÁhUVGGV?hkâÄGGÒÅTGGÓnÞÓGGkhãTkÔhTIUmg1TPaFA@QQÑPyJBFÓÓAJóòßJåçGaNçgõNeIûÿEÿIòF;idóàÿdàA-ñÿîñAJGßG",
flintAndSteel: "0g0gc000?kHGŒYCåZ(IWÞIWkÁHVVHECY4gHéSZEEY0000000000h0000001yg00000i)U00000iSQ00000jg000000jg000000lgk06000?M)0ÔK004ÃS6Xù000Q0Ñæò00006XGÖ00006æðÕù0006áÕ[ù0000AÖa000009ù00",
oakSapling: "0g0g9000RNZÄeZtúYhTWéîYÞRZÆRZ{IH000000000000010000020O0000Si0?Ñ000ÓMQÄG00xzK@ÔN002mÅ6Kxw000Óð02w003@x4(007ÔNi+ä00j+ãÆÔîg1h7CÕä1g002jÎw0g001EÏg000007Õw000007ä000",
cryingObsidian: "0g0g840Y00WE7YgMZ-ýHAàZKqYë&H4üoNìÒ4NúõØoC^?eS]Âgàfúú*)Gtë(Ü?hqÀhN:y6A^5itQ?FCVneql~nSÐ(rÖÛ20ÿö$DîiÄLiNae6AgõbÜAÕ)ÓEpü]K?tÕ0ë",
netherGoldOre: "0g0gcÀÁHUíWÀÎYÑCYÝIWSÁHe1HšEYï4WZGYZTHIúZ12NQOÃ)MjMBzR5Ow>>Ó2MÝN)X.dk)a3z][û]îQAM4MGIQ:O>3RU)>!üXT5z>ç_àIN)NCOQ()zPcÂ))S2k)àÂ]QCÂ+ANbA(Ôi3>A/J4)(k)]Pçj]SzQîxC))Oy)R)lzQO",
potDirt: "0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ",
flowerPot: "0g0g6000ìzYòOYå3HáSWÑ?Z00000000000000000000000000000000Âßë000ë20000ë20000ë20000ë1ë000òÒë000aMë000ô÷ë000òßë000ôNë000AJë0",
acaciaSapling: "0g0g7000ãMZÒRHêÏWéÞWöeZÖ(Y000w00041Ñ000CIìC01NNòL00#|÷Äë05Îæk007bÂk00iL?Gë02eJC001Ñg0001bAù00ieÇ0002CL0000Ba0000BA0000)?00",
birchSapling: "0g0g7000ÇSWÛàYEsW?ÈHÁLZ?çY000w00002S00001Ñë000Iýw000úöy004aLù004cJL000aEC000ÂöCë02ýáGë03ÃLÀS0Ao?w004ikw000a@ë0003)00003Õ00",
blueOrchidPot: "0g0g8000LWZ!ZZCeHu|H^NYÄCZlrH00000000000000000000000000a00000lë0h00OK6ù00C0b0000CK00-0î001dQÖë00S(Q0000&ë00007C00000H00000N00",
crimsonRootsPot: "0g0g7000èihùjSÑiHùjHETZÀiY0000000000000ë00000g000004hÏ(00aoÏë00bKKÀ001Eìë008rí0007ÙÎh00dÆ÷N001(Cë000wC0000rìë009CfS009ðoK0",
darkOakSapling: "0g0g9000RNZtúYhTWÄeZ{IHÆRZÞRZéîY0000000000000000000001w003xg0M3000kzkzi00MBÂR+>003ÃxzÁ(0002ONCÒ000j+y*Â003(ÓÐV)g003iÓÃ0000kDÔÀ0000*äGK00000äãÀ00000ÕÔÅ00006ÔÒÓ00",
jungleSapling: "0g0g9000+2W%eYFwZ$hY(kY-rZwùHoÝH00000000001w(000002jR(00004*Ti0000xQ>T00003m)300000Äz00002)Ïk(0000hMMw0000wCÃQ000005Ñx00000NÐ300000>Î000002mR(00000CÃ000003[X(00",
spruceSapling: "0g0g7000wLWgwW%yZ.ÐY$ÝYÀ?Y00000000100000aw0000që0001t$0002jQë001dßë001ÉNg008?&0006ÊAë001Ñi(00bueh00m}E8000?BE000dwë0002S00",
warpedRootsPot: "0g0g5000m?HiÕHlsHlïY000000001E00001E00002Ýië0ü0ëih0þ8K,01GhS800Sq1)00EIÎë0010Îë000hTë000k@0000o80000NÙ00010ß00014í00",
smoothBasalt: "0g0g6|AZ-?YËâZ(IZÖDYoûW5yS02Âx0]]GS5íiTm2SEi^Âi0íÂúLù$mR}E0ÙN0&ü9CXI%XûwA14Aï1AûÙC9E4ìÒùì4BgÙXù%]ÉwCùwnØE4ëSgÇ]Aí]í?SwÂ",
crackedNetherBricks: "0g0g8oMW;ßHQJYwTHEÁY(ÎZ-ÎZ8gH000000BmÂXþdEnÐLN?G[ÕGIÕ0+h0+hÒzsÔs}7ÁÚalAænÑæIAÙ00c03?SîREuGb[?Î@ýRÌgTÌdEldElJÔJLÄtE?eþIlgIÙJÁe",
polishedBlackstone: "0g0g6|BH;?H(eHkMWAìZsTY0ë840^5ih]CûEiJIíV1iúFkÒ0ÐCEÐC82^IíÂBiúFkÏx2U4IB0XÑB?bBk9ÂAö4iÏüA{8CúÀdU5AóM^ý8aiFq|EÐCþCUÂP$JP$",
chiseledNetherBricks: "0g0g7QJY(ÎZ;ßH-ÎZEÁYoMWwTH0229238EpAÐýgGòAÐd{lÚGLd,UA?eeQkjPcaQLóBsdcLÂScJ:VEÉ#Úckh]õdQLs?AdQkòSaJ:ØGGlgTHh0ctQAI%AËçØGlØg",
oakLogSW: "0g0g6ËyYâÐHúiW-cY{rHa?Y02PAJ]ACJ|hPQaw4JÂJRPPÂÑ^M8i,xAJJ]JPÛ090gAAaÁALòw1a?gsÄJS0üÂÚI1A0PAJJAüõw0PgyÂUjzÝûAúGPXiPACëAaÂ",
acaciaLogSW: "0g0g6ÇUZÖïYåiYÁAWÇQY÷nH02PAJ]ACJ|hPQaw4JÂJRPPÂÑ^M8i,xAJJ]JPÛ090gAAaÁALòw1a?gsÄJS0üÂÚI1A0PAJJAüõw0PgyÂUjzÝûAúGPXiPACëAaÂ",
birchLogSW: "0g0g8SHYZZZHšZ)LYlÙZÎâHn|HRjY0üLw@ogiN(óœApHrüLAh7zpKoj6zH$gjcCvEh8cAjðX_9?h84lìtg94:e;IP2:M;AÎîUxoùKîF1AùBhI4ëo$oúÄ6cAgaÙC{?",
darkOakLogSW: "0g0g6(úH;IZ]nZEìW(úWÇiY02PAJ]ACJ|hPQaw4JÂJRPPÂÑ^M8i,xAJJ]JPÛ090gAAaÁALòw1a?gsÄJS0üÂÚI1A0PAJJAüõw0PgyÂUjzÝûAúGPXiPACëAaÂ",
jungleLogSW: "0g0g9ÇhYS?WÖNW;IWâJHÀRHéßHVMYÎÏW1w3w3Ri51ÒàÒ3íg53l>Ò1ìg5z5ì55àgBx5à5Ò51wwg11ÒxÞgÀlhÀxwÞwÀ(nÂMB5wÁ+oÂnBB5Àm7Àoxw*Àí5341D*1R53Õ3ÔhÎÝBzÒ38gKgw1Bì7iwi0z1ìl20igx1Si0",
spruceLogSW: "0g0g6$ÝY-úW{IH$ÀY(ÝYUnZ02PAJ]ACJ|hPQaw4JÂJRPPÂÑ^M8i,xAJJ]JPÛ090gAAaÁALòw1a?gsÄJS0üÂÚI1A0PAJJAüõw0PgyÂUjzÝûAúGPXiPACëAaÂ",
crimsonStemSW: "0g0g8QîWÀÎWüÁH]ûHUeZI(Zä0WEJH0CÉõj]Cc_úëÁGAÖ5îJ4?e?LÆÙ-j:g?e@ÞK?aAjõÔÙÅ^NÑoîPCJ?-]h?ñoi@eÚíã&MEKaòci>o?Ð)öPD.A1+×2ñObþi0rdCES",
warpedStemSW: "0g0g8QîWQgZi6H]ûHUeZhGYlïYmÄZ0CÉõj]Cc_úëÁGAÖ5îJ4?e?LÆÙ-j:g?e@ÞK?aAjõÔÙÅ^NÑoîPCJ?-]h?ñoi@eÚíã&MEKaòci>o?Ð)öPD.A1+×2ñObþi0rdCES",
basaltSideSW: "0g0g5|AZ-?YËâZ(IZoûW42T9+SÑ989yR0ùlA0ù0(0÷R9Py_Õw]022PA2PwùP0oP0i]miPyS9yi1w]PwÂPAhw080wò9AÂc4ûSAh%ë?008úil1E4eRÉÚE?",
polishedBasaltSideSW: "0g0g6(IZ-?YoûW|AZËâZâlH4JS9w1AþIA2lJ@lÚGNöIAG[AÛlÑßÉÙßÉÚG?AþlÉþlÚJPBGlÑGlÚGlÚÛÇ%J@lþlÚGlÙJÉrÛPAG?zG?ÚÚGlÛPAAE]0ml90SP0P",
crimsonPlanks: "0g0g7èOHÕLYXSY]ûHÊiWQîW;ßZ4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
deadBush: "0g0g5000ÀrHýJYÒRZe?H0000g00401ù0040Îë006ëQë000kÑg000?w000JqÕ0]0miõ)S00Èï(000b]ë0001]0002h{ë000ÉÙ0000pÙ+0001Òù0001A00",
chainIcon: "0g0g4000AeZP@H<lW000004S006S0030009h00cS004S006S0030001000dh00cS004S006h003000000",
lanternIcon: "0g0ga000<lWP@Hò>Wì2WIíWrQYTCHZTHZsY000000000000g0000001w0000002g00000010000000ix000000)>000001yyg00004ÄÒS00003Ôã(00003äÿ(00003åñ(00004ÔãS00001yyg000000000000000000",
soulLanternIcon: "0g0g8000<lWP@H2ÇY#$ZGKHZZZKZZ000000000w00001S00002w0000100000aQ0000hE0000Â]ë000Êõë000ce0000ES0000el0000ÒEë000Â]ë0000000000000",
coal: "0g0ga000sÞZ$EZ(IWAJH)lH-sHAßHgTHsÂW0000000000000000001hg00000iOx00001?ÐQg0001UNNT0001G?Ò)g00kAáVA-00iÐRy[]00kyAQDGë0kQáDPPë0páGGååë08aáÿåA000òaAIë0008Ië00000000000",
stick: "0g0g8000?kS]?HEÝYòJHÖMZþÇS)lS00000000000]00002A0000lo0000Ðh0005Ä0000!(0001Vë000aõ0000VK0000c00005ÌN000EsN001@W0001E0000000000",
emerald: "0g0gb0001SWltY>iHnãWetZ2CZ0EW2ÂYîLZ1nY0000000000000000000hh000001z)g0000iÃ+[0001BÃ+ÑÝ001U?ÄðÝ001U?þDÝ001U?þDÝ001UPþCÝ001UP/XÝ000móÐÿ00001ÕCÝ00000GG0000000000000000000",
lapisLazuli: "0g0g8000osZ4þWt^YÈeW*èWãÌYh8Y000000000000001AC000bJG000Ùlsë03ÒøGë03ce?ë03Cê?ë0qOsi00nveG00ŠçgC01Íœe001:q]000Aù000000000000000",
diamond: "0g0gb000hIYZZZlZH_hYcrYzrHlâWqEHuPYLöY0000000000000000000hh000001yzg0000iQÃÔ0001AV*@Ý001AzzQÝ00iRQVðñ00i>?Vþñ00iCVUAñ00jQIIÓÿ007]ÓÓðÝ007ÐÓÓïÝ000åQVÔ00007GGÝ0000000000",
goldIngot: "0g0g9000eúWTUYZlZáCWZtWNÁWoIHZZZ000000000000000000000h000001hyg000hjOOM01hzOOONSlOOOOOV)iÃOO*V+Ai*OVÃãÓAiNï,ÓÓßAnN,ÓÓßAS1ß,ÓGQS00nDáQ00001kS00000000000000000000",
ironIngot: "0g0g9000ËâZEEYÞIWlÚYZZZ)lHí8WÇÒY000000000000000000000h000001hy(000hiQQz01hAQQQR(lQQQQQV>iUQQ?V>CiBQVUà,CiyV[OOyCny[OOyãK1ß[OGÓK00nDðÓ00001mK00000000000000000000",
copperIngot: "0g0g9000aiYIÐHò2YOSHaOWtÕWÙLWTbH000000000000000000000h000001hy(000hkBÂ>01hARVAR(mAQBÂQÓ>kÑRy@ÓBÅkCQÓÑyÃÅkÂðBÂBODkVÏVyÃÅÝ1BÒÂBGÝ00l?DG00001nÝ00000000000000000000",
rawIron: "0g0g9000VOYLgWZèYŒ#WZNZ-LYE,HòlH000000000hhg00001z)xh0001**)Nhg0kVÃÃÃ)x0kAVO>RRgÑGRGIßßgÏñDGìoGgÏIDähhoKÔIìhjUGKÔäìhQ>Dð6äIÓáRìm0ÓÓ0ÔGìm00006GhK00000ÓÓ000000000",
rawGold: "0g0g8000eúW?SHSjWZ?ZTCZZZZÚhY000000000000009AJ002ÃßCS0kŒgGI0JËeLs7Ú+JGG7ÖAe)ä6iŒÖyätÅÉP:vt!L&?l3Gú%Cø3DòOG~0áøtiä0fs3Zh000000",
rawCopper: "0g0gh000FUHIrH},Y.LWýeZOOWtÕWIàH}OYZbHÙLWñõH?rZcyHÎÑWA?H0000000000000000000000gX00Qx8002Ngx9{àCS0ÂúCîF÷caK0ÆLBB!gÑ9KhaúùïÝX?$0h?NùEgAO$0hjÑlegABeKÇ÷îxij÷î.?2?X-}hLÑ.r4un-RÇ÷G;ù46[òØÈgngù0x8$02kxR0000000x8000000000000",
copperOre: "0g0ge÷-ZéSZâlHÖDY.LWËâZniZIüHCóWí5Yr6Y.cYÈÆW}OY00g1zyhxhxyhhjNhiQ*ÃOCÝyh2U?(gìxyBPÔùhyhg.ãÐ2BÃwxh8ëzÇýxzBÃxrJIM0)ýM0HþßsnIgi4I1w{ëlMgìih8j,Ãh1yiy)þdzzM0PëP]1)LgI18ëh0ghiighhg1",
netherWart: "0g0g7000ÀÎW]0WëßWilYCJYÝgY0000000000000üë0005ik000+lq0ÙS+ÈL3.]}LrplpbÅI6ÉÈ1ÄS5?ß1+@iLk5+ee+À-Höå+ë-HûI;ë5Ùíi$ë9Ïíiyë9iíEyë",
wheat: "0g0g7000NoHjIYDVWâLZójHÇCZ0080008ëh0005ëa0g0d0zëC0e(q|g81D3Õ+À1È20ÆõcLak(??lÃkÀkÖ7Ð8Eggñ3dCggó2mCoc8!k-qëõ#S@#I)CÕEEI?Co;(",
lodestoneSide: "0g0g8E?YCAZ÷-ZéSZ-?ZPBWÖDYâlH42óPk]5IÚl×I%rTZ;?+O?úTÎ,tdÞd?â*rr+EåPLøiEGj?ú-ŒåLEg#oålJcLeåûÁ!JeçC×ÆsEåGE?%EKÑòB;^PÙsl;ÃÖiÁPiÂ",
lodestoneTop: "0g0g5E?YCAZéSZÖDY÷-Z40]0i09ClPGù8080ëh8jc(ip$ocóiÀ8iJÁ]pc?iPEÀc]JPyÀEQJP]oEAJÁyocIk^]pEoÏÀiÀcjAðio8090ëg9+LÚ)ù0iPwg0",
anvilTop: "0g0g6000T4WPAY;SZ-?YÁ?W000000000000000000Bm?BG?!CeFA_^üE^EôEAdÄEòGe×gÉ_ÄLeGlÁVÈeÐlÁVÈVÐcÁFkigiòBilöG{000000000000000000",
anvil: "0g0g6;SZT4WPAYÇÒYÁ?W-?Y0üaÛQS5]lJ]I1BAúgg4dAÚiò9kCJ?wCCUòy55y1PiÚ4CòPEï0üò!PgCCú6QSCiSFy0Cù9]ë5GìTw1ÚCJ%0iSGiS0úÚGëP0ÉÚ",
slime: "0g0g5à6%ÏLeçC%ç+eÈC%0C90kAdGhS0z|21AwR$oÀ00Tci0ySS8iS}g08g0]0S8î000À8ò001g0ëg2igwg04ùìx000iìS)44iAÂi9w4AÝXJÚG?d0900S",
soulSoil: "0g0g5ÇjY]LZ;EH)CWÖQH4C^ÖgABNj|24FEjÕû8PwÉQù1|ùIA2aÖ0]0ë^]20ùiÃwù8ëüúF1wACP]91Fwag]9]íJJ2óSmkgiJ0Dõëü?1+Qìm?5)KXDòFC4",
blueIce: "0g0g5×HYÛøZãeZ÷RZeLZ4CI9iò0ü]2)P0J^x)TwíaSE1A5qSCaQm?SgJSCLK6LwGLA5qx+JBg?BCÂBwÁ5kÂxgh0kÁ0i94íT0CIAüI5AùADk9AAB+ù|C?",
packedIce: "0g0g6êcHðYYJRZcfZYÍZ?HZ0CLQC?5EI]GSF@aÑù0Pùrwù9Pgh1yJ?A]9ALBy^PCI0JLF+I4DùBiSFAIaE0Ö)SÁ0T|C2Õë^Úg9Q2JÙùPFiJÑJ^|kAAüJÙCŒ",
ice: "0g0g6ðYRJRRYÍRcfR÷KR?HR0iaC@?0þINmKgJPùe0CiÑðp4Njc0P9ùûw2iÉga8ùþI2]PXG?ii]úD]XJSeESAE0$J4%A1Ñû1Ùù4Aa9EhxAiPÓ09ÑiËw2ÃC]l",
calcite: "0g0g6SnHRHHlÚH?$HZZZE?W5móÙSòFDÂßiúF:È(iÁFLLw0Â|Lò0gA×GÂSJRùCABlÈwüLFC?F]bRAS]úbÕF1ÕJjQùÂQüÁ4ùûACAïyaÕDKF:ÈÂ6SPLLëüT|+k",
loomTop: "0g0gdiÿWìîHGaZEÆZE*W(úYÁ2HlbHÖÃWD4YïGHH?YýSW1xxxMxxw?*BBB**)@++CCCC)@C+C+++A@CCCCCCA?BâBBãBá]EEääääAPååååååá@ãã++ããá@CããCCCA@++++++)?ccccccCEbEb000b@D+i+i+C?ÒÒÒÒÒÒÑ0SGgE0SE",
loomSide: "0g0g9iÿWH?YÚ3HUiYï)WöUHD4YìîHiðH0010hhg0iyyyyyywi)QQQQ>xkUQQVQ?xkQQQRyzMjyRQQQQxkQQQQQQxmÓÓÓÓÓÓÞo01101ë1iyyyyyyxkQVVUQ?xiyyRQQyxi)QQQQ>xiVVVQVUxg0ì0101ìGGGGGGGG",
loomFront: "0g0gfiÿWGaZEÆZD4YE*WA7HÁ2HïGHÖÃWiðHUiYÚ3HH?Y(úYìîH11112210NNNNNMNOMNNNNNNONRRRRRR>*??????>*??????>*ÒÒÒÒÒÒÐ,ññññññî(9ù099a3.eggggGI){{??ii><nnnnnnl<ÓÓÓÓÓÓl<÷rrrrol)0a0ù0I>rrrrrrrr",
loomBottom: "0g0g4Á2H(úYÖÃWìîH0000lVVÆg008g008lVVÀg008g008lVVÀg008g008lVVÀg008g008lVVÀWZZt0000",
jukeboxTop: "0g0g7ECW)EYÆLWÆrYå>YýáWoÁH0ù9Aí09ilÛ@keÉÐßlp&IoePÇ&IojPÎeIujPÎeIujPÎNIujPÇNIujPÇNIujPÇ&IujPK&IuePK&IoePÎ&ÉÐßlp9ilJ+k0iPAí0",
jukeboxSide: "0g0g6ECWÆrYå>YýáWScYÆLW0000005+ûÚDI9IsÞIge:#EgodIÊâIÆaiœEiAdltÁlga:#Eg85[Uâ?ÆaiœEiùdVtÁlga#!Ee88IUV?g6]Có]I4JPAJ]000000",
noteBlock: "0g0g6ECWÆrYå>YýáWScYÆLW0000005+ûÚDI9IsÞIge:#EgodIÊâIÆaiœEiAdltÁlga:#Eg85[Uâ?ÆaiœEiùdVtÁlga#!Ee88IUV?g6]Có]I4JPAJ]000000",
furnaceFront: "0g0gdÁ)Z;?YÖDYâlHËÒYJPWðoHwíWgTWEEYE?WIsHCåZ00g0hgh02zNNOzzSk*+zÒÒN(2ÓnGGÞÐw3ÎIIIIjTjEIGGIïT3EìhhoïSjÇAEEdýMjÐANRNNwbegggggù9adÓÓAAIcý[IIáÇh5ÀIIII3h3ÆIGGIõÀl-GGGGîIihg001hx",
furnaceSide: "0g0gcÁ)Z;?YËÒYÖDYâlHðoHJPWIsHE?WEEYCåZéSZ00g0hgh02O>UO)Ow2@ÏNV>VS3VÄz@V*À2?UA*ÒAMizNÄÃ?(13Ó>VÒOQwkVÐVRÒVTjQNACVU(7ñGGGGGùaaòIIIÐcqdaaaaaKmEEAaaAKb××EdDDE3)>QQQO(00g0hh00",
furnaceTop: "0g0g7Á)Z;?YËÒYÖDYðoHâlHJPW020AíS9DB|?kaR×A.Ef|ýl[ÕmÖÃgÒÇ%+cÛiìaÔ+?Fo,ÕsjÚd:ÚÙàÚKrÚr÷I0nÚÓL)a!isl[ÐMCElÇwnBÃGgEagE|dÆ020Aù0",
blastFurnaceFront: "0g0ggIsHEGY÷-ZÖDYâlH;sWPAY|)ZÇÒYÞoZóoYÒðWCåZgTWGlHéSZ1y)))>1ylÐãVÓÒlÐCòÓGäñCòPAÄÓVGPA*ÅôIñÓVÃ?ÓÕñÄÔGá@æEEQQ,á,æ001h+Ð*UI??N*Ã&cM??N÷?N;MNNNõIN]Acc9óINDaaaaÏcóDÓÕIIósøeQQQQZsIIIIIIII",
blastFurnaceSide: "0g0gfIsHEGY÷-ZÖDYâlH;sWPAY|)ZÇÒYÞoZóoYÒðWGlHCåZéSZ1y)>Q>1ylÐãVÓÒlÐCòÓGäñCòPAÄÓVGPA*ÅôIñÓVÃ*ÓÕñÓÔäî@äñÔÔIIá[IãGÄÔGÑ*ÓVVVÓÒÃ$??????i/Ln%yECz/!LC!!&z/o!!oEo?÷EooEE}]Xr}Qr}Q]IIIIIIII",
blastFurnaceTop: "0g0g6ÖDYâlHÇÒYPAY|)Z;sW4ëJP0PxiReihdicGG?+,ÚÛPxeAŒòEoÁlÚggÕÁ[ÊPB!|L?Â+LÄLŒGlÈ}_zúBy|iCöIqi@REg×+GleEO%Is^/?xiŒÞLI4giPyó",
smokerBottom: "0g0g8ÒRZÁ)Z;?Y-eZËÒYÖDYðoHâlH0üPPkëc?gþtÆDRtlËò,ÚdlØŠWÚOTÖoÄÉ,gOaOØGL|dÍÚãlÚGÉÚtgÚR:ÚelRòWÚslÇ!ÃRãlØgÈ_=léeDPOZnò0ngþiÆKüPPyS",
smokerFront: "0g0gjýLWÒRZ;?YéîHÀrH-eZÇÒYÖDYâlHPAYIsHAJHoÎYóoYEGYéSZwÎH)CHÁ)Z0Qx8RgXx80pagõÎwiSüì0^SXïx2ikA0càAO.jáoÎ8Lc%õÐoeA0w{cMõÐoiCzo{dMõÐoGCìoideØÈLG)AxqL*JàAoGX9x8J(XP8S3ow(iÞIIghÎ8iÂgCF]Rüì0^(üÎEiÀüÐ0?iQAIPigz8noiMXÐ8hAxÒF^ÂücF]ï",
smokerSide: "0g0gcýLWÒRZ;?YéîHÀrH-eZËÒYÖDYðoHâlHÁ)ZJPW1yyyyyy0)ÁjM>)lT1Uh?Qh?k0ÔGÔGGãMjäðAIñÿ0TAþåIðajMGÕÿåðÖT(ÿIIðÕðkQaåaåaaQkVQUVQV3(ÃlMÃllMjÁ?kÁ?QT1eGGggGO3ÐôÔaIæjjÐòÖäG×k?EEEEEE?",
smokerTop: "0g0gaÒRZÁ)Z;?Y-eZËÒYÖDYðoHâlHAJHoÎY0hxhyxy03kÄÔ?ÅÎ(hâÅâVVÓhlVÓ[ÓÓÅÞnÄiIIx[ÂB?EIIíQikÄIaaIÒÁDÄIaaIÒßCÄIaaIÒÎmÄIaaIÒhnÄEIIíQÂAãiIIxVÞCQUãÓÔÒÎhÑ[?GâVh0lãÞ?UÁ((hxhyyh0",
chiseledSandstone: "0g0g7REYOaY?ØWl^WlpHLoYigW00SAíP|gzÚGNþÉÚGŒG009AJ}d,eç,u%gàG,C|CþI+o%+s?gCPGEÇdCþlÚGRGAJPAüÄ%osÚRþ~_ÒEcDVUl}gÌ|ClúGoGlÚGRG",
cutSandstone: "0g0g7REYOaY?ØWl^WlpHLoYigW00TAJ^|IAÛ+?JlÚgÚG00ÎAJÄ9)lò[t9ilÚgm%GlúGL|iûÞ)oMGlÚGNN+lÛ@o&*r},CòGaö+LFClÚGN|GlÛ]l^ULÛÄýlÚelÚG",
sandstoneTop: "0g0g5lpH?ØWnÈHOaYl/W5yL^yU?AP(i{CiôPSúÕüú?iCAý1Aûi]JxïaiÀCUEüCìyòÀiUÀAÇúyCEyPÀJUCR?EJòECK?ióMj4B@ÑCiÂAC^PAòQüòTo^]E^",
sandstone: "0g0g7REYOaY?ØWl^WlpHigWLoY00TAJ^|IAÛ+?GnegÉÚ,yPiaÞåIePgaÔÑg|*_ÚRÚJJØÚAòlyâj?lÇ)JLi?giLÖRNDANÚnÞÝoEKiŒögÏÆcôÛ$?åFÞÈlaÜÙ÷iO+",
sandstoneBottom: "0g0g6igWlpH?ØWLoYl^WOaY5DqJÅi!@0J(úß)ûc8bìdcãLI÷oØ^]?ýGAÁQ$J+0ßm4JÀeÒeÆÝ*A|?EKp$2pyòrzgczJ6tðEîÞl4N]a}CœùdFöyt{0?úGe×EÆ",
tallGrassTop: function(n){
var pix = getPixels("0g0g6000í8WEEZþPHÞlWÒDH4000000í01000ð010S1íh1í00whcð00whc600(ë8400(X8400wX8)w0wëI#S0wAÕC0cCA{E02CÀ{E00Cg{(00QgÏ(844gÏwS")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
tallGrassBottom: function(n){
var pix = getPixels("0g0g6000í8WþPHEEZÞlWÒDH0XgÏ)S12gK(ë14oSwh86oxSk4mgx0NQklT0C]odKëCõSdáùCeI|ãgoacBÄwRDEÒÂGONGcCGcÄE×ðEVÄr!DûV)?FEI|þÉ$E?B")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
apple: "0g0gb000áCWèkZUùYATHGTZtÇZNÂHtßYTãYUwZ00000000000010000000z0000000g000004TMg0004ÄÃ[Ág00?òÓÖïh00?IIIäÁ00?ääGäæ00lÅâÅÆæ00lVVâÆÈ001VâVâC001?VGUC000CU?^0000ahqC0000000000",
diamondPickaxe: "0g0ga000cSHOEY#qZCIY]?HÖMZ8JWòJHEÝY0000000000000000000hhg00001zQMÄ0000nGQò000000Ã[000005Ö>Ý0000ÆùáÝ0005Ö0áÝ000Æù0àÝ005Ö00ßÝ00Æù007005Ö000000Æù000000a00000000000000",
goldenPickaxe: "0g0ga000ìÞHZSHŒgHoIH]?HÖMZ;EZòJHEÝY0000000000000000000hhg00001zQMÄ0000nGQò000000Ã[000005Ö>Ý0000ÆùáÝ0005Ö0áÝ000Æù0àÝ005Ö00ßÝ00Æù007005Ö000000Æù000000a00000000000000",
ironPickaxe: "0g0ga000?kHZZZlÚYIcW]?HÖMZoÎYòJHEÝY0000000000000000000hhg00001zQMÄ0000nGQò000000Ã[000005Ö>Ý0000ÆùáÝ0005Ö0áÝ000Æù0àÝ005Ö00ßÝ00Æù007005Ö000000Æù000000a00000000000000",
stonePickaxe: "0g0ga000PAYAÖYóEYéSZ]?HÖMZoÎYòJHEÝY0000000000000000000hhg00001zQMÄ0000nGQò000000Ã[000005Ö>Ý0000ÆùáÝ0005Ö0áÝ000Æù0àÝ005Ö00ßÝ00Æù007005Ö000000Æù000000a00000000000000",
woodenPickaxe: "0g0g8000)cWòJHâÏWÖTZ]?HwKYEÝY000000000000009Aë000Ãúa000eL?h0002gë000mär000eö(005Ad(00!Ncr01Ô0cE0aG01ë0Çh0002E00003r0000000000",
flint: "0g0g8000wíW;SZ$EZc(ZVVHéSZEEY000000000000000Aë0001{h000a^h000ÈgÆ002lHÐ00kýOn00DrPÿ00Gr{ûK0GAÑýC2klBe00@lÖÆ008_PS001AJ00000000",
mossBlock: "0g0g6PßHÛ3WTÂZÁCZÒIWßRZ50Æhën!nE}2ASi4Îþl|EÑÙNK9?EërzÞdw6x4$72ùÆAQ)cia?c(nJ9$0l4kEiÓhcíQ$ÙFwC1oöAFgO4Ò?c0I{hcr÷AÑëbzã@x",
caveVinesPlantLit: "0g0gd000ÁIWPíH{IHßRZÇ1WTÁZÞTZTÂZcJWÛ3WSðYozW00ih)SÂÏ00hjiQÀy0507hAS02òùÅacS0Cai?0EC0yAQxÀ0(004Rh(2î004qg3CFù0aE1lyaI00(iDâAI00MxlQÇù001h1A?00039úiQ002ïaIqk00CwhIaE00yÁyù0Æw",
caveVinesPlant: "0g0ga000ÁIWPíH{IHßRZÇ1WTÁZÞTZTÂZÛ3W00ih)SÂÏ00hjiQÀy0507hAS02ñ0Å9úS0CB4?0aù0y3QxÀ0(004Rh(2î004pg3CD009a1ly7000(iDâ7000MxlQÅ0001h1A?00030MiQ002ï0Ýpk00CwhÝ9a00yÁyÀ0Æw",
caveVinesLit: "0g0gd000ÁIWPíH{IHßRZTÂZÇ1WTÁZcJWSðYozWÛ3WÞTZ00ih)SÂ006hjiQDw0]AðhARw4oEðbeS04EI$0gE004{cÂ3y00Q#cDz004Rg68ìS04kelòek04_KlóÐG000Ke]ñw00bÁ4ÀÏß004É5ÁÉy004G2ÉU0000S0AG0000000S00",
caveVines: "0g0ga000ÁIWPíH{IHßRZTÂZÇ1WTÁZÛ3WÞTZ00ih)SÂ006hjiQDw0?*ChARw4oÏÄ8ìS04ëùF0Ií004P9Â3y00QE9Dz004RI62xS04kîlë8k04]KlS6X000KìSÿw008Á4ÀÏß004Æ5ÁÆy004X2ÆU0000S0AX0000000S00",
sporeBlossomBase: "0g0g5000Û3WßRZðcZÁCZ0000000Ch02ù0GbÒ6k0Nc]GidC?@mëdkiME]5ehJy?1CÑïüA0CIò)ë0G??ES0+óÀüÀ1chúDù5üiÝ+0dNbK2ëdù904ë000000",
sporeBlossom: "0g0ga000n×YSeZtsZhP0g.WýnHèLWLAWrsY0000000000000000000000000001g000000ix000001zNg0000jOOM0004ÃNz*S00RjyyMA06OxyyiOK7NNxizzÝ7jylÁyMÝ7ÒxVViÄÝ0GVÔãVG007ãäñÔÝ000ÔòAã00",
hangingRoots: "0g0g7åÃY000GlZýGYúUWesHGÆY4gÃ4mIyyÊAO{A?zwcÎNReÝoÞ(A}iÏÞAi{LLÖClÙ-i|CûP?a9AûeCl9AJ|AiPAJPCJPAJPAJPAJPAJPAJPAJPAJPAJPAJPAJP",
rootedDirt: "0g0g9GlZýGYåÃYÆrYesHGÆYúUWÚGZðoH1i(TBNwwAÂx>wUÓ>2Q4Á2BzÑn5>ÒhBwiikÁCjDTNzhÁ+NzywÂyRwR0x?C0ÁykhRkiÑBzxkyNxÏCNimSxxÀ2ÎRzkRiAgÒ@iMzzihUAyR0AyylzÐBhl(zA0xAÁiTiíTyhÃ",
floweringAzaleaPlant: "0g0gbPßHÛ3WÁCZßRZÒIWTÂZ000QhZ{nHÇhZÖRH1iMw)w2zi)kgS0gQwMNNk2(jyzx)jA)(zAAz>T323z>xxMwA2(z>TyigÁ2?M>Bi)2NiÃjÀ))ÏM,2Nß34ÎzDÑ[áÄÓÓ5ÔäGÓÓÓÓÓÓòðIÓÓÓÓÓ×AðÓÓÓÓÓ×DÓÓÓÓÓÓÖDÓÓÓ",
floweringAzaleaTop: "0g0g9ÁCZßRZÒIWÛ3WgõZ?rWa]YVTHPßH1gziiii01zNMM(jOzAÄilgNzh*ázkNO(w6@1(MiNjzjO2yMzwMNwwx?Îhjji2OÅRBji0zhÑÎkMh22zj2NjMzzxNMxy?ÎxM(z3iÅ>zjÃhNzÑÎONR3OM31MzNE0xxxxN0í",
floweringAzaleaSide: "0g0gbPßHÛ3WÁCZßRZÒIWgõZ?rWa]YVTHTÂZ0001iMw)BÔziÄágK6ïQwÕÂNU7ÅjyâÞ)jA)(zAAz>T323C>BÔMwA2*z@ïymgú2P,ÅFl)CNiûjA))CM/CNEcaEz!EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE",
azaleaPlant: "0g0gbPßHÛ3WÁCZßRZÒIWTÂZ000QhZ{nHÇhZÖRH1iMw)w2zi)kgS0gQwMNNk2(jyzx)jA)(zAAz>T323z>xxMwA2(z>TyigÁ2?M>Bi)2NiÃjÀ))ÏM,2Nß34ÎzDÑ[áÄÓÓ5ÔäGÓÓÓÓÓÓòðIÓÓÓÓÓ×AðÓÓÓÓÓ×DÓÓÓÓÓÓÖDÓÓÓ",
azaleaTop: "0g0g5ÁCZßRZÒIWÛ3WPßH4XiECë5+aÒíl|wb$ðûB2ÈFD?SmAÎJA%2À9CÃTþùSüIAEi1NA{Eë{üPBüi9yiÕGÃ|ma?wÇ?þjcDaÕíIÖ(ìÕCîÚùIÒ+ü1kÁ?Cy",
azaleaSide: "0g0g7PßHÛ3WÁCZßRZÒIWTÂZ0004DÀÞ0ûFI8ë2ATþA(CbP)Ê%[o|?j÷gid-??ük9X?ïyICFÇöÂAICe&OsIÿEØÙi?*GlÚGlÚGlÚGlÚGlÚGlÚGlÚGlÚGlÚGlÚGlÚG",
pottedFloweringAzaleaBushPlant: "0g0ge000ÒIWÁCZßRZÛ3WPßHgõZ?rWa]YTÂZVTH{nHÖRHÇhZ000000000000000000000000000000000000000001xzjkÀ003jAA)w005zmäyS002p,DFS002RAÕý(004(ÂNEÀ003w1reù000bHh000000hh000000bk000000bE000",
pottedFloweringAzaleaBushSide: "0g0gb000ÁCZÛ3WßRZÒIWgõZ?rWa]YVTHTÂZPßH000000000000000000000000000000000000000000i)zk0000lÔ>R0000@ïiN0000nÅRÁ0000PN>å0000xûzA0000(cM10000g4S400000000000000000000000000",
pottedFloweringAzaleaBushTop: "0g0g9000ßRZÛ3WÒIWÁCZgõZ?rWa]YVTH0000000000000000000000000000000000hzjz0000zAÄÞ0000h)ÕÃ0000z)âÞ0000ijQN0000jÑNh0000NÃ>O0000MNNM0000000000000000000000000000000000",
pottedAzaleaBushPlant: "0g0ga000ÒIWÁCZßRZÛ3WPßHTÂZ{nHÖRHÇhZ000000000000000000000000000000000000000001xzjkÀ003jAA)w005zjkyS002m)jCS002RÐ>Ò(004(ÂNßÀ003w1nÞK0007äë000000åë0000007ù0000007Ý000",
pottedAzaleaBushSide: "0g0g7000ÁCZÛ3WßRZÒIWTÂZPßH00000000000000000000000000000002A{h003b÷w008iFC002?Iù009Èõk004Ø}N006MÑg0024ëS0000000000000000000",
pottedAzaleaBushTop: "0g0g5000ßRZÛ3WÒIWÁCZ00000000000000000000000002Ã%(004LÁg002ÊöE004NÝù002ôúC002?Õù006cöE006ÈÖù0000000000000000000000000",
//spacer0: "0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ",
sunflowerFront: "0g0g7000s?HZGZZÃYrßH?SWhCW00000000000000000000000000aQ0000AÚ0002?ïù004c?w004oeC002?ïù000AÚë000bÑ00000000000000000000000000",
sunflowerBack: "0g0g6000BíHlrHÂÏZ^NYÄCZ000000000000000000000000009A0000ÃIë002ceg002RÛg003#÷g002ceg000UIë0009A00000000000000000000000000",
sunflowerBottom: "0g0g6000ÄCZÂÏZ^NYlrHBíH001{0000qS00002K00002ÎE0002ÂE0003ÄS0001Ý0000qw00002{0006Ië0007ÑK0009#K0001zü00004ù00004C00005C00",
sunflowerTop: "0g0g6000BíHlrH^NYÂÏZÄCZ000000000000000000000000000000000000001w00002w00003S00004K00004Ò0006I]0006ÂK0000ôK0000jS00002C00",
waterBucket: "0g0ge000)lHåOYAÖYx;Z%ÚW?HY*éYÈfWlÚYEEYÞIWþÇHZZZ00000000001hhg0001izOMg00i?ÔâUx00kÕðäãT00hkãÔTh00pchhrI00paAEgI00paAEgc00qaAEgc00raAEgI001aAEHg001dA?Hg000qA?I00001hhg0000000000",
lavaBucket: "0g0gd000)lH?OZaSYG,YJiYO?ZEEYèrZþÇHlÚYÞIWZZZ00000000001hhg0001i)?Ág00jÄÏCBT00lCCÏÏÁ00nïCÄÒú00qäIï#ú00qEdåÉÞ00qEdågÞ00nEdåÉÞ00rEdågú001Edågg001ædagg000ndaú00001hhg0000000000",
bucket: "0g0g9000)lHÞIWþÇHEEYËâZVVHlÚYZZZ00000000001hhg0001iO)Tg00iBVyzx00lÓÒyyÁ00hmÒÂxh00nThhiM00nGá>yM00näá>yT00käá>yT00iäá>yM001Gá>zg001[áOzg000káNM00001hhg0000000000",
cowSpawnEgg: function(n){
var pix = spawnEgg.slice()
var pix2 = spawnEggOverlay.slice()
for (let i = 0; i < pix.length; i += 4) {
var r = 64, g = 54, b = 38
pix[i] *= r / 255
pix[i+1] *= g / 255
pix[i+2] *= b / 255
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
for (i = 0; i < pix2.length; i += 4) {
if(pix2[i+3]){
var r = 161, g = 161, b = 161
pix2[i] *= r / 255
pix2[i+1] *= g / 255
pix2[i+2] *= b / 255
setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
}
}
},
sugarCaneIcon: "0g0g7000ÿLHHOHF(ZÏíY@1Z.ìY0000000000000005(000j?ë000c*4S01!MCA00haoh01cLG009CPoë2?áÂih1L?öE00ÅÒK000,Ø00001Æ00000h000000000",
sugarCane: "0g0g8000OhYÿ6HeÔHícY×kHûeWG2Y50Ne0NiëNe0ÀeKNeÞEeÝoe0Ne0Åe0Ne1E50Ne0Niëoe0Ne0OI0Ne0NrëNe0ÀeeÀj1Ee1Er0Ne0Ne0Ne0N5eNe0NiëNe0Ne0N",
diamondSword: "0g0gc000cSHdZW8JW#qZOEYlïHuDH]?HÖMZòJHEÝY0000001h000000iz000001Az00000iR(00001AÃ00000i?(00h01UÃ000mgl?(0001àÅÃ00001GÒ(00000mj000008ûh(0000óEOj000ha00O000m(000000O(000000",
goldenSword: "0g0gc000ìÞHZZZ;EZŒgHZSHNÁWoIH]?HÖMZòJHEÝY0000001h000000iz000001Az00000iR(00001AÃ00000i?(00h01UÃ000mgl?(0001àÅÃ00001GÒ(00000mj000008ûh(0000óEOj000ha00O000m(000000O(000000",
ironSword: "0g0gc000?kHZZZoÎYHTZlÚYÖDYþÇH]?HÖMZòJHEÝY0000001h000000iz000001Az00000iR(00001AÃ00000i?(00h01UÃ000mgl?(0001àÅÃ00001GÒ(00000mj000008ûh(0000óEOj000ha00O000m(000000O(000000",
stoneSword: "0g0gb000PAYþ]ZEiZwíWålHÇÒY]?HÖMZòJHEÝY0000001h000000i)000001zA00000iNS00001zA00000iNS00h01ÃA000mgl*S0001UÂU00001VÒS00000mk000007XhS0000åCQk000hó00Q000mS000000QS000000",
woodenSword: "0g0gb000)cWâÏWïJHwKYÇ1YQ?H]?HÖMZòJHEÝY0000001h000000i)000001zA00000iNS00001zA00000iNS00h01ÃA000mgl*S0001UÂU00001VÒS00000mk000007XhS0000åCQk000hó00Q000mS000000QS000000",
floweringAzaleaLeaves: "0g0g8ÁCZ000.NHÛ3WßRZgõZ?rWa]Y50N5A>Ñcw5G_Q09ön^õ@hùÒóùiúSËIAëó]arìiÊùyrÿßQúC4ÇÄoi4ëuszhGÉKSÑÑiÉÑCo=rbE41lÄi%i?usie-LA4?0]^AC?",
azaleaLeaves: "0g0g5ÁCZ000.NHÛ3WßRZ50N5y>Ñcw5G_Q0iöióõ@hù0óùiPwn9AëP]arìkAùyrëiXúC4Qioi4ë1]zhGÉKSÑÑiÉÑCoAEbE41e@h%i?i@ie-LA4?0]^AC?",
pigSpawnEgg: function(n){
var pix = spawnEgg.slice()
var pix2 = spawnEggOverlay.slice()
for (let i = 0; i < pix.length; i += 4) {
var r = 245, g = 168, b = 165
pix[i] *= r / 255
pix[i+1] *= g / 255
pix[i+2] *= b / 255
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
for (i = 0; i < pix2.length; i += 4) {
if(pix2[i+3]){
var r = 223, g = 101, b = 97
pix2[i] *= r / 255
pix2[i+1] *= g / 255
pix2[i+2] *= b / 255
setPixel(n, i >> 2 & 15, i >> 6, pix2[i], pix2[i + 1], pix2[i + 2], 255);
}
}
},
crackedDeepslateBricks: "0g0g8ÇÒYÚGZP)ZT4W-lH$EZAJHoÎY4CPAñ&wS0S0rw8ùJ8N%5A9@C(;lPhuaÔuKÔEJÖ$AIDgçYtnSA>nÀJì1(oX0a×ICw40lxCRGhVG&ýóëA+oe5ÃAICJPAgÉãLlÚ",
crackedDeepslateTiles: "0g0g6$EZAJHT4W-lHÇÒYP)Z4ù9wJ19a$únÀKpÚ]A?Ñr×cAA0ùLÒG?AJ1AgPJiA%í?gU?c2oÄDIdETwg0w2PdîÑe^û$jÂ]A?w2J|þhAù10ù9ÕAAÑNûT+hxEa",
deepslateRedstoneOre: "0g0ggåOYÒþHÁ?W;sW$eH{lH-EZügHigHt0WTâZigHü0WtEYïÒYsÞZ1yyOhizyzQOOxyOzh1lÄQ>)ONlÅGÎ0hi>EäAHghz0xg?nxøn1i&ryOrNlÄOghV>yÍdÐwnñór,tyxy/n?u?Nz)>r0hCVKzzN1iÔsSi-rhO=ehz>QO0hr)(ixg0iiAwhyh",
deepslateEmeraldOre: "0g0gcåOYÒþHÁ?W;sW$eHltYnãW1nY*ÐZ>iHuÏYnkH1yyOhizyzQOOxQOzkÄiAQÄ)ONÔ3OxÔ1i>0kíh0hz0zPAhxyx1oýæíOQNj]ÿeìz?Ï*ÐG0ii+Ý+Ý0xA>(1g2NzPAM0hzg0åÅC1iOQhçæEhO)ÄhEC4O0hÔ4(2xg0i0Awhyh",
deepslateDiamondOre: "0g0gcåOYÒþHÁ?W;sW$eHM4Wv|HGaWm.WÓEZlZHÎOH1yyOhizyzQÃOxyOzh1ÏBU>äûNiû,ò0ai>yO.úghz0x!ßhdEx1AãÕEÕüNiÇaaVa>yDØOVdiON:GyDÕô)>iiÏzgýÂ0hzg0BÅí1i*ÀhæãÕeOgòhEÖaO0pû):Jxg0iiAwhyh",
deepslateCopperOre: "0g0gdåOYÒþHÁ?W;sW$eH.LWniZIüHí5Yr6Y.cYÈÆW}OY1yyOhizyzQOOxA>zkV3QO@ÝONgBÃx01i>yÆÔìghz0Eãùh)>x1i03z]XNi)>gqHgyz?îwieðÝ:?G1y*03iÉ0z)Sygh0g7zzN1iOBðÿONhOÆRÆÀ>?I0hz(1iw00iiAwhyh",
deepslateLapisOre: "0g0gdåOYÒþHÁ?W;sW$eHpÉZxÕYloZglZhqZ?hZ×ÍHg?Z1yyOhizyz>QOxy>zhÄÅA)>ñ3N1p7Cg0i>y((1hhz0z*úhÕyx1-edye1Npc00h0jy!EOFlGkN(0ypÈdp>giJwóE!Khèh1w1rci(chæCoCO)eÁeëw30hÈÝw2xg0ig2(hyh",
deepslateIronOre: "0g0gaåOYÒþHÁ?W;sW$eHâüZòlHE,HLgW?aY1yyOhizyzQOOxÄÒzhÔÐQ>6ÝO+ä2zxg1i>0O+Ôãhz0xÔIAÝCÞ1i0äë3QNiOO01z>yzCàwlÔÃNOÅäìyä4>igò3)0y0hz00zBÏ1iOÔ1ÄäñÎ+á0hDòÝ30Òz)M01gh0iAxhyh",
deepslateGoldOre: "0g0g9åOYÒþHÁ?W;sW$eHaJWoÝZZGYZTH1yyNhizyzQÀzxy)>h12?Q>?ÃNiAÄÁ0ÄÂ>y*ÔÁgÓ30xÔäÎx0x1i6ãÂOQNiO(K1zCÀzÄzÀii(1OÔ21yQM>i0hz)VÏ0hQ(3BÓñÁkVKlgÔÝ1*ÔñgzÄ1O0mÝ)(0yK0g2Awhy1",
deepslateCoalOre: "0g0g9åOYÒþHÁ?W;sW$eH8wYECYsÞZPzZ1yyOhizyzQOQTyOzh1iÄÑ>ãONiDÓñÀhi?ÏMnV0hz0hyT0ARx1iQ>yÔÑNiOÄáhCëyzBÕÔig2NOTã0yN)>ii0z)>?Kh)QhzQM1iÆÒÁiðÂhOmÀ1zÒ4O0g3ÔM0xg0iiAwhyh",
deepslateBricks: "0g0g7ÇÒYÚGZT4WAJHP)Z-lH$EZ4JPAùjw00ë0ew1w08û!8ùi5j)!CúFÃilÂócàGlÚgÉe?haçÓNA2>4JP20ew10i1jw40iS#y8ëýE#h10GCeaICGlØGlÚlÚaÜÚG",
deepslateTiles: "0g0g6$EZAJHT4W-lHÇÒYP)Z0ù90J1Pa$JVÀÙpÚPA?Kp×dAA0qJÚG?Aù1wgPJ?×%ð?gUac0oECadE1wg0w2PdîÑE^û$3ÂPA?w2J|GhAù10ù9ÖAùÚíûP+?Ù2a",
deepslateTop: "0g0g5ÒþHÇÒYPBWâlH;sW5yS1cgiAôdhnQñi^6?úhxw0nÝEóúgëÝ0P]C3ÂRú!QòdIJ0,1xGaA78düÂQÐú1C>Igr@S3ú2IIýA]JüÀðsxñhQ0NA,0AdyBiÂ",
polishedDeepslate: "0g0g7ÚGZÇÒY$EZP)ZT4W-lHAJH00S42a4ÿ#AþL4gjÑJÈhgAgUEcþIAEÏlFzCBmNÆNöG?BiPCiÏe@?&JLl#AdÇmhJPýJNii_úJLaiEG]JAJ?ÑJÈcJLÙJ}FÑG?ÒG",
chiseledDeepslate: "0g0g6AJH-lHT4WP)Z$EZÇÒY000000FGLÚGùB+JÚCIJ]Â]IAë0Â]ë4ë19C04ãLS0gØXû02i{5+S2+IògAùGUhGÑùdg1GaeGC4DLÚC?BCLFokipx(AK000000",
cobbledDeepslate: "0g0g6PAZ)lYÖDY;sHåOYÇÒY0DqùÀeck?TðÐAG^ceÉÏ#?5J?úÀbÑawV0ie9#U+^íG3cþÈCq1úM?cm?ÄE%ÎJÚSmoei5cJ_Û0SE+U÷ë>ÒóOSi?Ñ]lknSci]Ùly",
deepslate: "0g0g5åOYÒþHÁ?W;sW$eH5AaACL}@l?ClAiüJ,rÕClQ2^öCLAíÃ1kCBkú4crPgqFGiB-L|+kEDLÛQúPdzEDûß)ëBN0|+ìFG9FGòÚiò}.r0üNKC]0CüSüò",
tuff: "0g0g5ËâWÖGZ|QHð7YCòH4Jjw2hÑùrFib%JÆ]0ÉÞE0QùS%E0%üaBCbÙXIxm?ÑCiÑ+I0í3wy]ÚEb16Sß(S$m?ùCgõþrFwbÚùùAùÉcXÉõí?82?Î2SSmiPg?",
amethystCluster: "0g0g8000jøWZ&HEWWöEZZTHåØHÒpZ00000000100000aK0000^X0002^ùë002eÝë00c?l000dplë0]ìclëÂFhelíúNûsäjÎN%sê>x6ÐHct80RgCÚ00|SOo00ÜtWt0",
largeAmethystBud: "0g0g8000Z&HjøWZTHEWWöEZåØHÒpZ000000000000000000000000000000000000000w00001E00009Þ0000lÉë01C%ÉXh1)*CDë1ÐêHAë2RLHÚS0ËRÅo00ÜTÍt0",
mediumAmethystBud: "0g0g6000jøWZ&HÒpZåØHöEZ000000000000000000000000000000000000000000000000000000000w00001Q000y1Qk00kÊ(C00pÐEi00ÄŒJ/00@NeG0",
smallAmethystBud: "0g0g5000öEZEWWåØHÒpZ000000000000000000000000000000000000000000000000000000000000000000000w00001{0004A%w00k?ÞD00>zNo0",
buddingAmethyst: "0g0g9ÒpZåØHöEZi~WZ&HcRWÊOYÆOHQdZ1igjQÂ1CiB1xBÓiÝ273Á5ÏÝg1wá(1BëhiMä0NäñÎBR7ï[ñ>0)?ÁääÞ(2iÀ5-w>gw1ÀhÅ8M2Àhj7IÕßÂNh)äX*ñ*wiÀñzi2Þg5MáM5)7Á1iO0ÎjÞNgiÀgjlglK1xh)xÎ+",
amethystShard: "0g0g8000Ú/YZ&HUoYEWWZTHjøWöEZ0000000000000004JS000FAh001òÊh00aJrh00ßAth03NNs00p*;E00ZL<ë01c;$001GèK001ET0000,i00002S000000000",
amethystBlock: "0g0g7ÒpZåØHöEZi~WZ&HcRWÊOY5ibJCÄ!CÁÅÏù8ëdna]5dI4ÄòFA0EkMÄy9ejëßÈ]Eg2!ëÖQCg6ïÈwgÐAEÀ?cÈBÄ÷5UÀ!lÀ!GIlIÖ0NF5DëiùÈwE8$íOhkPÞsÌ",
snow: "0g0g3SZZZZZSZZlTlSVÂýhV!þVÂdÈlÈìÕVah]ÁkBhÆÁc?×UüïF^iccqÄðS?ÂókVa0VUE4ÈmClÕ10VC",
powderSnow: "0g0g3SZZZZZRRYlTlSVÂVhVCþVÂÖÈlÇìÑV6h]ÁkBhÆÁc?×UüïpPiccqÄ@S?ÂòkVagVUo4ÈmClÑ14VC",
snowGrass: "0g0ghSZZSZZZZZlHZeËHåUZêCYÆrYýgZGnWÚgZåÃYGlZýGYðoHÚGZâÑH0004Rgíh8S0XgXy8Xg0S02h4x8R000oh14x8RhëÐwi(c20hMùÑFcMõÑoiáoòPiÎAdÁJíCÐÈ?igØÖLlee×LlgÔÉÈgEŒÉ}gAŒÈLGMÚÉÄi%ö:oãg?×LLeÚçÈegÔÇLGgôÈLgeõÉÄG%eÇ?âee×jIaÔÐmlee×?Le?ØÄGgÔ",
/*n => {
const pix = getPixels("0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ");
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
const { random } = Math;
for (let x = 0; x < 16; ++x) {
const m = random() * 4 + 1;
for (let y = 0; y < m; ++y) {
const d = random() * 0.1 + 0.9;
const r = 0xff * d;
const g = 0xff * d;
const b = 0xff * d;
setPixel(n, x, y, r, g, b);
}
}
},*/
snowball: "0g0g7000e$YlKWŒRYæAHZZZIÚY000000000000009A0002ÃÕh00koeo00nËEÐ00gÚâO00eÚge00dËÖO00œŒez00leÉÕ00>G?o009aiS000Aù00000000000000",
powderSnowBucket: "0g0gb000àdWZZZnnHYKW)lHSZZlÚYEEYÞIWþÇH000hh000001y)g0005iC>TÀ00Á@)NM?00UiÏ)kl00VÁO>?V00ÅïVUÇc00ÅGäXûc00Åßäóaï00ÆßäXaï00Çßäóac005GäóAÀ005ñäEAÀ000Æädc00005VVÀ0000000000",
bread: "0g0g8000ÒxHöúZc?HHyH;EZ{nWV1H0000000004J0001FGS00aJ@Ð00Ð^]Ð03Aö@Ð0pAúiÕ0DüJBÐ0IqúzS5Pzòq05IA]k05gy@ë0t+J)00sCúC003iâ0000ØÕ000",
dirtPathSide: "0g0gc000E)YA4WúLWïcYÆrYÚGZåÃYýGYGlZðoHâÑH00000000iiNOxN)NkilzxyOiCAlBAzànñò-G?+äÅâIäVÅâGåÿGdåÿaääGaIGïIGIñääâäñGÅäÅâÅGGaääåÿAÇýIdñäòäÕñÆââñIÿGGGaäGgIâýåIñÇââaäGIñAñdIGIâ",
dirtPathTop: "0g0g4A4WúLWïcYE)Y55ÇIlL9êÍlñÄÖÊÔÁ?bÎB>IÄ9V?EÉkÖâAoQI|_5CV3lUéQTI?ÞÀèUâæÂì?IPQULVl",
farmlandMoist: "0g0g6UEZ;ëY)KHÙRHVVHÚGZ0CS0CrKw>0k3cy0ÙkoÙC>KiÉKi]Ùk>1kScCÉÙX8CC>Kk34ypÙy0ÑCrcy>KCrKüÆKü32gÉÙk>KCrKl0Ùy3cySckoÙyocüSKC?",
farmland: "0g0g6ýGYåÃYÆrYGlZVVHÚGZ0CS0CrKw>0k3cy0ÙkoÙC>KiÉKi]Ùk>1kScCÉKk8CC>Kk34ypÙy0ÑCrcy>KCrKüÆKü32gÉÙk>KCrKl0Ùy3cySckoÙyocüSKC?",
boneBlockSide: "0g0g4nÙHOöWŒaH?èY6×Dè6×EÝ+EEÝ+EEÝ*EEè*EEè*EdèsEdès×dè+×Dè+×DÊ*×EÀ*EdÀ*EdÀ6×cÊ6×cè",
boneBlockTop: "0g0g6?qHK!ZnÙW?õYŒaWišW5,AJ+ïFGòF+k|cSGüLÚhÕ2JaÙlÚCaÉóôÕG0UI1ÚG?UXb?GLcX1ÚGócóôÕGl{Ië%GlUÙù0GÀÉÚj?Gía|C|2üL9GòF+?c,AJ+I",
boneBlockSW: "0g0g4nÙH?èYOöWŒaH01S05VVÀEEEEšYoZeEZšZZZZZZZZZZZZZZZZZZZZeŒZtEteZEEEE×cVVÀlV10000",
glowBerries: "0g0gg000ÓRZÁ?W{IHFÁZ%JYIiZÇ1WÞTZhúHrUHS5ZSðYlIYúhY.IW000000000000iw000001)Ä000003áRK0000äáQK0007ëëQm009aùë4Ä00Agd85Ä09EJLo5R09EeaO0R09EaaOùr09eaEŒE000oejAE000erOEN000000rN0000000000",
hayBlockSide: "0g0g9òiWHcWþ1ZilWERHcyZcRYú2WX?Z1x3xxTx>xxzxAxT42T1A244QÄãÓGäãÓãAA4AAA42xTx34AA4T>xzT>AxT>>x>T>>>>>>>>>>>z>>T>>x3xAARx1TGÓÅÄÅãÓã2w022A2240A44y24A4x1xA434x3x3>zz",
hayBlockTop: "0g0g5HúWýRWE(YòIWjhY5y?BA^Î2JÕCRPQiÀwlÕñ8FÐa$ùÃ{ChÎCA9cqP8T@4ÁSGòÀCiM11?o2?i?ÀyiFDó(CûÎcaÎ5aÀ)Ã{ùIÖCcEX9BkRRAì8þóÕCÆ",
hayBlockSW: "0g0g9òiWþ1Zú2WERHcyZilWHcWcRYX?Z10wOOhSgOMBVÓÐÞÓg1ÞjOMzhÐ0ãVVÐãÓ1gTOMgÝgÄ(zVÄÐãVg0TOh1xhÓMàVÒÃzÓ10>OO1whÄMxÒÄOì+MhxOOhwjÃjãVÒOàÓg0ÝOMgÝMÃhãVÃOàÓg0zjM0z3VMãÒÄMà*",
wheatIcon: "0g0g7000ölZV>YécWDVWjIYNoH0000ë0000}2000gÝE100j)I800pDoS00xiA^00BkLÀ00oü?q01&Lþù06GïC00)LÖm09?JSAëeiù0006+ë0005Cë000840000",
diamondShovel: "0g0ga000cSH8JWOEYCIY#qZ]?HòJHEÝYÖMZ0000000000000000000001i000000j)w00001*>w0000jUÃw00006?N00000Ôîw00006ä200000Öë000006ä000000Öë00000Óä000000Ôë0000008ë0000000000000",
goldenShovel: "0g0ga000ìÞH;EZZSHoIHŒgH]?HòJHEÝYÖMZ0000000000000000000001i000000j)w00001*>w0000jUÃw00006?N00000Ôîw00006ä200000Öë000006ä000000Öë00000Óä000000Ôë0000008ë0000000000000",
woodenShovel: "0g0ga000)cWwKYïJHÖTZâÏW]?HòJHEÝYÖMZ0000000000000000000001i000000j)w00001*>w0000jUÃw00006?N00000Ôîw00006ä200000Öë000006ä000000Öë00000Óä000000Ôë0000008ë0000000000000",
ironShovel: "0g0ga000?kHoÎYZZZIcWlÚY]?HòJHEÝYÖMZ0000000000000000000001i000000j)w00001*>w0000jUÃw00006?N00000Ôîw00006ä200000Öë000006ä000000Öë00000Óä000000Ôë0000008ë0000000000000",
stoneShovel: "0g0ga000PAYoÎYAÖYéSZóEY]?HòJHEÝYÖMZ0000000000000000000001i000000j)w00001*>w0000jUÃw00006?N00000Ôîw00006ä200000Öë000006ä000000Öë00000Óä000000Ôë0000008ë0000000000000",
diamondAxe: "0g0gb000cSHOEYCIY#qZ]?HÖMZ8JWuDHEÝYòJH0000000000001g000000ix000001zT00000iO*K0000ß>îù00007â-,00000Äû,00005d7Ý0000Äù000005Ö000000Èù000005Ö000000Èù000000a00000000000000",
goldenAxe: "0g0gb000ìÞHZSHoIHŒgH]?HÖMZ;EZNÁWEÝYòJH0000000000001g000000ix000001zT00000iO*K0000ß>îù00007â-,00000Äû,00005d7Ý0000Äù000005Ö000000Èù000005Ö000000Èù000000a00000000000000",
ironAxe: "0g0gb000?kHZZZIcWlÚY]?HÖMZoÎYþÇHEÝYòJH0000000000001g000000ix000001zT00000iO*K0000ß>îù00007â-,00000Äû,00005d7Ý0000Äù000005Ö000000Èù000005Ö000000Èù000000a00000000000000",
stoneAxe: "0g0gb000PAYAÖYéSZóEY]?HÖMZoÎYÚGZEÝYòJH0000000000001g000000ix000001zT00000iO*K0000ß>îù00007â-,00000Äû,00005d7Ý0000Äù000005Ö000000Èù000005Ö000000Èù000000a00000000000000",
woodenAxe: "0g0gb000)cWïJHÖTZâÏW]?HÖMZwKYÇ1YEÝYòJH0000000000001g000000ix000001zT00000iO*K0000ß>îù00007â-,00000Äû,00005d7Ý0000Äù000005Ö000000Èù000005Ö000000Èù000000a00000000000000",
strippedDarkOakLogSW: "0g0g5-iWQLW]?H{rHÀrH000000BAPACRQJôßEòÛ]ABy{]ÿxBgAÛiÉ|EúÞA?J]{ÂQJJQüBPiPCJÂCûÚBAQdxACûCAJ^@JJRÂÚIsQûzÝJJBy^QCJ009w00",
strippedSpruceLogSW: "0g0g9ÒÃWÎRZÞÐHåÐHìîYéàHïîYéàYÚÐW101hh01hwyyyw3Q(N2NyO0OyV(0)@Ò+?Ð0OQVO>Ñ+QÐyw2yOÑ>ON0NVV0)Q>)@Ñ)O>,ÓÑGNy03Q00O0N3Ohnà*(3(00OÑQVÃÑVÐVÃ03Ó+>03-3Q(2yxIyI001h1g0ghg",
strippedJungleLogSW: "0g0g7E5HýsHCkZGlYG+WH@HA4Y4DODRTÙI%F?TáI4V?3áGiVGri-3ÂÑ?+8cûwze6Øöc8$8Ðâ?8E?yE*a!*bÐ-ó]Gyò)a@-qúQ?!o?ÖhrFhh?Iî1Eõ?OîdhdDgT",
strippedAcaciaLogSW: "0g0gqaÐYcÐYaÐHýÐHcÐYaÐHdÐYdàYeàZeàYgàZeàZeàYgîZeÐYIXWhîZgîZdÐZeîZgàZIXWcàYcàZcÐHcÐH0Q1õëp{18>-ißgXygígOÂ?Ia898ggÕàASGhÊÏlheàCsiMõÒ.jÛcEXÁjâØ8oiõOoi&çN?iMMíIiMàAÏhj(Ö[.jcsoiCçn8.jàÐ?ÂüçLlhrîcoLüõÏñ.kàA?GMR?X*ÐRnØÆcÖcÓg8TÿØxdp4:NAx9àoioix8Ðr6;I>",
strippedBirchLogSW: "0g0gnEÓWGdHGãHGðYGðYHþZilYiIHidWigWjsWloHilZigHjOZl8HLsWiIHiIYjlZl8WiIYigW0Q0cx8X(õ08RRkI/6(cFaJigwyüJgðÂRleò^Âgú^:ÊgHgX2üiiûÈdhoßü?cFálEiiMJgd@âE?p^_ÄgdiÂõüajàJgh^ÞJÿ.jÂAO.COAOoI:aoiiMAJh×Â{ÒF@PAqeRÐAÐoiiÂùú×(RCïFgXg4+x$_BwoX(8>gQy4A",
strippedOakLogSW: "0g0gmúLHúLWasHC4Ya?HE*WG?YiãWE*HE?YEBWGVYDAZE?HHâZHãWiðHHÒZG?HE*HC4HasW0Rx4200M80p6Ãccx6RcÐ/6)c!!LÂüe.JüeIT^MöØÈLGgK.NÂGOÈLgeÛ;wáwc/NâeF^ÂÿAO.L?CgáÄgeIÈLEýØ.nleÔ.NÂe(;wàa?._DHOßLüCOÈLÂgI!NäR7ÆI*aF^}G%Ø;i.EOÐCÞö8AiPõÙAO.Jbx6/ÄcÐikcÕ",
strippedDarkOakLogTop: "0g0g9)cZ(cY{IY]eHÀnY(ÝZ-úW;cW-eZ0g0hg1002yzz>NyxiVÓãGGÓS2URyzyCx3ÏOOOOD(iß+ÔãÐC(3Ð*OOÐ+x3ß+,ààD-3ß+,ÐÐC-3ß+OOà+(3Ï+ÒÔàD(îßOOOOC(íßzyyACMiããÓÓÓÓxiyOz)Oywëg0g00hg",
strippedSpruceLogTop: "0g0g9Q?WS?ZQnZìîYåÐHòûYÇiHÎyZÞRZ0g0hg10yzO))U>O(jÓGñIIGÀ3ÒÃO)O,M4àQQQQ-Sjî[äñá,Ská@QQá[Mkî[[áX-S4î[[áá,S4î[QQX[S4à[ãäX-SkîQQQQ,Sjî)OO*,TjññGGGGM3OQ)?QO(0g0g00hi",
strippedJungleLogTop: "0g0g9ýsHC4ZClWCkZGmHdOHH+YýCHaiY0iN0002x4Q??ÒUQTkGGñIIGK4ãÑQ?Q[RláVVVV]ÃkXÅäñâ[ÁBâÅVVâÅRlXÅÆïï]Á5XÅÆââ[ÀlXÅVVïÅÁláÅGäï]Á5XVVVV[ÀAX?QQ@[ÁkññGGGGTkQV?ÄVQRhx0ihhg0",
strippedAcaciaLogTop: "0g0g8aàYúÃHgîHeàWIeZöNYaRYcÃW0ë9wg09AlöCù!nHZTCaiJ|BúfClÚg?#dgT*AL,ÉÜ,úLdcRg?fdcK*AfdaÜgAfDgng?LDlÚgA#CLP?a#RGlÚú9ClÞGù0ë802]",
strippedBirchLogTop: "0g0g8D*HEÓWl8HilYlEZDÄHEGHGdH4J84J]FAlöCúanHZTC!iJ|BúLClÚg?#dgT*af,ÉÜ,úfdcRg?fdcK*aLdaÜgafDgng?LDlÚgabCLP?abRGlÚú9ClÞGùAíPAëP",
strippedOakLogTop: "0g0g9éûYòiWïGWGVZE*HiãWéîHýLWCkZ1gw0yxh23O))U>O(3ÓGñIIGÁ3ÒÃO)O,(4àQQQQ-Szî[äñá,T4á@QQá[M4î[]XX-T4î[]áá,S4î[QQX[Rkà[ãäX-R4îQQQQ,R3î)OO*,S3ññGGGG(3OQ)?QOM0g000000",
strippedDarkOakLog: "0g0g5-iW]?HQLWÀrH{rH5+a&m]1CÁ$A]8DÁ$þ]5Ð?XiI4AÉAGI9AÉB-ù9crMokaAÉMpaalpMja9[pBJL8þcÒük5-òÞüù5)ôÑþI5)?%+I9>r|Cù8IxQDÀ",
strippedSpruceLog: "0g0g9ÎRZÒÃWÞÐHéàHìîYåÐHïîYéàYÚÐW1z?)yVÎh5AÒ*BjÒg4ÄÂ)xjUgkVR+ÁÃkgljÂCâ)lìhmÁUâUhë1ÄMkTUÆx2UNlÎã*x2ARBÎâ*ì2BRUÎ5Më2xVUá1Á0iÁÄUU1ÎxixkUVÁ*wilk?TÁ)w1zÄTÁÁ@wiÃÒÎÁlÒh",
strippedJungleLog: "0g0g7ýsHGlYE5HCkZG+WA4YH@H0JÂÙ6]Pp00GJ1yCöûÕmGûÞG^JqNAIECa_PE|fÖeöIS1gxL>ÆLRPÒECaB)íihNkhúzs&PcÙiJßiJXù809yÀ]?7ÖòÚð?Qüg1Ei",
strippedAcaciaLog: "0g0gqýÐHeàYeàZeÐYdÐYgîZgàZeàYgîZaÐHdàYeàZeîZaÐYcÐYIXWcàYhîZcÐHcàZdÐZIXWaÐHcÐYcÐHgàZ0QMùcxõÃCë^þCgcFõÄIò_ùsgEFõ-8ò_þsQEFaÐSJÕþð?4oi-RKwAÈÄzpó*ehEAÂl?(iMhI3EEö?(?M9hØXÂõÒo?hb0àïiõcoN)9h3üIAcoN)yÖ3üs8csUMyÖ×÷SIC)Àxg9|j,aÿOkÂhFGmMaXgNVgh×EMACzNÁw0",
strippedBirchLog: "0g0gnEÓWigWilYjsWGðYjOZGdHGðYiIHl8HiIHloHigWGãHidWLsWigHilZHþZiIYiIYl8WjlZ0QM4>oXx440]M4ÒoQM4C-]Q4ÐPÀMoCMIKdFÇÀMpX.iKýØÇÀxcöÖijc#9^yaöØðnõÀEiiAðNInüTEL-IöNënõ>FR)öñ(önC>FQGEJ;òkc2ÁQ?ùJ18Gc29^PA01cÒ÷ï8^j4IÖíÏilg^ÂïeMðoRloóx5e1õ*ÀcpQwgd",
strippedOakLog: "0g0gmúLHC4YGVYiãWE*WE*HHâZiðHasHE?YE*Ha?HHãWHÒZúLWDAZasWEBWE?HG?YC4HG?H0QxùÐoðMk?0]xùÓhðÞkcS]jkÏgLÞ5TRiilígLà5?aiidyÕLMö}0Q>tyMiÞd}2iTa%piAhT2iÁöCo?QhÀSÏÄpDhiQön1iS9Di@Ñõ(ÝÂŠ8>wAÖI(QLa8>xoTFUT2ú8Óh!?5ÎÝRú8ihiwïÎß?M8>giwd_0@M8Ðgixd_",
mushroomStem: "0g0g4l;HIbHKrZišZ0K00òë0íBC08dÄEFdlDcHZËHrhHÖëFãí00C0cCE2×ÐENsþcLTSZTlZVÍcÔlVS9L2",
mushroomBlockInside: "0g0g5idHHãZjgYE@HL?W0CëF0g1C480AI0J9yüÞ4ÂT42SkCÕ8h9)AT)i0wiTwóÂ0I80íÕByd4ë]CëÂwk90C0Aù^]J]Gh0Ch9üyT0kòw2öCëcA0ë4iJAU",
brownMushroomBlock: "0g0g4ýgWýIWöcWaOYoÁhlwTÇËlÎR?5?ÀVllUmxVÃk5VlÒ?áúP?ÄhÁV@À?lAQýjS8?ý5qÁX5ÄÁRlLTÂÊVÀ",
redMushroomBlock: "0g0g6hCHHíWiCY?EYtTZtÖY4ùù4XùA2iSkëw+JPA11iiPAì1?hBwi]+18iR]ëJSðh5AJ4.Ç9Aëw:oF0JP6h]ëiPAi1A3K4JP0sEiiSitõA90ù>ÎAëA0900ù",
brownMushroom: "0g0g8000jÔYúgHÞUWÖOYÒUY{SWGÅZ000000000000000000000000000000000000000000000000009E0000PFë004^P(008Aöh0005h00007C00001N00001N00",
redMushroom: "0g0gb000a<WtCYNTWþGZißHÐTYKnZEðHREYl^Z000000000000000000000000000000000000000000000000000000000000000000000000000iy000003yz(0000OyO>0000?OVÓ000007ë0000009Ý0000009C000",
myceliumSide: "0g0ggågWÖãWÇÒWÖþYÞðWìDYEÞWòIW-cZÇ2Z]LWåÃYýGYÆrYGlZâÑH0iO?xBÁ>Tj0Qk)QÓzgàM?-?úNxMh^îTQ3dÈì+ÝMÕìq!ÎBmIòþjSpA.GõAûaÆe/GEiH{öìegØ?ltlôgrõ?HaœNŒ?r?HjH$?Nhh??ŒgggrHgT?hRH??Nhhghg??œ?s?g?h",
myceliumTop: "0g0g7ågWÖãWÇÒWÖþYÞðWìDYòIW0DO?ÈÐXEAMI%{õ?ýaÎÖmPõ-ÑcehÐ6ÌÑinUhh(Gdeí?Òe$loõìAÎcE?Ai?Ie#ïNIEÐI×6IÀiÊN?cÎaÈCmz0.x%E?Ii?ÎþòÏÆõ",
//the wheat texture is up there
wheatSeeds: "0g0g70003ìW×IY%0Z?iHEIYÚiH00000000000000000000000000S0g000ë02000h04ë020À6h02EÙ000Eo0000+0wÊ0002ë+0003K00000000000000000000",
wheatStage6: "0g0g7000NoHCKYjIYécWÇCZölZ00000000a00010j00090Bù00902ÀS02A3C(02h20më1ai0)gCóakMùÚÆ!dÐGöÆ2hTgg9>iÁEý9Tgw(íÐz{!+ìLyGE&ca%kÈE",
wheatStage5: "0g0ga000P?WawH2eYölZnNZCKY5CHÇCZh?Z0000000000010000000h0000000h00000g01y0001(04g0000Ãw600000N0403000(6Ó05O0OwÞÓ83w0Jgë@3N1gìSI68y1nIKI48a7wñKëðÔ1ÝÝÝÎÝð[4ÝÝÝSÝá74ÝG",
wheatStage4: "0g0ga000P?W2eYnNZawH5CHh?ZölZCKYÇCZ0000000000000000000000000000000000010000000i00000003A0000w02S0000Nw200000A2A00S0ySÄT03w04SÀn4AwÀÄKÀ85A5ÀÀgV85@5ÀaÝa8pÄÀùùÝùÿ96ùù",
wheatStage3: "0g0g80002eYnNZawH5CHh?ZP?WÇCZ000000000000000000000000000000000000000000001000002A000(1K001g_000ÒAr0(05I%0mweI6hEwíò7hIwJòDgPw",
wheatStage2: "0g0g6000awHnNZ2eYh?Z5CH000000000000000000000000000000000000000000000000000000000w00002K000ëÇK001ùp0004ëc0ë06ó40NECôQkÁÕ",
wheatStage1: "0g0g4000awH2eY5CH00000000000000000000000000000000000000000000010002S0g5009730cI3c",
wheatStage0: "0g0g5000awH2eY5CHh?Z000000000000000000000000000000000000000000000000000000000000000000000000000000008000002w(02030S0",
lightGrayGlazedTerracotta: "0g0gjAÖYK|WVDZÎIHmåZmóWÁVYIsYmEY?*WãoHlÚY|VHJPWÇgWÇdWËIHmPWmÖY0Qh4Ñx@30A8@hAxSh4ëxoLgE7ÆS6008ÄEXN1i6pFoLLA#-2g008RE1dÆ@gë38Rl4o8RCXÒàic4xoRâ54ßaRÐŒ:RgsEp]RgÎÆÈjëzgI8J>9hÝën8R8QúÂA0ëa00gSXÁi5Ex8S0GXoÄcÐÏ0R0IcoÄ(õx020IÐoRwIw",
lightBlueGlazedTerracotta: "0g0geyrZ)OY/JY}RZÄTZ$GZTZZy$HxTHEGHlRYNhY?KYOZY1iO>lRÔ,ähzNýzÕzG5kNÇOÐGGÝûgÁNDÓ7GaÁiÙä2wGýÈÓIDGN7ÁiÙGNG)EtÓiGRDiNi×7ßONVyÓdGzOOÇiÙ7ß)OyâúhGANOyÓErNiÓiyäæVe$ÓÙRyãÇiNiÓißãâýy$ÓÙ",
magentaGlazedTerracotta: "0g0gaI:ZneYIÙWI{WsNYraZEiYÐIZAgHlõZ1xM?Uy1111AÄÒR111xUÔã?111BÅëDÑR12?G22Ô?9BÅK3O6áÂVð0zO0ä?ÅIãÐ+äGXVQVÐ6UQQ1xBàDR11114Ý,P11114à8Px1114Ý6R1x114GÓÇ1x115QQÂ1111MMM.11",
yellowGlazedTerracotta: "0g0geZÐZrIHZgZZ?HrCZeSWcLZrLHaGHrEZZ?HZâZZGYE5H1yOxw2?Óix[yiyQðyiyixh1ADy2x!OgaMwbciiMExyGdchyryiEæiÞßÝixGEiD>hxzyxÁy^Ä2inzliEÕ2jÞiMÕÕÓyiDkzIÅÞP1yÞ>ÚhL?gi$EÑ?ÁÕh1nÄXnTÓìE1ÓÎÑt",
purpleGlazedTerracotta: "0g0gaI?YõlZcÌW$eWÑåZüNY(lYKåYÆäZÊåW1zOy(4O(0iN2(S>0x0wzSO04NÁxz6+5[Oy2)6KÆGNgwCSVñGxyN2Ð.ágyO>xy,TTOS4N2,ïù06KNy-ìS4OKÐO(ëSS+0ÿüU4S)09[ISQ4O5[ëh4åÅ(Uá8Q[hU5Pá0lh[á",
orangeGlazedTerracotta: "0g0ggš1ZmåZšûHšGHTZZvsHqŒYmóWšcZmEY?ÝWRùWnëWZaZl?YmGZ0gzyk?VK0Ý8íAgHÓnßzDèHii0xnå?0bIwx?bh1cVy,ecE0cÁíD0{?0ihIå?Lc?5hhèEJSy6Á_?0?QërÒ{h0cöwrOÊhgcw5uOÉC0h1lÁoÉ??mÍhVyVHRrÒRix5ÁuroVÂh",
whiteGlazedTerracotta: "0g0gdZÐZTZZy$H/JYSnWZâHZâZ?nWlËH^RZÂRZTjHSjH01g01zAg5ÎhhhßTÎ6hKUhEmÎhhmVoAÑ1hÑhh[ì1ÎÎÄhoyT1k1KhyJhÎR1?o!,hoz1hRODhy.hoDDáiDàyyìhhDTàNìhhiáhíÞm0ÎyTkíhÑhoDhR/g0ÎR,äóa1hkz.CFh",
greenGlazedTerracotta: "0g0ghÒSWlËHPÏH÷ýYßÏHãíH?<W|íHVCY?ÂWËRHæCHÓxHÏ1HK|WÛÂWPÏW02h8xgiRAz0iÐCxiU?EÎ8{OõCÀAVdð9ðc-AÐUÅg>gùd4ÔÂI@g>^6Nõ?/ic9E8Rhò^PkzHC8{>òR_QßkXiUiARiJE<2o÷lgóÀXRw?qüC%[]ùRò>xmÂÐ?å]ÅccxaSs?x8SI>OkLò?y518o8?D8XTLlsÎo{MIXgiMAz",
brownGlazedTerracotta: "0g0gfìÃWj[ZcLZïÃWl?YlsZýCHdOWE5HmpHöÐH?*WKnZÖ2WLÕH100zg?lQg6äziQhU00Gwx4úl60wwcbPh7ycã1%GV7Ý?ß2glQyGDíaqEc3(ÏDKinch!06Kxnh2hiC0c$?Q0xh!CrýU_hChyOVhüHELu?HÁp_EJgÊi?hQ0??H?QTUJcQiÉ",
blackGlazedTerracotta: "0g0gj$eW$eHAíWõíWEcW00WAJYAJZIÞZQTW4gHgTWoÎYsßWU(Z(lY-sW<4H)?Z0Q(gÐEcÂüd0iA4ÕEaúx!gXëgðÆaClboðßoÐPi)EØ(÷Sìîq^úö$18ggœoic%íoICtÔ#m?C|SjM$îoXL.eFÄúöÏ3X?gex0ÑòîÝkLgeNiÂöîiqlHhÈ@Add_ÉF*eÆiIEÏ>ÒChRE?ÁE}ØKliÂÏ@,$ÚØK?RÂM^gd%ØÑ?^i",
pinkGlazedTerracotta: "0g0g7GLZGiYsNYr!Y?IYlAZsÉW4ALGg!xFÃPAcF_iÇEL^Æþ|cJÂie~AûãAaÇÓlPEa_,ýòCCPAýeÓEJHae+þÚ?JP;JPB#ÚBaåFÏÚCNP_iPGJ}Æùò+C^iëe+eòCS",
limeGlazedTerracotta: "0g0gcîhZZgZeDHÌcYÈìHrIHZ?HrCZñNWôÏWHMYrLH1zOOO)?KlSyyyy[hA>8IEwDÒ(O-AIwDÒN3OIò0?nN8O[Ý4ÁUN8XÁnQÁÀNëý×cÉlSNwôqEhU2N0IÄEVS2NyI?lQ02RëX?lQò0Qy?ÁU0y4ÅçÁÒSòy_mÓlU0I4e1ÅG0yw?K",
grayGlazedTerracotta: "0g0gd?*W)?ZAÖYCåZÇgW(lYÁÒZÒlYþÇHÎIHP?H<4HTAZ1iMQÄ[0hhíP?Äÿ0hjC1hgaC0yK1E04A0xccÊ5ÀQPh6ÎÁlViákPû(elciQü>yìmIhTg[xwqcGhh4EzVÁígTk[yÁrM4Ýl4üK?ðQQ5ÀPE6(S4QVRzîMc7SÁyghh0Q1j#s1g",
cyanGlazedTerracotta: "0g0gjl?YmåZ?*WlËHK|WqŒYhdYmEYmGZ-sW)?ZqEY?<WlŠWmóWloZliW(lY<4H02xcîEXÐt6^íG(Ògõ6aiÂílEChë6GxàëgER(u0;g8UCX@^J0068UÐXxUU7ëi.LCaIJükoRKhlcÂbë38?ÐqLI^ÝRÎ8cKëý?^{íhlîgalF^ÂÊlEÙhëcCPÂëgeí(0cpNÂõ0ïÏ00üìCÂCK4x0038{Ðín!%Õ0Î9XÎigcS",
blueGlazedTerracotta: "0g0g6$GZ?nWwáWwÐYy$H<qY5wLP(ëxwLP(ùëCrÚEiÝ/ÑùL0ÑpS2iiákÖCb2Óî|+úK)ÃÒ)LFDîÒ+Á]SI|üíÂP?düqiÚ!?wGë0*K46L]6J+ër96dD>T16aÖG]",
redGlazedTerracotta: "0g0gaõíWIÞZAíWEEHJAHÐCH?VWGEHI3Yj[Z10g0z)?O0ggg0+[Ã(5O*wCÑà(3àà(6ÓQ(6QQëkÑ@0CQQS0iQ2XO,R1g4->VOãîÂ2)>Æî)Ô*wäQ)?)>OíOX@?)[OQ*-Q*á>,@ûÃOÃð>ÃÖaOà-Õ>@aPþQQ])Pû)aÑQñ)aO",
lightGrayTerracotta: "0g0gdïDWòGHòGWïcZïDHïGWìDWòDWìcZòDHöGHöGWïýZ000i2wO(0hk05i006000wÀ2Ýy03700001iEO0h00gw0002w1yÀ0907ywg0y2w00yiÃ005yxgw00000Vh001c2h000000xyyw0000r0005ÂÁ00ë0x5c(00y0205Âl50O0",
lightBlueTerracotta: "0g0gaÞGYÚÐYÞÐYâGZÚGYâGYÞGZÞÐHÚÐHâiY1hw(?0hg0O+00(g140hg000002hl00003(1ixO00(0w000030013x052K10gÀ000K1100VÃ(01h1000O01j,0O01g0g0Ã050w02g*1w000612ìwû07gx004w000(02x0",
magentaTerracotta: "0g0giýÄZúÄYýÓZaGWaÓZaãZýÄYaÔWýÔWýÓYúÄZýãZú@YaGWaÓZýGWöÄYý@Y0Rg8Ñ9^KXC06OC@]ówë1iXKXCwXx$PhQKXAg0x8ih]T(C0@M0@EXz8RgXx85wXz44(Syù@gcigAwëx8Rh4g400IÂcÏgëgX1iS18Ð(XgöDgóM81840ISxQxkí004Awrõj8RgXÁ;IMCj8cgïgëI0Xw4igXx8CgXÐ42",
yellowTerracotta: "0g0gfGiWG2WGiHHyHG2WHiHGiYGyHiyHG2HHyYG1ZiyYiiHE1Z1hiO3MQT0OÄ10OS1A1khÂyD0zxQlw0y1z*AThI0xNÂg2yyy3Ãyhýh2OÁÀhVjN2yVÃáhh2OOCÂhhhwhyî0xoôyO01g1gyOÂzNh01hJkgyyzz1hngOy#Sh2B1lyyBNyxk2",
purpleTerracotta: "0g0gmâlHÞlHâlYåBYÞ5WâlZâBHÚlHÞlWåBHâlWålHâ5WéBYâBYålYåBZÞ5HéBZéBHÚlWå*Y0Rg8Ð8i2gë06Mü01ð(ë11h4h0]c0oa(h2g#0000a0iûgõ0Èk00o600000Ð03]N04f0S1öwo0kCFo000ÐoNSw03ðM÷0o0X41003pc00IgE1ð(01I00ë0oiÐcK0000wühg001õOc80Eg2c1ëi010cùw900ÐcÛ3ë6g0",
orangeTerracotta: "0g0gjcRHaRHcÂHcÏYcÂYaRWcÂYaRHcÂHcÏHcRHcRYdÏYcÏZdÂHcÏYaRWcÏHcNW0Rg8Ñ8i2üC08Now0ðwë11i0XwSXwARh40ü!00w00h8ìkc8@(0SwX0ë004x84SX04b0SywT(0kwEw008RM4ÀXx0IígKg2gXx02h8Ñ00göïgðS8180gëSwixwë8S00xØëgI2gXT;10wg2A0ìyë104w480Xx8ígX2ü2",
whiteTerracotta: "0g0gfLiWjGWLGWLLHLLWjiWLLWjgZLiHLIZLiWLgZLLHLoWjIZ1hw)ÄSGÝ0O-04Ñg150GÝSS49Q2Gq00096Ñ[çxO00KSw004S6QS1ax0@RS1QkK00QQ[704ÓÐ(S7Þ100QO07j:4Ð01g0g0ÓQ@Sw02g+1w04Q{72ÞwL4bÝx0QeA04QÑ42g0",
greenTerracotta: "0g0g9PRY|ÂZ|RY|ÂYPÂY|RZPRHÁÂY|RH001h1g002hh03h2w0000OO3OMN02w4ywMj(00hw(jg2yyOO1Mg0Bw3h(i0O3i2zhhg001hhii000w0Ohy01mOhzw2w2(hjMi0220n03zOMTw2KyhA80w0Owz3)ThTN0z",
brownTerracotta: "0g0g7{iH{iW{LH]iWÀLH{LWÀiH4ùJFm?5]òFCPcJIPwePmi0w9ÁA?CShò201AXP2@AAúQüóS0JPNP9ACSJP4üCwjx^xPAigÁAùAiPùeRPAòBJk8m91y^9ACPii",
blackTerracotta: "0g0g6AÁWAÎWAÀZwÁWwÀZEÎW0094Xù0ù00ü0c4ùwëR4Aë00i4úi0ù0wX0001A00S2Rw2Tw09ACë0J]wA002PSw^0ù0000Aë]00ë)A04ùÂa490Ag00ú00]0Aë",
pinkTerracotta: "0g0ghc)Za)Zc*Wc?WaAYcQZaAZa)Zc?Wc)ZcAYcAZd?Wc*WcQZd?Ha)Y0Rg8Ð8i2gë06MI01@O011h3ohoùww0Sh3gF000000i)góÆÆh00o600000X03ok04d0S1öho0hõzo000ÐokSo026MõKo0Ð41004xî00ÐMói6(01(00ëSoiXcKÆ000wç0K00h^Nõ60wg0Ð1SC010gN430XÂõÕ205g2",
limeTerracotta: "0g0ghÒlHÒlWÖlHÚ?YÚ?HÖ?HÎIWÒIWÚlYÖlYÎlHÖlWÚlHÒIHÖ?YÎlWÖIW0Rg8Ï9ajon06)A18óÃë12ëjAng00k_hQjo$0000xhaxoOÕ@M0TwX0IS04x84hQ0Xc8SyITg2h8Bw008RgXKs00IÂcKg0àX10S00Û8ëàõÔ0IM01-40I0x4xkSÕ00Xwr2Ýë20XÀ-D8ÌgIC0130x04w4y0008í0XjA0",
grayTerracotta: "0g0g6-CH-CW-EH;EH;CH)CW4ùiFiP5-9xyPkJP00ò8i]009d1PBE1K2000382QA4ì4ùaS009iP1AA0JP4ùqwi?1CPAi0{0ùAiPÝJS0wòCJj0i902]00o0i]",
cyanTerracotta: "0g0gjVÒYVâZÇâZÁVHVãWVâYVÒZÁÒYÇâYÁVYÇÒYÇÒZÇãWÇïZËâZVÒHÇðWÁÒHVVH0004R0X1õ004xg01Qw00Mh0s0gRj95gí3Ca00À008Xxc004w0wgQK0002x42gíK0b00ì8Sg0182g004Rgíù000Qx9ëg0000000ïC0c09K8Xwk00000CgXx8S00000îë0k18RwG00y01C0|xë01Xw02(RgIT8R001",
blueTerracotta: "0g0g9]OY]SZ{SZ]SY]OZ{OY{OZQOY|5Z001y2w000yx03x00S000xhTOig050300iyg00y0gxk000hh2xk0603ygg0y2w01hig001yywg00000hy0S2why30000kyhiw0000y031hih00Ý0í1S004h02Thhxhg01",
redTerracotta: "0g0geõrZõ?ZùSWú3WI?Yý3WüSWùSHùrZI?ZõSWý3Hõ?Yù?Y1hiO3MQh0*Ô18Og191ph!E3Izìao0001ïNAhhVëìÆwoë0íE5zwhmh8Oìwhyj(08yz.hh2OOEwhhh0hEÃ81lÊCÃë1gìoC*yz(h01hGhg8Ðî31hTo*0dSh0E1iaC2Â2ìha",
terracotta: "0g0g5aáHýáWýÑWaáWaXH4J0{i]ePpNQ18üP47o0+XõJ]JiPBIzA0P82P0]QJ@aAiPPi0ßElßTA42]wiK2Px@]0|íhúey4Cò0J_i]?Bg?1JPe@]Aýz0iS",
ancientDebrisTop: "0g0g7SÞHéïYþnZÒkW]EW(ÎWÊLZ0CôíõecbÕÒAàEEC2kûi?i&.2eS5CG×GnÈ(qEgöÀ6Aìgl|aÐXìVsCEKx2%0×CUhÂÔ]cVL40ÈÒÅÙi?<÷EìÚC]loüúÙÀðdÓÉïkT",
ancientDebrisSide: "0g0g7ÊLZÒkW]EWSÞH(ÎWéïYþnZ4DüQíIAreSùI0×|w0ëSù0ctdS4î÷L0Ï#GÝ0g}Â|lwí}iPCAJ|ùTzÚeeë9kJPÝN0SJ]Þre]ùPÚëdÕiSLC0I2&,U2ò09AXXÅÙò",
yellowStainedGlassPaneSide: "0g0g5000Oû.lÐ.lÂŠnà.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
yellowStainedGlass: "0g0g3OûEOûpOûC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
whiteStainedGlassPaneSide: "0g0g5000ZZŠSnåRHŠTRg001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
whiteStainedGlass: "0g0g3ZZoZZ?ZZo0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
redStainedGlassPaneSide: "0g0g5000AI.ùI.õEŠüI.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
redStainedGlass: "0g0g3AlÕAIpAIC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
purpleStainedGlassPaneSide: "0g0g5000èT.äšgáoåèšŠ001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
purpleStainedGlass: "0g0g3èTEèTpèTC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
pinkStainedGlassPaneSide: "0g0g5000RšåOOŠn?gOš.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
pinkStainedGlass: "0g0g3RšÕRšÇRšÓ0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
orangeStainedGlassPaneSide: "0g0g5000lS.J?.ILŠ?S.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
orangeStainedGlass: "0g0g3?SE?Sp?SC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
magentaStainedGlassPaneSide: "0g0g5000e<åd$Šcsge%.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
magentaStainedGlass: "0g0g3e<Ðe<ae<D0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
limeStainedGlassPaneSide: "0g0g5000Hxgç1gãRåHhg001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
limeStainedGlass: "0g0g3HMÐHMaHMD0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
lightGrayStainedGlassPaneSide: "0g0g5000AÖgJP.÷-ŠþÇå001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
lightGrayStainedGlass: "0g0g3AÖÐAÖaAÖD0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
lightBlueStainedGlassPaneSide: "0g0g5000ÓÚåÏ{ŠÌ;gÏË.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
lightBlueStainedGlass: "0g0g3ÓÚÐÓÚaÓÚD0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
greenStainedGlassPaneSide: "0g0g5000ÒS.Î?.ËLŠÎS.001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
greenStainedGlass: "0g0g3ÒSEÒSpÒSC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
grayStainedGlassPaneSide: "0g0g4000|)ŠPAg?kå01ë001h001ë002ë002S001h002h002h001h002h001ë001h001ë001ë001h001ë0",
grayStainedGlass: "0g0g3|)o|)?|)o0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
cyanStainedGlassPaneSide: "0g0g5000|ŠgPO.??ŠPŠå001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
cyanStainedGlass: "0g0g3|ŠÐ|Ša|ŠD0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
brownStainedGlassPaneSide: "0g0g4000ÒO.Îz.ËiŠ01ë001h001ë002ë002S001h002h002h001h002h001ë001h001ë001ë001h001ë0",
brownStainedGlass: "0g0g3ÒOEÒOpÒOC0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
blueStainedGlassPaneSide: "0g0g5000M:.M!g%qåM!Š001S00001K00001S00002S00002w00001K00002K00002K00001K00002K00001S00001K00001S00001S00001K00001ë00",
blueStainedGlass: "0g0g3*:EM#pM:C0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
blackStainedGlassPaneSide: "0g0g3000oÎgkÁå01S001ë001S001S001S001ë001ë001ë001ë001ë001S001ë001S001S001ë001S0",
blackStainedGlass: "0g0g3oÎÐoÎaoÎD0000lVVUlýVUmVVUpVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVUlVVÑlVVülVVU0000",
lightGrayStainedGlassPaneTop: "0g0g5000AÖgJP.þÇå÷-Š000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
lightBlueStainedGlassPaneTop: "0g0g5000ÓÚåÏ{ŠÏË.Ì;g000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
magentaStainedGlassPaneTop: "0g0g5000e<åd$Še%.csg000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
yellowStainedGlassPaneTop: "0g0g5000Oû.lÐ.nà.lÂŠ000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
purpleStainedGlassPaneTop: "0g0g5000èT.äšgèšŠáoå000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
orangeStainedGlassPaneTop: "0g0g5000lS.J?.?S.ILŠ000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
whiteStainedGlassPaneTop: "0g0g5000ZZŠSnåTRgRHŠ000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
greenStainedGlassPaneTop: "0g0g5000ÒS.Î?.ÎS.ËLŠ000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
brownStainedGlassPaneTop: "0g0g4000ÒO.Îz.ËiŠ0000000000000000000000000000VÇDýGRTE0000000000000000000000000000",
blackStainedGlassPaneTop: "0g0g3000oÎgkÁå0000000000000000000000000000VVVVÒAdÇ0000000000000000000000000000",
pinkStainedGlassPaneTop: "0g0g5000RšåOOŠOš.n?g000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
limeStainedGlassPaneTop: "0g0g5000Hxgç1gHhgãRå000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
grayStainedGlassPaneTop: "0g0g4000|)ŠPAg?kå0000000000000000000000000000VÇDýGRTE0000000000000000000000000000",
cyanStainedGlassPaneTop: "0g0g5000|ŠgPO.PŠå??Š000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
blueStainedGlassPaneTop: "0g0g5000M:.M!gM!Š%qå000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
redStainedGlassPaneTop: "0g0g5000AI.ùI.üI.õEŠ000000000000000000000000000000000000000000AJÁ]CPÞECJkC000000000000000000000000000000000000000000",
cobweb: "0g0g4I<W000ZZZOEYlVýUÒÃeÇÊïþÒÅÄllUAGÒÁãËËËrÔÁ=olü?ÿe-Á}?ÿÇãÇaÅÔ^ÁUllIÇÚÃgÒÃIÇlÇVU",
strippedCrimsonStemSW: "0g0g7IOYäGYèlWëOWëOYüsWcmY0i10yA?(AB+4ew3K-NCÉzJS02N%Gi%i]5gÄlCk00bÚGÉãG0%06hGk5g+6gÉÕeôÚC0%0,ØÐËg9(02L0eC%úLaÙþüÚG?BA^E6ô",
strippedWarpedStemSW: "0g0g7/ÖH&nYNEHN-Z+ÆZ@òZ=EH0i10yA?(AB+4ew3K-NCÉzJS02N%Gi%i]5gÄlCk00bÚGÉãG0%06hGk5g+6gÉÕeôÚC0%0,ØÐËg9(02L0eC%úLaÙþüÚG?BA^E6ô",
strippedWarpedStem: "0g0g7/ÖH+ÆZ@òZN-Z=EH&nYNEH44LTwIKXL9SnIëk8TCEðk8?aJJë]AAol0ÀQ?kl2À0ÌlüíP(ËgGXh(÷ck41wgog2Îw*CwRÚ(NeEÂc,Er4ÀhöElëR9õnpwi90a",
strippedWarpedStemTop: "0g0g9N-Z/ÖH+ÆZ/-Z/8W+åWtVW%âWFiH1gw0yxh23O))U>O(3ÓGñIIGÁ3ÒÃO)O,(4àQQQQ-Szî[äñá,T4á@QQá[M4î[]XX-T4î[]áá,S4î[QQX[Rkà[ãäX-R4îQQQQ,R3î)OO*,S3ññGGGG(3OQ)?QOM0g000000",
strippedCrimsonStem: "0g0g7IOYëOYüsWëOWcmYäGYèlW44LTwIKXL9SnIëk8TCEðk8?aJJë]AAol0ÀQ?kl2À0ÌlüíP(ËgGXh(÷ck41wgog2Îw*CwRÚ(NeEÂc,Er4ÀhöElëR9õnpwi90a",
strippedCrimsonStemTop: "0g0g8ëOWIOYüsWXSYèOH]ûHÊiWÕLY4X0PiRdgsÂ+?enHZTúeClÞgAj.AJ[N~ggT[cjPÑûPajgdSInjgdl[CjgCûICO.gnI?jgAJ[CfgrÚdCfRGlÚAdgsó@?0ë0000",
copperBlock: "0g0g8?6ZlOYIlHICZcÑWeXHa>YúzW0g]02A9+ú4þr8UIAeÛe?T?gedy^|IÍ9iÂÛÕR8íûà[Ü4kaA,Å0Cœ?Gÿ5DÙöG÷9:ÒÚC@9lØâyecÇÉdhÅmoR]acjÅ×QüN/ÚSJÚs",
crackedPolishedBlackstoneBricks: "0g0g6(eH|BHkMW;?HwÁZAìZ4CÇ$þicSÉm0qcaEG[qÞírKB2Äëtâ+2GbÕiô!EVEEÇyúFi^Eügw!ìLÇlI×EGÆcA!|þhÙ-2A,rañiÒIÈEL!Ù4wePyE?AP]J^Fi",
crackedStoneBricks: "0g0g7ÎðWéSZCÖZålYóEYÇÒYÖGY5CJFFBiùÑÝIdQ6{-ù|Ï!PA0n?ApÒíSöGjïIËçÙsK<?2k%C00P8INiJCÏâõOcùhËÎiTAAE@i9AOBQApÜRËõgÉ?oJç<Û00%G00",
diamondHoe: "0g0ga000cSHOEY#qZ8JWCIY]?HÖMZòJHEÝY000000000001h000000iOg000004?MÔ000004Vò000000ÐU000006åS00000Õù000006å000000Õù000006å000000Õù000006å000000Õù000000a00000000000000",
goldenHoe: "0g0ga000ìÞHZSHŒgH;EZoIH]?HÖMZòJHEÝY000000000001h000000iOg000004?MÔ000004Vò000000ÐU000006áS00000Õù000006å000000Õù000006å000000Õù000006å000000Õù000000a00000000000000",
ironHoe: "0g0g9000?kHZZZlÚYoÎYIcW]?HÖMZòJH000000000001h000000iOg000004?MÔ000004VX000000ÐU000006áS00000ÕS000006á000000ÕS000006á000000ÕS000006á000000ÕS000000Q00000000000000",
stoneHoe: "0g0g9000PAYAÖYóEYoÎYéSZ]?HÖMZòJH000000000001h000000iOg000004?MÔ000004VX000000ÐU000006áS00000ÕS000006á000000ÕS000006á000000ÕS000006á000000ÕS000000Q00000000000000",
woodenHoe: "0g0g8000)cWòJHâÏWwKYÖTZ]?HÖMZ000000001A0000aÙë0004ýah000il00003:0000ri0000i00006r0000Në0001H0000cC0000Ü00003E00002S0000000000",
podzolSide: function(n){
var overlay = getPixels("0g0gA{?ZQIZÒ1ZQeYÖhZÒhZ]eZâxZS?ZÎxZVÎW{nZ000URZéÁZÎ1ZU?ZÀRZ|ÁW{RZ]nYÖxZÇ1ZÆnZQeZòÂWÚxZÁÁWUnZÀnZQIYÞhZQRYËxZÊRZÆrY0gîgÀicÞiwJI$îd-s0SK0sGÂ|>VVKSËðÈ$JjÙ,tMÔí(zl$üLMScN8{âðcwIcêzc(IcNOc(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(Ic(I0")
var pix = getPixels("0g0g7GlZýGYåÃYÆrYðoHÚGZâÑH4C9PCg?CÐSCÉ9(J9Ci)ykBkaEðÂ%UÈ{üÉÖ)ù9Eù84Á]2Â$üòFkÃQCA?CLPwh?0ìKNÏFihCDÃ{CRPAë?$ò{)9FXl1kòEiCByÃ")
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3]);
}
for (let i = 0; i < overlay.length; i += 4) {
if(overlay[i+3]){
setPixel(n, i >> 2 & 15, i >> 6, overlay[i], overlay[i + 1], overlay[i + 2], overlay[i + 3]);
}
}
},//"0g0gA{?ZQIZÒ1ZQeYÖhZÒhZ]eZâxZQRYÎxZVÎWS?Z{nZQIYURZÎ1ZU?ZÀRZ|ÁW{RZ]nYÖxZÇ1ZÆnZQeZÚxZÁÁWUnZÀnZåÃYÞhZËxZÆrYÚGZÊRZâÑH0gîgÀicÞIwJô(O}cek11ë0àhP*eVVì1ã3Îû9%+îÚhiÆka8(V(üLcnî5kIxrIÞðwc?ËæDËë(>5kIí8tã7ËáMîplËc,ËcKiáMîpkIá(ËáMîo(>5l>60IcnËcgIcnËcn>5?tcgIâlKâkIìlKìlËâkicÔ>5kIáMîpkico3oMCcgIc,>5l>4(>pkIX(>5?35?të(ËcgIcÔËâlËáMîpkIâ?ncgIã0iìkicgIcnKcÔKã0icÔ>5l>4(>5kicgIá(ncgIâkIcnK",
podzolTop: "0g0g6ÖhYÀRYÁMW]IYòÏWeJW4C_KmpAiawEiwëô4CÖA48hEÐÏiiCí?ÝGTë6icëi1ùPA2ò5EPxù]Ùþ0c(IxiIù4i4iòym?0DÀBGIëCÇ%EÏ&o9++ìÑaÉïEÁwG]",
rawIronBlock: "0g0g7ölHéîZLgWE,HŒ#WÒ>HZèY4DIÁ+dõ08ÖëGPùÕ0ñzyJLáþk6gCRüa)*j4EûCX?lC?ÖðI*G8ÁC1CbÖ×+]ó)F1Ec?+I+ùsPð1RLq|ëÂÕq_Ù<y$)AwEA0iúBD?",
rawGoldBlock: "0g0g6TCZiMZeEHrúYSjWZ?Z0CÆÑgrcüoÚnoCOÚõC?öaÕhüüõdwXeÇByÑB^rÑÆõF1zy?hPþn(RÂNEi]iÁþiÂ?iòK]ißkÊ$@ÁùRÑÒExyGcEgÑðNÂQL4FiúFh3",
rawCopperBlock: "0g0ghaÃZgCZdLWæÓYA+YÞüHïOYlOYonWšdHeXH|ÐZéIHÈÆWacZ}OY.LW020ëypaÐCD(00p9h{kcaÁÄÃooSõcïT1^IüI-SKEwEÂðõ62í3001kãk69kÝoi8S30i/iDcC(0Ðox0QnõïMÄÐ58-a+kCÁþÀxES0ÒFÒ8aE578c2hcÀcÃoE1ëÆ+c00jëÐ!ißhEÇRXCeÈhÝX6Æ}Xs?Ö{jýÝFiîXkäiÐ&g",
barrier: "0g0g4000H0WN0WE0W00001EESaEEEqS2EF0aÙE0F$E0C$E2ù$EaS$EF0$EC0$!ù0EqS2EeEEE3ZZh0000",
netheriteSword: "0g0ge000]CWïoHwTWÞÿWÁkZËVZ(JH{SZ$íWKlWÞkW-?YkxH0000001h000000iz000001Az00000iÂ(00001?>00000mÄ(00h01Åî000mglä(0001Tñî00001Qä(00000mÃ000009cñ(0000a(Oà000hI00O000n(000000l(000000",
netheriteShovel: "0g0gc000]CWïoHwTWËVZÞÿW{SZ$íWÞkWKlW-?YT4W0000000000000000000001h000000iy(00001A?(0000l@?(00007ÑÃ00000ä*(00007î300000å(000007c000000æ(00000Ge000000ä(0000003(0000000000000",
netheritePickaxe: "0g0gc000]CWïoHÞÿWËVZ$íWwTW{SZÞkWKlW-?YT4W0000000000000000000hhg00001yzTl0000mÓáð000000Å@000005þáK0000ÆKÐK0005þ0ÏK000ÆK0ÏK005D00ÏK00ÉK006005D000000ÆK000000Ó00000000000000",
netheriteHoe: "0g0gd000]cZïoHoÁHÞÿW(JH$íWKlWËVZÞkW{SZT4W-?Y000000000001h000000iyg000003)BÔ000003Xû000000Õc000006à(00000Ö(000006à000000Ö(000006e000000Ù(000006e000000Ö(000000O00000000000000",
netheriteAxe: "0g0gd000]CWïoH{SZÞÿWËVZKlWwTW(JH$íWÞkWT4W-?Y0000000000001g000000ix000001zM00000kO*K0000áOÃÝ00007â-,00000þà,00009d7Ý0000þÝ000009g000000AÝ000009g000000AÝ000000G00000000000000",
netheriteScrap: "0g0g8000SÞHþnZÒkWÊLZéïY]cZASY0000000004ë0001Fg000^}Â00jØß/S0GlÚgGu@?ÚRh3A?çr00HuZÛ00JZ?Jh6PAÚr00gzÜÝ00olnë00f,N0001s000000000",
netheriteIngot: "0g0gb000AÞZ|4W(CYPkY|AZÇVYÞIW-?YgTW;IW000000000000000000000h000001hy(000hk?Âz01hQÄÓÒU(myÂVÓÓG>iãÒVDG>òqdÓGác/òoIG^OOIòqI]OOÐdù3Ð^OEaù00/ó.a00003.ù00000000000000000000",
itemFrameWood: "0g0g7l8HilYlEZEGHGdHDÄHCCW4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
itemFrame: "0g0gbEJW(EY)iZAíWÞ2YåiYìyYýNYcÃWeàW)EY1iyyxhhjkQQQ?U?TmVVÑ[ãÔÎBÔãÓÓÒÄÁAUÄäñÄÄÎBÓÕIaþÒTCãåAIñÓÏCÓIIIIÓÂCÄAòaòÔÏkVäIIIÒRlÓÕaaþÓÂlÒÓäIãÄÂlâV?VUGÏlÔâU[ÒVTkQ@ÑÓ?ÓÁ1qhhyyyg",
stonecutterTop: "0g0gaýIHåÏYâlH÷-ZìûYÖxHÖDYéSZËâZÁ?W0iOOOOx04ÄDGGãÒSlÄyCyDBÁCyàGOGCÏ,ßyßàONàOGGGßCCz,àOzNyGàNÕIIIIðàOÖaaaaþà,,GO,àOO,DyÓDDßz,Gà,GGOàCÏàßDãÏÏlÄDßyGBÁ4ÂGGGGÒS0iOOOOx0",
stonecutterSide: "0g0g8000Ò2HÆ?H{IZÖDYâlHéSZ÷-Z000000000000000000000000000000000000000000F?%LLÃ?ÜgZÙóÑGòED^ÕELPDÁ{IAJ]aEJSgÆÇFlgZoLÒHslÛi?Renœô",
stonecutterSaw: "0g0g700WlÚYZZZEEYŒEYí8WÞIW00000000000000000000000000000000000000000000000000000000ÃPë00mò?y00C^MAh1JÁòyë5oõPiI8ü_EüÆcCÛLCÀ",
stonecutterBottom: "0g0g5Á?WâlHí8WóoYÚGZ0000005ALPiK9iÃPGùdGaÚG?ikJÚC]9AaÚGAdDLPoÀdGòFC?4DlÚAA9+lÚG?9Gú(CùgüaÚGkdAaPG]dGlÖ)ùdiJQAK000000",
brewingStandBase: "0g0g6ÖâZÞþHâGZìSZ÷8WC-Z0000iS0DI4J05iÈ]Cë604]CI6ùk?Aì5keFiI5:È&úh0üòU0AxyÁV0Àx:Ç}CixLÐF?ìyC4QCPy0cPiò1(cPkì0k?4J00J0000",
brewingStand: "0g0gp000;SZ|)Z(IWÎðWlOZLiZsÞZÊEWërZÇÒYúzZhÃWdiHjGHü?HLlYZZZEÎYlnYL3WNlHe÷HõwYIíY00g00000ë000h0000wë000Mg?(Ixë002ÞõAw@OX006ë8Î8i4c000ùEÒEL4ë0080gÒEi5ë03kkgÒ(i5ë03CNgÝEi5004Ò(gáëi200aÚEùÝCi000gØÕÐáëL000gOåIäCi0005eK0kh00000000oC00000000oh0000",
cakeTop: "0g0g8000SEYZnYZZZkíZRIYolHEîW0000004ClÚC]5+lÚiI9gòPGk9hjÚ+kdülÚs?dþLòG?eCO?G?dDoaN?dGLOc?dGò|C?9?lÚü?9rÃ×Gk5+I|GI4ClÚGI000000",
cakeSide: "0g0ga000SEYZnYZZZ?_Yö2HcyHènZgÎZIíH00000000000000000000000000000000000000000000000000000000000000001zOOOONg1zOOOONg1iONzOxg4lÏmÏlÎS7ÕðòAñÓÝ7ÆaaþaïÝ7ÕÇAaAðÝ7âVVVVÅÝ",
cakeBottom: "0g0g5000ènZö2HcyHÕLW0000004CLFA]5AJPCI9yÎPkÀ9üP(Jù9j9AAù8J^BiA9oPAiù9J{Aüù9yPBkI5B9Aiù9i^(JA9yPFkù5kAPAI4CJFC]000000",
cartographyTableTop: "0g0gr{IY]eHÀnY-úW;cWIsHEGYCåZHðWïeH(ÝZ]cYHûWÞoZEKZTeZZZW-ìHÖDY)nY1CW1ÀW;ZY$gW×ÂZV?HêeH0Sx8R0Xx8302Mùw02g0X9aÃs4x4XxzqóG*jigs<e0?iAQ>n6Tw8Aãiî>?8<xx20XzQx8TAàücdjQh7I&0X0XRQv4hA0S00A>NShzÂüOEX>NsAQa#ØdjiÂúFjhMa-4gíSëRaeEGAw0g4xge^Ðî02RgXeÚ×EÐqAd.j",
cartographyTableSide3: "0g0g8ÀnYÖhZ(ÝZ;cW]eHEKZ{IY-úW4ùP4ùP}:Ce5G~Ò(Ã*Def+ÈfCg÷sRø-Á?sÂ5Ar×NeôwTG?YGrŠôogXsÉ5oG4refwÈaN}*oÃÒwe4NÃ_(E×?R_EEbC~*Cd!Jd!J",
cartographyTableSide2: "0g0goÖhZÀnY-úW)nY;ZYEñW1ÀW1CW]eH{IY(ÝZ;cWEKZ$gW1NWáCWZlZNÁWïeHLiYTeZÎ1ZHðWQeH00g0104NkIRÂCcÙakLai^iccaaQ+Aiaiwc!^U?Gî8ùwe2RU+öCaLCcaRUIi$agheca0g01aÄI8{gXIER^ÄB^àa!weyaÄELLa?Cc!amIÄgýEhccageÂÙgCcc×aÀdNõaoCcÙaÂdÈÙýDCcÙ^LwXx8ÂwcÙÂüIF{ÂüIF{",
cartographyTableSide1: "0g0gk1ÀW;ZY)nY$gW-úWÖhZÀnY1NWloYEñW(ÝZ;cWEKZ]eH{IY1CWSAWáCWZlZNÁW0RxùDF^ÏüD/ihFÙOÊIg×åNëúEOAd.×8gùúiàA>.EgRhdCØþ>%?ÑÒ+FEØþd%EF^ÏýEOÄI*ÑOþigõx8IEXàþ?eØÈL>%iOþd-iMIc.iOÄiýiMþI.EOÈcliOIC*×OAigjàÄc.ÙOAigXxmd*ÙßN>oiMA>*ÙÂüIF{ÂüIF{",
smithingTableTop: "0g0g7PBZT5WÁÄZ-?H)lZAJZ$IH0J2S0i4þlAG^dIrãiI6PAý]?ÓÖ)IIa6ÔGûÖoerGlPoe>GlR]&ÚGl×_NÚG?RbNPãlÖ8ERGl|8NÚGaP8dgGL]??eÉúG?]41wLS",
smithingTableSide: "0g0gh-?H)lZAJZ$IHT5WoÎZgTWSÞH]ÞYýáWÊJWÒÿYPBZÀìZ$ÁWwûWåzH02xXÐohTõKoiyõ?oiMcÏgXÁI>gXx8RMõÏüDMóÐoiF÷àAO.jàAIhùXB7.jáwihüGMX×üïECpÊi(õàAO-CpÀ,HÐRgàAIhÀOTj/gXwhhÈcB^ÂkcEhpAOBjàAO-Cp}àc8RgàCC1ÀX.7.jXwc1UDd^ÂAlECFÊO.jàAO-c",
smithingTableFront: "0g0gf-?H)lZAJZ$IHT5WoÎZgTWSÞH]ÞYÊJWPBZÀìZ$ÁWåzHýáW0iMOO4O(OyÃBOOzNyBNzyyyyÓÓVÓÓÓVÓÄGäIIñGÒCIXñGIIÂBAGa^APÂ+ii?E?EÂ*áéG]I[ÃBöêIóæIÀBCaaüüaÀ*ji??E?À*IIIG[äÂ5ñäIIGäÃ5aaaagaÀV??????V",
smithingTableBottom: "0g0g5oÎZ]ÞYSÞH$ÁWÀìZ0JúFyë1DLÚGh$IxNRÇ$CJPBq!AJPBp}AJPAÁ}AJPBq{CJPBq$CJPAÁ!AJPAÁ!AJPBq&AJPBp}AJPBh{axCRÁ1ClÖCh1iÂBië",
enderPearl: "0g0gb000clW+ÕYCnHhâW0JWøNWL:W9)W4?WpoY00000000000000000001h000001izh0000izQOÀ001zÔIQ*001CåaI?00i,ýVAXÀ0Â]ýVA)À0Ã]ýVAAÀ05-òañB005)IIã?000È]NAÀ0005UQV000005V00000000000",
netherWartIcon: "0g0g8000HsYCûWCû0ÊÁYÊÁë{TH{TS00000000000000000000000000ÃÂë000ûaë001NýC002CNi00dxÂÛ000GJë001,Âë000ilë000CN00000000000000000000",
flowerPotIcon: "0g0gg000(ÁW)ÁW-ÎW-ÎHÝ?Yå3WåjHÕiWUìH{úZÀìHaýHòQWcgZÀÞH0000000000000000000iz00000>Äâ>0004ÄIIâS009ÐIIóE009iEEeE009ÙœJLE000GÓÓØ0000h?nØ00009jJE0000bNLE00000Tg000000000000000000000000000",
cake: "0g0gh000l!ZSAHZrWZZZEîWkíZRIYolHÙIYýxY;ÝYö2HcRWgßHIíHeÏW0000000000000Xx8Rg0002hcÐoiwX00QRkðM8R8w8IÂcITIÂgT8iTùE(]NwÎ8IQcT8iRcT8ðNgXxgTIT]ðMõÐgix8F^XMõÐgXx5#_qxõÏgðCe#^AoòEØ4ig#2US<KáwLeK0iÿ<RàLIE0005eØÈLE000000000000",
furnaceFrontOn: "0g0giÁ)Z;?YÖDYâlHËÒYJPWðoHwíWgTWEEYE?WIsHCåZt(WIÞYZKWZŠHZZZ000ë08R0X00XMIÏoiMcë96ÁA>M{ÁIK0õKAO.jjcS0?kx8Rgëõì8iXwO.kXkì0iX4x8RXkë8iüd^ÂüüüÎ8?MgÏwðxIS2LgeØÈLgew2ÂýAiMJCdì3iÂt8ReLcë1^6cJØCrdë0iñhEçNL(C9@OIRèKSdì8íLihÙulXT",
goldNugget: "0g0g8000éSZT@YToYÚgYZZZoIHNÁW000000000000000000000000009w0000ÃÀ0000Éã0000ÉG0000ÚN0000at0000ar00001ë00000000000000000000000000",
ironNugget: "0g0gc000-s0ÇãYß-hg%YlêHSKWC?Z-sWÇãëß-ZY%Y000000000000000000000000000000000001g000000yMh00002?yzg000BÓÅäù000CVæÐ0000#QIë00008I00000000000000000000000000000000000000000000",
redstone: "0g0g8000ÊgWÝ0WÐ(Wt0WSgW$0W)gH000000000000000000001w0000aÑ0000ÊG0002?ÂN00mNáN00ÐlóYë0G?Äaë3ÅqEnë0×l+t00dhYK000+?00000000000000",
pumpkinTop: "0g0g8IeHdìW?xZ?üYcÀY?CWGgWKkH0gëw211yJFyI9AjdCg0)ÂEmò9l0ëXg9dGùyAPcE?gA8ISE4ìxx=N]Àdo7r4J{CwíyÀ8ASxQ85CJF2Ixw?Pyú9m?9Ehwgh101",
pumpkinSide: "0g0g6IeHcÀYdìW?xZ?üYèrZ0g1S4TÚù?%í?ßlzNRx&zA&SK%íl%GÆ%íl%GÉ%El%GÉ%El%EÉ%El%EÉ%EleEr%í?eEl%ó?eElxóheóhxk0Ca1CÂ9Cq?CLPCL|",
carvedPumpkin: "0g0g8I?HcKYcìW?TZ?üY$0WQSWèrZ0g1S4TÚù?%í?irQyEx&#E+kK%ne,×Æ%ne,ÙÉ%nE,Úa%JAOÚc%Gie[r%l>CÃÉ&lâGnÉ&RGlÚexn+rÎExLS%r??Ý9wC[?r9?t~",
jackOLantern: "0g0gaI?HcìWcKY?TZ?üYZ6HZïHZšWLcHèrZ0102g0i2O(3(j(jN4SV43Ã3RzSÄU5V(Sz*ÓÐ5ÓÀ(z*Ôà5GKOz*ÔÝlGÕOz)G(kÔã>zO>43Q)Oz**3À5*OzVVâÅVÒOzÄÔGGGÓÐw*ÐÔ7Ó6ëw)Oîz-ûNJ90ywyJ9JFwyJFJF",
pumpkinSeeds: "0g0g4000?ÈY?oZiiZ00000000000000000g000o0S0$0K0SoE0CÙ010001ëTK2Iíh02h0000000000000",
melonSeeds: "0g0g4000ÎÃHEëYsÀH0000000000K000E00k000NKS00EK00ÀE0QC01i002hTë02Ih0000000000000000",
shears: "0g0g9000ÙLYEEYlËHÞIWò3HcOZÊeZT4W00000000000000000000iOw00001>N20000lzwz0001ÏN2O000máwzN000mÝ2N[001Ô04xÝ001Å0hn0002xhVÝ000w4VG0000S8G000008ë000000000000000000000",
melonSide: "0g0g5ÛRWDeZ*nZÂ1ZMcZ5NaQmI5yaÑkS5C8ÑkS5E1Kþ8xETÙþi%GTÙði%GTÙðixETKði5C1Ñki5y1QkI5RbQ385iiXObÒRiïebÓR?ïebÓR?ïî86ycQ38",
melonTop: "0g0g5ÛRWDeZÂ1ZMIZ%ÞY5N1ÑmI0CTQATwkT?2aÑ0ìÎùj{ë8{XAACaSA90ülòCS]2ph0JÖwxÀijwisI0P4ðh{Xëx(a8múÖgô5í^QX>?A1wCRwCë5y2wkI",
melonSlice: "0g0gd000ðyWÇúYHiWi[YCÏWEÀYäKZL?YhrZÆKZ?(ZIIZ000000000000000000000i0000003?w00000O)Â00003Ô-Â0000.+Õi0003OcÕr000+ÓO-r003ÐcÓir00OãOÐïE01>OOiÂE0bUIIì#000gVh#E000bggE00000000000",
glowstoneDust: "0g0g8000éyWoCZtSZTÇZgiWÆnZöÂZ000000000000000000001w0000aÑ0000ÊG0002?ÂN00mNáN00ÐlóKë0G?Äaë3Å!Enë0×l+E00dhYK000+?00000000000000",
redstoneLamp: "0g0g8(ÎWQeYÊIHïNYcîHecYúÐWúÂZ0000004CkaU81<adHë5KgbGiaÈín@krL=ADÕ9c?Jïg0ïrÜCS07aLr0hh?ÿíkpimÕm?doRSgAbii5gk1È?pšë4lA9C8000000",
redstoneLampOn: "0g0g6-ìHQ?HýcWoÑYSØHrSH0000004Ck9G81.Çeië5ik9iia@íÎ.geGtEDÆ9C?ýXk0ïÑþES06œgk0dgaEíkeEjánÆe@RKgo9ii5ik1.Áeië4k?9C8000000",
quartz: "0g0ga000EòWŒaZSnWòOWnÊHOéHl#YGAZÚâY00001h000000ix001h01y)001ySizU001y)j+á001OÔmÒXh00@ÕlÔ@M004ÞVÕ[Ñ01kìVÆÿù01xTâäAhg4N]âòìÓg4àAGò[,S9Gåäòñò00ÿòAòIù009ù9ùa0000000000",
endStone: "0g0g6nAHlÖHRlHisYKoYSŒZ4XI}icAEÂùíg9n8?wRÝCna^üXLTÁûÉ(!IÀhcxoV]XIPIacnhCGTÏNR]Rjïo]&wÁA2RÑüÐ9hhB4Ï}gSS#zwíýòÂ?wAb(yT5hA",
endPortalFrameTop: "0g0gaTiHapWB3YGgY%ÑZI8HOAZR?Y0SZ4ÎH000000001yxN?iyg25(?K3ÀS2,Ð0Q+àS2+4RRAÐS2ÅEIIëâS1Å]aaüâg4Å]aaùâS2ÅEaaùâS1Å]aaùâg4ÅEaaùâS2+SS04ÐS2,Ð4Q+àS25(@À3ÀS1QTU>kQg00000000",
endPortalFrameSide: "0g0ge000TiH%ÑZapWolZgeHElZGdHisYKoYlÖHRlHnAHSŒZ000000000000000000000000hhhhhhhhz?VVVVUNAÄGGGGÒRBäIaaIñR?PeJiacUâUyyyhiÅñVVVVVVäEÐñGGäóE?g?EEJiEGaeiElHJ?aõH?AeHGIEhndòEgEiIóLEE",
eyeOfEnder: "0g0gc0000ßWolYFVWÂ6Y.üYg_H.ÐZ×ÿWapWocWíOW00izNx0000hyyh0000hhhh0000hhhh0000izNx0000y?Uy0000zÑäN0000*AeÃ0000*GeÃ0000zñäN0000y?Uy0000izNx0000000000000000000000000000000000",
enderEye: "0g0gd000MðHtzH}8HÓÔZ?TZgýYô5YßGYÿ@YÄQWgeWocW00000000000000000001y000001jOy0000jQQTw002)ÄäQi002?Ö!X_00x@JiÐTE0xIßiÐTE0x]CiäìE02)ñFî_002j]Ð-r000eOOTE000behg00000bg00000000000",
chiseledRedSandstone: "0g0g7??W?LYIEHICWeìZeÁWa(Y00TAJ^|IAÛ+?JlÚgÚG00ÎAJÄ9*ãl[tmlaålÄ.Oe?OþÉËûGÚÓMgGgGNÿØÛJŒãAJãCüÄ&]Cö]L|Ðseio|GnÚiNÂÅsJ]olÚegÚã",
cutRedSandstone: "0g0g7??W?LYIEHICWeìZeÁWa(Y00TAJ^|IAÛ+?JlÚgÚG00ÎAJÄ9)lò[t9ilÚgm%GlúGL|iûÞ)oMGlÚGNN+lÛ@o&*r},CòGaö+LFClÚGN|GlÛ]l^ULÛÄýlÚelÚG",
redSandstoneTop: "0g0g5cTWgJWeìZIEHeÎZ5yL^yU?AP(i{CiôPSúÕüú?iCAý1Aûi]JxïaiÀCUEüCìyòÀiUÀAÇúyCEyPÀJUCR?EJòECK?ióMj4B@ÑCiÂAC^PAòQüòTo^]E^",
redSandstoneBottom: "0g0g6a(YeìZIEHeÁWICW?LY5DqJÅi!@0J(úß)ûc8bìdcãLI÷oØ^]?ýGAÁQ$J+0ßm4JÀeÒeÆÝ*A|?EKp$2pyòrzgczJ6tðEîÞl4N]a}CœùdFöyt{0?úGe×EÆ",
redSandstone: "0g0g7??W?LYIEHICWeìZa(YeÁW00TAJ^|IAÛ+?GnegÉÚ,yPiaÞåIePgaÔÑg|*_ÚRÚJJØÚAòlyâj?lÇ)JLi?giLÖRNDANÚnÞÝoEKiŒögÏÆcôÛ$?åFÞÈlaÜÙ÷iO+",
redSand: "0g0g6?LYhJWIEHeìZeÁW??W4C??CAÑELõr8@+9AE?FNlPCIÓþóEþ^$üúÒNÇKgÇÛi?$þ_%EbÒiAÖüÇ5JÉ(EÃ(CiBoiÙüÇPGÇÒDôlmi?laECÇEEú?oò?kó$üÁ",
purpurPillarTop: "0g0g7iEHGÉYeoZErWagZciWúaW4ù^4EPNiý+IcMnÚÖ>h%gAJÏPdRPÒhüFRJPKüF@J^?EÄÏJEOA9RJÄNü+?EÄNüFÔVG?E!ÚGlÒA0(b0ùPNnÛFÁcMiEãlFAaAERP",
purpurPillar: "0g0g7iEHeoZErWúaWGÉYciWagZ5MBiÁ_9(ýòKÃ9-ôINûò<el-û8eBiKôaGýòKô6GôIN_Xhel-Ã5MB2Kû9-ýòKû9-ôINÃò<el.Ã9MBiÎÃ8GýòKÃ8GôIN_Xhel-_",
purpurBlock: "0g0g7iEHGÉYúaWErWagZeoZciW42a4ù2%GN%GL*gÊ&GollÙmGollßmgß+RE,ÉE:ÚG:ÚEÂ?iÁPi0íR4ë^%Go%GLeGL%gÈnÅÙ*lE:ÉE*lE:ØGmŒE:ÚE+REPAJPAJ",
purpurPillarSW: "0g0g7GÉYiEHeoZErWciWúaWagZ4ùP4ùP|GLPGLP+lÂClGlÚGlÚhs1hs9Jõ?Jõ?IõAIõAG_ÑG_Ñhs1hs1Jõ?Jõ?IõAIõAgØGgØG4ùP4ùPP]aPGLPGlÖCLGlÚGlÚ",
seaLantern: "0g0g[ÂDZÂnY}nYÈ-W}nHÄ-WÄDZÌ-WÄDYãGWJTWóoZeÊZe$W?öYIÚHe{Ye{YgÊZÿbHãgZÂDYÂnHIöHlöZlaZlCWlCWlaZKöZKöY}7HJTHIéHnEWnEH?EHlöY^7We$WneZ?eZlöZ^nYOHH?HW?HHe;HleZe;Y^7HÄEW?EWIéYÂEW?öZIËWgÙZlEHûbH?éY÷TWIöYlCWPSHðLYeÊYæiWPSW@7H?SW04g(ë02a08Kwîîgg]cÐ6÷uSòyÒaX$AÁà6|r+Ýnlió4=ì9lÕúC]úpCcïCcAIG×kÐÀcRz^ò#6S?B!Ä$Èe^ýIní8hí?#m$]eÏüð?EÓ-?*bm)ÕúÏïiLGaní?#Å)ÕeÏliN02??*bmA]eÏXÓlëeAoBaÄ$ÆeRüðPCaHÞC^UEÂc>[[nE4RII]JA]úq*]ÌE=ÁonIes+ÞŠIo4h44cG(Îxs?òAgh11iyKõCEÑa(09ë2",
prismarine: "0g0g5ÌaH@DHc;WæoZ=6Y5({ÕIagiú|Aoí)Ic?8^m0wDAÙRSïE^KmAwkaëebÓ)?iiÈ}6R5Cj0új9í?5F0$8SFín(Qi$2ûÓC?Ñih2(zPþ00þ4{NcúÐ1X1i",
darkPrismarine: "0g0g6<gZ/6YMQW*UYASH.ïW4Ca4C^xisxisd^NdwLÂAJÂByKCi0C×ChÙcicdIÊdSoÂBiÂBy4C^CC^yisCisdhLCxÊÁByÁByCC^4CRxi$xisdSNehLÂByÂBy",
prismarineBricks: "0g0g8ÛoZÿ;HîrZ@DHÈGHR6YÂÕWÏaY4J]QJî(0BwSz(86wå5g~oST<2x<S9:y1Bi8jÂ1oCPIuTùÿKTÊ{SiZ3;ÏA2Ñ3ÌÐ4j?<Í?DûÐOj?WtÃ?iÒZJÒBa?WlnSÛLRâgÉ",
prismarineCrystals: "0g0g6000ßaYgÙYneZPýZûrH000000000000000000009w0000ÃQù008aÚÐ001j^?000PNS002AXJ00klðDS0Dný+N0Lœd#02ÉÑJ]02P0000000000000000",
prismarineShard: "0g0ga000ÂÕWûaZR6Zd{WÄÕY%ïWêiHMcYMýH000000000000000001g0000001xg00000MQ?À00006QATg0006ßQÞâÀ000ÏykR?ë00ÔDAQå0006ßyQp0006iDDë0000ÔyÞë0000ÎÞp000008hù000000a00000000000",
darkOakLeaves: function(n){
var pix = getPixels("0g0g5ÞgW000GŒHAÖYéOZ0C?×yUÑùzFCABEN?iJ!0ÃSJÁ|NÈAmIPiC0ìpÙXl%þ?ëkú2yc{ëa%)sQù4ÒAj%ùÉIC2Ý2^ÕG9öþIQ8ôÕÐ1wgq?)IÙü?ÒA]hJô")
for (let i = 0; i < pix.length; i += 4) {
var c = leafColor
setPixel(n, i >> 2 & 15, i >> 6, (pix[i]/255)*c.r*255, (pix[i+1]/255)*c.g*255, (pix[i+2]/255)*c.b*255, pix[i + 3]);
}
},
spruceLeaves: function(n){
var pix = getPixels("0g0g6óEY000|)ZAÖYVVHT4W4wÉwE>õí?Cþ?ÓóÇc4bA(_÷(Ç&-ic?_AEi$ð9)þÕcIp8i>4þPwE?õL_Cþ_AwÇciÖ$íI÷NgÓóÉ$þTÑ(|4e?&-i$Jo)Eicls8mÕ")
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i]*(97/255), pix[i+1]*(153/255), pix[i+2]*(97/255), pix[i + 3]);
}
},
jungleLeaves: function(n){
var pix = getPixels("0g0gb000ÞgWóoHAÖYGŒHEyWn5ZißHHÏHRæH?DW0i2j4)TiOi2NOQ2xRO0Ow00AAO0y02*4>(yi0BÓz(3Mw05ÓS0Qz0yw)A0RÅ3MwA)2]AQz04Qx?D>>0wSyBÓNS2jOR40Oj2hAQ033N02>)0N000wQ)0M(0Qz4Swxz3>>w")
for (let i = 0; i < pix.length; i += 4) {
var c = leafColor
setPixel(n, i >> 2 & 15, i >> 6, (pix[i]/255)*c.r*255, (pix[i+1]/255)*c.g*255, (pix[i+2]/255)*c.b*255, pix[i + 3]);
}
},
floweringJungleLeaves: function(n){
var pix = getPixels("0g0gb000ÞgWóoHAÖYGŒHEyWn5ZißHHÏHRæH?DW0i2j4)TiOi2NOQ2xRO0Ow00AAO0y02*4>(yi0BÓz(3Mw05ÓS0Qz0yw)A0RÅ3MwA)2]AQz04Qx?D>>0wSyBÓNS2jOR40Oj2hAQ033N02>)0N000wQ)0M(0Qz4Swxz3>>w")
for (let i = 0; i < pix.length; i += 4) {
if(abs(pix[i+2] - pix[i+1]) < 10){
var c = leafColor
setPixel(n, i >> 2 & 15, i >> 6, (pix[i]/255)*c.r*255, (pix[i+1]/255)*c.g*255, (pix[i+2]/255)*c.b*255, pix[i + 3]);
}else{
setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i + 3])
}
}
},
acaciaLeaves: function(n){
var pix = getPixels("0g0g6óoH000GlHÚDYCåZðoH5yPÑC?ÑQ>CEK$ûwAkÇ5I1]þiXA^ëEyAIQBûUNiÏõXP(k^SiÀëIc4CUõóPwA]BEÂÎSÇ(mQ|JIóJI$iRNwÊBwÏAER@6ÁXü]XJs")
for (let i = 0; i < pix.length; i += 4) {
var c = leafColor
setPixel(n, i >> 2 & 15, i >> 6, (pix[i]/255)*c.r*255, (pix[i+1]/255)*c.g*255, (pix[i+2]/255)*c.b*255, pix[i + 3]);
}
},
birchLeaves: function(n){
var pix = getPixels("0g0g5óoH000ÞgWAÖYGŒH4CP]kÂFXóxJRAARAC^cùÆB@ò8@òQNÁEX^{iûBjp0CSF2hBXPA2Á@N^8ü]]ERÑCb4XùBh9%üÁxy^xyû$kÂÒiÊEiIXGPÑE9EXI")
for (let i = 0; i < pix.length; i += 4) {
setPixel(n, i >> 2 & 15, i >> 6, pix[i]*(128/255), pix[i+1]*(167/255), pix[i+2]*(85/255), pix[i + 3]);
}
},
oakLeaves: function(n){
var pix = getPixels("0g0g5ÖþY000GTYAÖYâlH0C?ùNUÑùz&NACRN?JJ&0ÃSJÁÞiÈAðIÛiC0úpùXlNm?ëkú2Nc{ëaMiÊQù4ÒGÃ%ùÉIE^À2^ÕiPöþIQ8óÕÐ1wgq?)Iùü?ÒA]2iô")
for (let i = 0; i < pix.length; i += 4) {
var c = leafColor
setPixel(n, i >> 2 & 15, i >> 6, (pix[i]/255)*c.r*255, (pix[i+1]/255)*c.g*255, (pix[i+2]/255)*c.b*255, pix[i + 3]);
}
},
spyglass: "0g0ge000N>YhCYtþHNPW×TZcÁWSðWZZZèSYdâYÀCYUCH(ÁW0000000000000iw000001)Â00000Ô?ïw0006n)Vg000ÎÞà>g000ÿñnÞ0009dÞyE000Adi#0000iAJE000bÚ?k0000ECn0000bJØ00000dak000000n00000000000000",
noodles: "0g0g5000CzY?-HZdHLsY0000004y1xE0Bn9úaiMpb]oüEob{mCEoaõkCEoaõk8Epaöü8!Oaìü9!3qìicFR?Mic5SÏMIc5@ÑR4ò1@Ñ@4c1gÐ?C{002S2S",
egg: "0g0g7000âcWEÿZn.YSAH÷5YVOY000000000000000000009A0000ÃÕë002cÛù003zÚK00lrÚÊ00mlÚ$00mlÚ$00mlÖ$00klPÊ00dÂ^N001Gl00000000000000",
orange: "0g0gk00WåkHT0WlrZeCY$EWrTWÁSWgCYéwHtÎHZ×ZZPHtlZZÈWNhWtIWÀEWIkZaÝY0000000000000008ë00000000800000000ÑEë000001õI/iù0000OF^RùXë000*%öÂüXë006ÔMEÂüsA006ÐM^ÂõsQ006cF^ÂõsQ008cF^ÁcAQ001,d@O?Ië001)xRèùIë0008c8Rhg00000@MõÏ0000000000000",
ramen: "0g0gi00W*hYAeW$nHl4YRaWOCHI(WIsHZhWgúZyiZ;CYsÀW-ùHÞ(ZÀNY(ëY000000000000000000000000xg0000000c>g00000004Î8000000RIzMë00008Âko^{cë00oRùdRkg)00oOkï.LO)00os.jàa8)001nhRçn6ë0006Gfèqk000001eØS000000000000000000000000000000000",
bowl: "0g0g8000;CYÀNYÞ(ZShYsÀW-ùH(ëY00000000000000000000000000000000PAë00iaÖi00dy^?S0RAJÚS0gGlBS0ãlÚE00bÃ×k000%G00000000000000000000",
mushroomStew: "0g0gb000;CYhOZj+ZjÔYsÀWQhZÞ(ZÀNY-ùH(ëY0000000000000000000000000000000000000000001hhg0001iOyxg00jQQ>OB00mÏOOCÒ00nðÓÓÕý00aGGGòÀ000VñäV00000VV000000000000000000000000000",
largeFernTop: function(n){
var pix = getPixels("0g0g5000ÞlWÇâYþPHEEZ0000000000000000000000000k00000GS0y00yk0GS04ÇaA00ycMw00G_(C09cc!N010ÐÝC002õEù00nbðN00ECÝDS0C>ÑJS")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
largeFernBottom: function(n){
var pix = getPixels("0g0g6ZZhéSZ÷EZDóHÖGYÁVW0C?ÕGS5oÉÁiCgí]Úp82Ui^mLlEaÞey!S^}ÂCgl1ã2S0CiQkk0>p]GS00û%i02?b]oK9AnÖ+J0ÇÇPÐK00ÈÙC000jQë0002(00")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
fern: function(n){
var pix = getPixels("0g0g8ZZhÖGY000ÇÒYDóH÷EZéSZþPH00100200sK0200tK0200kS020dcÑ0200{L02dggi02ÓiUQ)iáOÜGiiÖîsIûÈ0dLE?L04Ñ?0201gA0200)h0200nS0200cw02")
for (let i = 0; i < pix.length; i += 4) {
let bright = pix[i]
var c = foliageColor
setPixel(n, i >> 2 & 15, i >> 6, (bright/255)*c.r*255, (bright/255)*c.g*255, (bright/255)*c.b*255, pix[i + 3]);
}
},
"water0": "0g0g8Ic%EGRDAÚl|%K;RlËÚZZRTRe4üúAùOPyPBAJBAJA0ÂFy1A2P]JJ?AP]CTAiJ4JPAþrÞJTAJS?ñAwë_PAJPAÂFAÂQíPPAJPAúPAJPkJFAPA2óPAúzÕawÿsAiP",
"water1": "0g0g8GŒeEGRDAÚIc%l|%K;RlËÚZZR4üúAÿ&PyPBAJBAJBGPFy?BEP]JJ?AÇPAÇBüJAJPAa:þiÇACÉtWÐAG{PAJPAÂFAÂQJPPAJPAúPAJPAJFAPBEóPAJLši$aTBJÇ",
"water2": "0g0g8l|%EGRDAÚZZRlËÚIc%GŒeK;R4üúAJsPyP?AJBAJCLPFzÖALP]JÂ?AÖPAÖCüJAJòAAtfiÞACÚKÅIAk]PAJPAÁPAÂ]JPPAJPAJPAJPAJFAPCLòPAJ)W^)ùn+JÖ",
"water3": "0g0g8l|%Ic%EGRDAÚZZRlËÚGŒeK;R5CLFAÒÖGûÚGlÖCa]CJ|GóPkJÚAaÖGóÚGóPClPCLF$x(CíP)ò4ÖI]ùùÚGlÖDAÚGlÚAJÚGlÚGlÚGlÚGl|GL]üJÚGlQ÷ÃPxxQCó",
"water4": "0g0g7l|%Ic%EGRDAÚK;RlËÚZZR5CLFAÒÖGÃÚGlÖCa]CJ|GJPkJÚAaÚGóÚGóPClPCLByM-CíP)ò4d2]ëÀÚGlÖDJÚGLÚAJÚGlÚGlÖGLÚGl|GL]üJÚGl]IÃPw1QCó",
"water5": "0g0g8l|%Ic%EGRDAÚK;RlËÚZZRGŒe5CLBAÒÖGÃÚGlPCaÕJJ|GJPAJÚAlÚGóÚGóPAlPCLByMwCíPGìAö2]õ~ÚGlÖCJÚGLÚCûÚGlÚGlPDA|GlFGL]üAÚGl]IÃPy1AA^",
"water6": "0g0g8l|%Ic%EGRDAÚK;RlËÚGŒeZZR5+?BAÒÖCÃÚGlPCaÕùJ|GJPAJÚAlÚGßÚGóP)lPCLB$.wCíPGìAci]÷Á|GlÖAÂÚGLÚGûÚGlÚGlPDA|GlFGL]üAÚGl]oÃPyPwA^",
"water7": "0g0g8l|%Ic%EGRDAÚK;RlËÚGŒeZZR5+?BAÒÖCÃÚGlP)aÕùJ|GLÖAJÚClÚGRÖGó|GlPCLB$.BAR|GìAci]÷P|GlÖAÁÚGlÚGûÚGlÚGlPDJ|GlFGL]üJÚGl?ÕÃPyPwA^",
"water8": "0g0g6l|%Ic%EGRDAÚK;RZZR5+?BAÑÖCÃÚGl?AaÕùJFGlÚAJ|ClÚGRÖGó|GlPALBwFFAT|GìEAa]LPPGlÖAÁÚGlÚGûÚGlÚGlPCJ|GlFGL]CJÚGl?oÃPAP+JÂ",
"water9": "0g0g7l|%Ic%EGRDAÚGŒeK;RZZR5)?gCÚÖyjÚGlACaÕAúFGlÚCJ|ClÚCòÖGó|GlPALBwMPAT|GìFg^]œPPGlÖAÁÚGlÚGûÚGlÚGlPCJ|GlFGLQCJÚGl?qÃPAPriÂ",
"water10": "0g0g6l|%Ic%EGRDAÚZZRK;R5)k0CÒÖwjÚGlACaÕAÁFGlÚCJ|DlÚCòÚGó|GlPAL?xxPAP|GìFiÂ]IPPGlÖA]ÚGlÚGJÚGlÖGlBCJ|GlFGLPAJÚGl?qÃPAPiiÂ",
"water11": "0g0g7l|%EGRDAÚIc%GŒeZZRK;R4CIÞþr]ùaPAJÎJÂQ/?ÒAJPiPFkJ]JÇPAÎFAJAEP$úØAJlBA>ÑþPBó?ÒAJQJ?PAJPyÇPAJ?AJÙCPBAJÒAòAJPPAJ%GiAJln+I",
"water12": "0g0g7l|%Ic%EGRDAÚZZRGŒeK;R5)ùACÑÚwbÚGl(AaÕÆÁF+lÚCJ|DlÚAóÚGó|GlPkJ?wxPAPPGìFyJPgSFGlÖA]|GlÚGóÚGlÖGlB+JPGLPGLPAJÚGlQAÃPAÁûiÂ",
"water13": "0g0g7l|%Ic%EGRZZRDAÚGŒeK;R5AùACÉúCaòPAckCI689PAJAúÂPkúAJJQóÂPAPkJ?wp^AJ^]dFyJPgS!PAúA]ÂPAJQóJPAóPAB]òPPy^PiPAJúPAAþUPAÁç2Â",
"water14": "0g0g6l|%Ic%EGRDAÚZZRK;R5AùwCSÚEaÖ+lNklÕa89+lÚCú|GLÚAJ|Gó|GlPAJ?y1PGJPGòFyJPiSFGlÚA]|GlÚGJÚGlÖGlB+òP+LPGLPAJÚ+LAAÃPAúþíÂ",
"water15": "0g0g8l|%Ic%EGRGŒeDAÚZZRK;RlËÚ5AùwC_úqaòPAmýAId]cPAJAPJPiúAJÂQóÂPAPAJ?y1^QJP]òFyJPySCPAúAIÂPAJQJJPAóPAB]òPFy^PiPAJúPyAùüPAúgíÂ",
"water16": "0g0g8Ic%EGRl|%DAÚZZRK;RGŒelËÚ0J^900ÑI1ÙGlÂ2lÒ#2ëGlÚJ0ÚGIÙJ_%ET%GlAJPwùëBGPAGSQJPAJy0GlÙJR%GlÚEPÚGlÒGl0GßAþ?%GIAJPÙG?04_AJ]ûCP",
"water17": "0g0g8Ic%EGRZZRl|%DAÚK;RGŒelËÚ0i^dëSXX1JPAÖ3Aï/eÆIAJi0JP9ùJ{NRPCPxAJP0ù1C]PAi]ÑJPAJr0IAùù]NPAJRPJPAJPAwiÉ4axJPxAJPùIx0ë{AJ]_EP",
"water18": "0g0g7Ic%EGRZZRl|%DAÚK;RlËÚ0i^Öë]X61JPAÖ2Ñï/aEPAùë3JP9ùJ{CRPCPxAJP0ù1C]PAi]ÑJPAJr0IAùù]JPAJ]PJPAJPAwiÈ0a9JPxAJ{ùIx0ù{AJ]_(P",
"water19": "0g0g7Ic%EGRZZRl|%DAÚK;RlËÚ0i^Öë]X61JPAÖíÑï!AEPAùë3J]PXJ{CRPCPxAJT0ù1C]PXi]ÑJÑùJr0IAùù]JPAJPAJPAJPAAiÈ0p9JPxAJ{ùI94J{AJ]_NP",
"water20": "0g0g8Ic%EGRZZRl|%DAÚK;RGŒelËÚ0iRÖë]X01JPA9íÑï!AEpAùõ3J]PXù{CRPCPxAJT0ùh6]PùI8ÑJÑùJÆ0IAùJPJPAJPAJPAJPAAiÈKp9JPxXJ{ùI94J{ùJ]_E{",
"water21": "0g0g8EGRIc%ZZRl|%DAÚK;RGŒelËÚ40aÖJ1ëJ]JPA$ëAíEòEPAùs_JP0ë242P02PA009Ñ2?2]4JP0w0Aù094PAù00JPAJPAJPAJPA0]qÑò4JPAë04ùP0w04ù01_E4",
"water22": "0g0g7Ic%EGRZZRl|%DAÚK;RlËÚ4JRÚëSXg1JPA0iÑðEëSIAùë0J>cXù{ð]PCPxAJSKù?AiPJP94JÑùJSwIAùJPJPAJPAJPAJPAC]È4acJPAXJ{ùI94J{ùJ]_N{",
"water23": "0g0g6Ic%EGRZZRl|%DAÚK;R4JRÙ0>Xg1JPA0JÑCEhSIAùë0JjcùùPðP9CPxAùSKù?wiPJ]P42P(ù]wIAùJPJPAJPAJPAJPcJ]R4acNPAXJ{ùI94ù{ùJ]^E{",
"water24": "0g0g6Ic%EGRl|%DAÚZZRK;R4JRSgRÑg1ÚGlwJÉC^ìSGlÙë]ÙJlÙJPÒGI%GIAùÀSùù0GPÚGP409AëPwGlÚJPÚGlÚGlÚGlÚGI%GQ4þ?%GlÑíPÙG?4ù_ÙJ]Jí_",
"water25": "0g0g7Ic%EGRDAÚl|%GŒeZZRK;R4C>0JÐQg2PAJwüÂ@N9XCJ]ùPPiJPi^PAòFAúEJÆKù?0CPPAPA09EëPACJPiÁPAJPAJPAJPAòPA|4üóFAJQí^]CúAùÂPi]G2^",
"water26": "0g0g6Ic%EGRGŒel|%ZZRDAÚ4JR0JsCg9GlÚwJÖy-94lÚCùPGûÚGJPGlPClPAùoKùNcJTGLP06IAë]AlÚGJPGlÚGl|GlÚGlPGL_4a|+lÚC0PGlÖAþ|CJ0ß2P",
"water27": "0g0g5Ic%EGRDAÚl|%ZZR4ü]0JsQg9PAJAüÁC-94CPQëP]JÂPi^PAòAüòAJoKùNcJTBAT06IAë]ACJPkPPAJPkóPAJPAòPA_AüJFAúQ2P]CúAð^Aù0Û2P",
"water28": "0g0g5Ic%EGRDAÚl|%ZZR4üP4JsQJP?AJAüÁC-9ACPAëP]JÂPi^PAPAüòAJ0KùNgiTBAT071Aë]ECJPkÁPAJPióPkJPAòPA]AüJFAúA2P]CúA8^Aù?ÚíP",
"water29": "0g0g7Ic%EGRDAÚZZRK;Rl|%GŒe4üò4JsQJP?AJACÂCóPACPAëP]JÂ?y^]CPAüòAJS0úÆEiTBASCaIAù]PAJPAÁPAJ]J^PAJPAòPAIAüJFAòA2P]CúDÄaAúÕ2íP",
"water30": "0g0g6Ic%EGRDAÚZZRK;Rl|%4üúAJsQCPBAJACJCëPFy9AíP]JJ?y^]CTAkúAJT0aÆEiTBASGaOAù]PAJPAÂPAJ]JPPAJPAúPAòEüJFAòA2^PAJyLawù?0iP",
"water31": "0g0g6Ic%EGRDAÚl|%K;RZZR4üúAù?PyPBAJBAJA0ÂFy1A2P]JJ?y^]CTAiJAJP0þoÞJTBySG7ÆAù]PAJPAJFAJ]JPPAJPAúPAú]üJFAPA2^PAúy?awúÕAiP",
"netherPortal0": "0g0gO]bEÕ{SÝË)Ñ;EK$EQbÚÀrR;aŒëöG-aF;aEUs(ae-XeGIhGáÚ)-aÖ-aESb${bRäéâSaœäÚâÙ{S)aEÆs(Ñ;Sau-Ê$Þ-aEXaGèéâür-K;E)9OÀs(IeGÆ$ÞÙÊSAt-ëaG{bEÆsÞ-aŒùnSèöâùJS;aœc=å;b$ÀbR0gîgÀ3oÞ8oJô(kj<4@]úë]4?Àj1V2KÆElPXi{*ITûA86ÉcßÊ?,ËdNkPApèMkUÁiík9S4yokùèM÷9kS2,lSgBÝUA{Þ[ÊPì?gp9MÒ{1Ë8O?tgQüÁÐéÂëõSiÝÂilÆûæQOÊPJP1ÂÐAeEbbe??B.b$o5s3í9Nt{lc03Ð^AlÒyÃÂTÜkÅ(Ãhl|1Ì9DÂIe1ÊHü5(íI4e",
"netherPortal1": "0g0g.SaœÆsÞÕ{SÙ{SÕ;SÀs(]bEÀbR-aEÝË)QbÚ;aŒÆ$Þcu-èéâõJSÑ;E;aEÀrR{bR{bEK$EUs(ùJSäÚâc&å-aFáÚ)ÙÊSÆs(äéâSb$;aœXaGÊ$ÞÑ;SIeG-aÖ-aE)aEëöâSbÚáË))9OK;E;b$At-IhG-aŒëöG-9dèöâür-XeGünSQbEëaâ0gîgÁísëòEE?)NKTi6oXûx?ÄËðP%caÙÔr%dÌtEcìÆÏöSÑ÷9?%FôògÒ%pÃAiDFŠ{CiúxÏh|oAAIÿAòðqEhwoRCú?EEódÅE&gÏBAE}lLRŒý!?a5reCH6{#M(ÒþEHJïgiÇØe&Eó8ÿO~]Ïôo^wÚRÆSóg<aÜÂôpöUEÚÞDÁýâŠ@ÚeôN5GniiéCøcd^AÞQÛBaõÓI%Cô",
"netherPortal2": "0g0g;;aœUs(K;EÝË)Às(]bEÑ;E-aÖÊ$ÞQbÚ-aE;aŒÙ{SùnSae-äéâ{bRëöGèéâcu-äÚâSbÚõhSëaâ)9OÆ$ÞùJSSb$K$EèöâÆs(-9o-aFÆsÞÕ{S-aŒ-aESaœXeGáÚ)ÀbR{bE;aEünSÕ;SXaGõJSÀrRür-ëaGIeGIhG;b$áË)ëöâüRS)aEQbE)9DÑ;S0gRcT@kß3AC?)M÷;ekkC?t36?ALUcmclL%ðÈ4SrÚIRåÀËwEiB?óg,vAGxòo?CÁiAì?$ìi6ã[cÂd(EÐCrOdaNM4$üC?a?d&4$;ù@ÙCiÓlaÙGÏhgJÀcIRwLdG4Tg4ÂãIks%CQ4dRPçseç$IsÄîåKILjDlxÉT%X&sdAcsÑAùNé!ÙG,]HgÛ}Ó(HôEúÇPi3œËaýrP",
"netherPortal3": "0g0gM;aŒÀrRUs(Æ$ÞèéâSb$SaœÑ;EÊ$Þ]bEáÚ)ùJSK$EAt-Õ;S-aE-aEQbÚäÚâÝË)eêGäéâ;aEÆsÞXeGÆs(-aÖIeGXaG;aœÀs(èöâ{bRÑ;S-aŒëöâÙ{S;b$SbÚ)aEIhG)9OëaâÕ{SIhSëöGÀbR)9DüRS0gîgw3kÎiAÁ^$IJ-s2Q26Süóh*l?Ò?VýV1Ca(L?QXlÑrsÑ0cQ(täIølDíMúÈBcIè*AkÝ0ílL(ùJðCîæ)I0B{EJApCÌêj^pdCïm[?C?dGIåliArÉuU5ANduFCÊÇNV.S@a4@JÇêN?äCì6Euþ6ŒCOCA+$^kú9,u0þjGsasÀ&x.~pCÊèU9mTóEa?0Á{há}Òo?ÈJK",
"netherPortal4": "0g0g+-aÖÀrR]bEUs(õJSÊ$Þ;aE{bR;aŒK;EÀbRQbÚÀs(Ñ;EIeGÆsÞK$Eae-Õ{S-aE{bESb$)9Oäéâèöâc=åáÚ)IhGÝË)Æ$ÞAt-Õ;SùJS-aESbÚÆs()aEür-ëöâáË)QbEüRSèéâ-aFÙ{SXaGSaœäÚâünSIhSëaâ-9o-9dÙÊS0gîgÁñoí^$àd-shP)LVÀiÆglÎãÈ%ÁÉÞlcwÔKk?ñsiøsKÅSEtÁ?ôM0l&i3cßl8Ñ?*Li$?ô5?iRA4)95NÄôUåùAÞPUa5ÚE×&enèzÙxN?öô?áG?ÀÐ4Þ*ôGzQÖÁídÀ7Hi#I?o$1JgßIleItgnIg×9ôaE:Þiriö7b0!ùsîqÕB{T5S&?%ÕõizRgcI_weîäaùÁ>Aql1",
"netherPortal5": "0g0g,-aÖ]bESb$K$EünSÙ{S;aEÀrR;aŒÆs(Às(Us(ÝË)XaGÀbRÆsÞõJS-aEÕ{S-9dèöâáÚ)áË)üRSQbÚÑ;E{bR-aŒ-aEc=åÆ$ÞÊ$Þ-aFSaœ;aœÑ;SIhGëöGäéâ-9oÕ;SëaGIeGëöâ;b$ae-SbÚ{bEäÚâQbE)9OëaâK;EõhS)aE0gîgÁñwí^8i?)?kkX^4kí{glÆVlFíöÒc5ÚiËd5Ì.dcÕ1Ism3Fsq;ßÉÏ0b5Dx46Kc?sårA5CiæglÓC?êP^ÎdJkÞ{yßÐCI!Ï6õdXõxiqEiï;hI6ãecëxÏhRlEeÑD7caëpócHãcÁÁIéEI5Á[ÕåØ4Ä_äc|JgcéœL1ë?Bô?Es_$rÁgwàAëLK0áFëx8í3LÀñ×ŠlbÏC",
"netherPortal6": "0g0g*-aEQbÚ-aÖUs(XaGÝË)]bE-aEÀrRÊ$ÞèöâäéâIhGÕ{SSb$Às(Ñ;ESaœ)9O{bRAt-XeGK$EÆsÞÀbRIeG;b$;aŒeÛåùJSÆ$ÞÆs(-aF;aEK;EëaâSbÚcu-áÚ)Ñ;S{bEëaGÙ{SõJSÕ;S-9oáË)QbEäÚâëöG;aœ-aŒüRS0gîgÀðs0Ioí^$i{)Nø4XhP*bSlÄÊÓlÆsPÖeÊTlÌSN3oDNKìùÇÞûcÎë63î-KÁoÝ8cjcCxðcÔlêl?=@IÈÇûcÒöIŠdX!F!Ei4wOEj|2?IyCg)hE×LIÇGL4?OaeiejûBoJ8Î5ow?ACNäXe75CåŠô55ÿdÐÞAÏ×w*ìGnCÊÎýcON{OJÛ0×eA÷-xcCÙIK88LIðÙÏIQzk",
"netherPortal7": "0g0g,-aÖ;aŒ-aEÀs(XaGÝË)QbÚ;b$Us(K$EÙ{SäéâÀrRëöâÑ;ESb$Æs({bRÆsÞ;aEc=åXeGÕ;SëöGÆ$ÞünSÊ$ÞdÌåür-Õ{S]bE-aEÀbRäÚâ{bESbÚ-aŒSaœae-IeGÑ;SAt-èéâQbEáÚ);aœ-9o-aFèöâÙÊS-9dK;E)9O)aEáË)0gîgÀ60ß1oú^$jd-rù?yÃ0IlBÒjP25MðÈ;ÏaÇIÈ-II5sw?c5XAAQRcN]?÷ACQ3Iq4@-oòóÀic0?wÕLãÕÀxiPá.I44dió?QDE/EI02gåÏmdnEgs^Kni4mlkTð-Ôõì?RèÎÄIk^IÏeTkðrmAcD_;?aEíEXÂ}x?uiÓJJi4giõp?RÿQ}.Nhü3w?NØ(tÆÄh~;ÕÈ;sã",
"netherPortal8": "0g0gO-aE-aFÀrRIhSÝË);aŒ-9oQbÚUs(Saœ]bEK$EÕ{S{bRáÚ)Ñ;E;aEÆ$Þae-äéâÆsÞQbEÙ{SõhSèéâK;E)aEÆs(Sb$ëaGÀbRÀs(SbÚÑ;SeÛGùJSIhGäÚâÕ;SAt-Ê$Þ-aÖèöâ-aEXaG)9OëaâëöâIeGXeG{bE00RcS5oß9Ee4(Ã};á2tj50Aû$Sf$í4FQiUïÿÎAÇgyó1DiÞj?áSõEÂò)ÁikGJs1isCCKIc82ï)lmê1LizøÀAÁ(ÐK16?þÖi*IÃÀCoCnKtSÐÐìLmEh!6Aë0E-ÁögàÍUd%CàoÙÃÛ-goQdAkixhjBuñ?hERgsÝ%i^Cßí<[eiòÐÝàÚCHÐ;æIk27ExÊÀÈlõnÊkàisGl",
"netherPortal9": "0g0gM-aÖ;aE)9O{bRIeGK$E-aE)aESbÚ-aEÙ{SÝË)Us(Ñ;EÑ;SÀrRSaœÆsÞÊ$ÞÕ{S;aŒõJSäÚâÀs(áÚ)QbÚëöâÆ$ÞAt-ùJSÀbRSb$Õ;SõhSÆs(äéâ]bEèéâc=åXaG{bEK;EëöG;b$-9oèöâëaG-aFIhG0gîgÁësëIwCôk3d-shdALoIÄÊLlKl?ÒãøËEA%l^g*uÀûnÑcKïEcÑÔIËSîoì{ù9AÁý?üczÊ7?èÐ?úù?!Ð^&Pn+FNomNKnblûLMþdoüAèI5âDlÀAFdSpÑ3!dRÑ!>?ÓG[eü?^S?$ÄRËù?é!dGIÆê@^ýCiëÁV?ûvB9A{UÔÎGyÀmÜùÓ~]*AxQÇyP3P0øhG1BJøC>B",
"netherPortal10": "0g0g*;aŒSaœ-9o{bEáÚ)K$E-aE)9OSb$QbÚèöâõJSUs(-aÖ]bEÆ$Þ{bRÀrRÑ;Eür-ÝË)Ê$ÞÆs(äéâÕ;SÙ{SõhSëaGëöG-aF;aEÕ{SSbÚÆsÞëöâ-aE)aEäÚâüRSK;EÀs(QbEIeGae-ëaâÙÊS-9d;b$XeGÀbRÑ;SAt-èéâ0gîgÀ6sí@cCi(lõ;rÀQQIpALSSÄËîïAic?ÄÈËeÊÖ1÷âlCBSlÚúÅ-Ee(1ÁáýiQÑcä1ÎòxÅ/Ne2>hBÐnþÖiÂóÎ(id03ŒgÅikiÙ-OL)ÒaäJfayÎ0æcANgwAÚèaòèMÄHîcõûhé3üÁ6ÝCÐë1jü$ÊU0oNEi?ÓmOCSìoù8ÎüáiíJá×0B?}MKwAji4šeÀ0÷hù6õOP.8×",
"netherPortal11": "0g0g*;aŒ-9oQbÚáÚ)K$E-aE-aF)9O]bE-aÖXaGëaG{bRÀrRÑ;EÙ{SÊ$ÞõJSÆs(Us(áË)ÝË)Æ$ÞÕ;S{bEäÚâèöâäéâÆsÞIhG;aESbÚëöâ-aESb$Às(Ñ;SXeGëöGÀbR-aŒeÌå;b$;aœÕ{S)9D)aESaœIeGK;EùnSèéâQbE00RcT@sy98CI8ûc)Nõ)R094~xA?ÁÃÄ0I?ÇýÈÚÿtáIIAÃSéGmF3iaocÝI?49fÇ?dlSNüOÓ(ädklöòi3AÁfcëjPCþCzdh*}<Nl8òù2Ca0!iãhdäÆ?wEAyllU#í;ìil?xX0IhÐ>EMBÆÂLky$hR3HeœQ]AÆõßSÿimxRJüA=;Lkû×w2LL-õaz0liJ!RRhÀxGzR)T(",
"netherPortal12": "0g0g+]bE;aE)9OSb$Ñ;EÙ{S;aŒ-aÖ{bRQbÚ-aEùnSëöâSaœ-aFSbÚUs(ÀrRÀbRáÚ)ÙÊSÊ$ÞùJSÕ;SÆsÞëöGXeGÆ$ÞèéâÕ{SÝË)K;EIeGõJSèöâõhSK$EünSÆs(äÚâXaGQbEAt-{bE-aŒ;b$au-c=å;aœür-äéâÀs(-aE)9D0gîgÁñ8í^we5)?~SShP*61Vÿpë8ÒCSpm0ÚIÌlswX1IsN1eEl÷[CQClUXhEÎÌÙ*]8ÑlXÅÒQyÑsáødRÌåadCúJ0Iroú!VgÑã^No9?4RÎERk%nëeiJGëoE?ÆUíòäñÆsÑ7-(9JScù7EKcî4O?þRÑAjÃhcgÏgÞùhëGE@c$nh5D#@60J62S91$spÞhëÚ8hriL06TVÎ",
"netherPortal13": "0g0g-]bE;aE-aÖSaœÀrRÑ;E-aESbÚ)9O{bEAt-XeGÕ{S-aE-9oQbÚÀbRUs(äéâSb$Æs(Ê$ÞK;EèöâIhGK$EÆsÞ{bRëaGae-)aEèéâür-ùnSÆ$ÞëöâëöG;aŒ-aFäÚâõJSÝË)ùJS-9dÕ;SÀs(Ù{SáÚ)áË)ünS;b$;aœQbEXaG-aŒüRS0gîgÀi8TiAC?)?K;ihhxÃÁUþ<kIPàl41jVð?lDNár7ärR|slðE?ÙO{Mkëa.LgSÉäŠ?CAo2Gœ)lÒ=?ïHþAâ0ë|ri13tg5Ud0q)aÚübeiÀV&r[7MB5kÁ;wh×?ûD?RAi~40KGßÛQStÀÖ[eÇÖãz?0kÂÐÇÉ1:óI?ác3ÒCgÏÒaU:ØSÁER2n0<l|a?þN9~?úixE7ÆiË",
"netherPortal14": "0g0g,ÀrRSaœ;aŒSb$Us(Æs(QbÚ-9o-aE)9OAt-ëöGÊ$Þ;aE-aE]bEÝË)K$E{bRëöâÙ{SÕ{SèöâüRS;b$-aÖÀs(Æ$ÞXaG;aœ-aFXeGc&-ùnSIeGõhS-9dÑ;Eäéâc=å)aESbÚäÚâIhGK;EdÌåáÚ)-aŒÆsÞ{bEau-õJScu-Õ;Sür-0gîgÁñwSIgC?)?Jp4SP)~lll)Ð>ÇÞAÒc?SGÂ?elÞyËäÎñdscè[xpNU?GAAÕckS@ùScÌÇd=óUsCíeEùT4ôErÖc?i1gx1wfT1a-Š~cFÚ8y5ÈORcÓe9s(hûhjj@ýlAs?@-TIRÎÀ]rCÛëð8wùËGM<?ýiIø;FàÙàÂcreÀE4iËrxüÈÖeÐ9ÁÂ;iP.QlXrð<jNwÎîL?+",
"netherPortal15": "0g0gOÀs(;aŒ-aESaœQbÚÀrR-aE-aÖ{bRëöâùnSÆ$Þ-9o]bE;aEÙ{SUs(áÚ){bEÕ{SÑ;EK$EK;Eür-Sb$ÝË)õJSÆsÞIeGèéâ)9OõhSXeG)aEÊ$ÞÀbRèöâXaGÆs(áË)üRSAt-IhGäéâëöGc&åSbÚ-aFÑ;SëaâÕ;S0gîgÁ6c0[wJô(j}gSJTiL|?Ä8Ti?ß2sð1ÒDIU>Êáñì8l@hlIë7Å2jË&Cc9òBÛÖiåówc^ASãj8Sxigj<eÙÞ7X43iÛzIK?oÓ3?sUdk4ÚcÞJâùî4S25>lkàÂa0|T]bsBdGìI?i?)kÅRr]KxLËÃögxLEx?gâ^Ùxë1GRQc]xÈVHlCIR75)hlÏnt;ÄêØXKÄx(STÂÊC",
"netherPortal16": "0g0g+Æ$Þ{bEQbÚSb$Us(QbE-aÖ;aœÊ$Þ;aŒ-aEXeGáÚ))9O)aEäÚâÕ{S]bEÝË){bRÑ;EK$EÆsÞ-aFSbÚùnSÀrRc=åSaœIeGèöâ-aEõJSünSÀbRXaGAt-;aEëaGëöâëöGèéâÀs(Õ;SÙ{SáË)K;Eür-Æs(Ñ;SùJSc&åäéâae-0gîcT@sí^0e1)(÷8sh?AlÁVXE*?%üipC[PEshknåjPEQnKij<-xòsÐT9yüz?wñú.pdC6Ñ×ÄuEU@ßA]ÁCÐ&dIBÏh0iCBg?(G?*Dñ}gxÏÁû^iód)iCli×ÀA@Núx_hèýÝ@dIIy4eUdÖÞúQCJJRíÖŠÙ?ÁABçzwcúhïOÂ5ú?]iAâØ10|ýbq5!ÿAiØLëRdgÿ!CP^Sb",
"netherPortal17": "0g0g/Ù{S{bE]bESb$-aŒ-aEQbÚÊ$Þ-aÖÀrRÝË)Às(-9d-aE;aŒäÚâèöâäéâ{bRÆs(èéâK$EÀbRIhGáÚ)c&åÆsÞSbÚëaG)9O)aEõJSÕ{SëöGëöâùnSIeGünSùJSXaG;aEÆ$ÞõhS-9oUs(ÙÊScu-Ñ;Sür-Õ;SÑ;EK;EIhS-aFáË);b$QbEAt-0gîgw?oß5ACô(Mö-s2BkûÁVíkÐe?Ýökx}ÎJ?Õ+iÞÔ>.)CdñiìEÏ]Ác0Šj-ÓBu9ðkADÎÐnCìùwwËd5lCKcd!I.yiuiC-z÷!KðáK@EL&cóiëcöpCi.kLs(ï8Ýí4c9äoM9z]!@AcÊdCÂ9AÁàLIð_ÃC?d}CõøEnÙ2I?!/G?ol-œU0Cn-CÙemI.}Kal>-lIyi8?èC",
"netherPortal18": "0g0g/ÝË){bR]bEQbÚ-aÖÆ$Þ;aEÕ{S;aŒÀs(áÚ)SbÚ-9o)9OäéâÊ$ÞK$ESb$-aF-aE-aEcu-ÆsÞÙ{SÕ;S{bEëaGÑ;SÀrRùnSèöâXaGSaœëöGIeGèéâõJSAt-ÀbRëöâUs(IhS;b$XeG)aEÑ;E-aŒQbEüRSK;EÆs(ÙÊSIhGõhSùJSc=åünS;aœ0gîgh@cÞIACô(wöw?ô8C~.0íhkúECö{lkFÂ@ÆílKAId6U?ãìÚIó5gnTOLë-ÏÆ8ihIBÌÖicg÷gw?dLPCóëEj!|ùC=A5gM8ËCN)wúkâŒÒ#3ggX99Eëa[=rüxa3hGLÂ1ICû432RÀõÉÇTsBMfcAiÝ?E0ýkGQ0CìEË4IJdbenmë:Í3ÊXwdìÉÏUwei?LpgDkOý83ÒI",
"netherPortal19": "0g0g,áÚ)ÆsÞÆs(]bE-aEQbEUs(;aŒK$ESaœSb$ÝË)Õ{S-aEÀs(Ù{SáË){bEÑ;SÆ$ÞèöâÑ;ESbÚ)aEÊ$Þ{bRäéâüRSK;EÀbR-aÖIeGXaGäÚâëöâÀrRëöGèéâ-9dQbÚõJSAt-;aEünS)9OëaG-aFXeGÕ;SÙÊS;b$-9oõhSc&åcu-0gîgÁñcí^oea)NJss3?yûÁVòAâiKG|)M7ÖeX-LýÝÎaE7ÌddI{-fcOCÄoð@(qßP>tÿO=-_{CCgÓÓCó@-Pl$nEæ.IÄEpÐdX&FIENó<r%÷cDpÂÓAGÛušSUk|D0>EicièÚUÎ4yeîhOVÑciÑlIÕj[{Rí|M&å?A/æAÕißy24sii@ÝENJOgJ6qr7ET_èsúÌÞXu*I3Ðl",
"netherPortal20": "0g0g*IeGÆs(Ñ;S{bR-aESb$Õ{SQbÚÊ$Þ;aEÆ$ÞÆsÞK$E-aFÀrR)9Oèéâ]bEÑ;E;b$Õ;SünS;aŒ-9d-9o{bEäÚâèöâ-aÖáÚ)Às(ÝË)ÀbRäéâëöâUs(K;EëaGëöGXaGõhSùJSSbÚQbEÙ{S-aESaœür-)aEAt-õJSùnSXeG0gîgÁñwÏ[Ee7)jøkÑh5ALUeÄkVI(iÆÇû?ÖeAQLÂPlï?lþ.Túc,?åoxw8Iõdg6ÄútOë4Gn$MOÇAQ@ó}dÎ^ê,9hoïpÃ#)àIEÐA<le^ÖvöÏÛäX~dsÊdbnùCÝlB3ÆñjsGRé$saù[+Lz/Oõ5Òóoìm4aî-hsgiiEáiCi?NI%GicQGRHzsÇCi!KÄ?tnénehÕLQ;%RJì",
"netherPortal21": "0g0gOIeGÙ{SÕ;S{bE-aF;aŒK$EÀs(Ê$ÞÆs({bRÕ{SÆsÞQbÚ;aEK;E]bE-aE-aŒèöâSb$-aÖ-9oSbÚÆ$Þ)9OáÚ)-9dUs(XaGäéâèéâäÚâÀrRÑ;SÀbRXeGëöGùnS-aEür-ÝË)ùJSc&åÑ;Eae-áË)c=åünSIhGõJS0gîgÁñwú^$àd-sh]kLcúT0ï?ÀVÿBíal1dÕ0lËÒsMî^tcJEÏLEDòKîjpLIAhCBsxTñnEkÆßiCmBm÷[^TÁ@wÞUÇ1}þÎö?P?9cQ?4ÁêðoïàÅThiRJX*oôÕEVlCÐkGÊ)LeäG?E1IUÆÎÞ51xÃÀÝýVwOsðhÁ.iñXc$GGdß?ýCiNÞiÜ6RïÀÙsOmkSpdeEùANöSc?eyg",
"netherPortal22": "0g0g*èéâÕ;S]bE)aESb$Ñ;EK$E;aŒÊ$Þ{bRQbÚÕ{SÀs(;aEäéâSbÚAt-Æs(-aE-aEUs(Æ$Þ{bE-aFáÚ);aœ-9dÀrRXaGQbE;b$ÆsÞäÚâõJSXeGèöâÀbR-aÖÙ{S)9OSaœÝË)õhSIeGae-dÌå-aŒünSau-Ñ;SëöâùJSëaG0g2cTRoÎiwJXsedEÃXAcjTkû8CiÁVîEBiKEîÒCaEíÉpItÀïRäSÉèÐwÂmhwìïêE?ÀÎKERk?ÇoFíÒNKaãÞ?ÙúN|Ð[Î2E)ClyýnüwiDchwRøtRÂCGOF?oC?Òuù9sÎíÆù%2úIÁîjüãi9R_kßíBRlqíÉhTL}?^?SïHEíÙÒncûclÂr&IX#sõyl^ÙÊ?AoüAß?ÁGóL?R",
"netherPortal23": "0g0gLXaGäéâõJSÀs(-aE;aŒÕ{SÆ$ÞÙ{SÑ;E]bEK$E;aEäÚâÀrRQbÚÊ$ÞSbÚSb$ÝË)ùJSÆs()aE-aÖ{bE-aFQbE)9O{bRèöâÆsÞUs(áÚ)ëaGK;EáË)-9o-aEür-ae-üRSIhGAt-XeGÕ;SùnSSaœ0gîgÁñwJò$Cõklï<2h-sûÁVÿESK;+p?cKSûlkRA]g^Bl÷%RLlDAR2Is1ýogIæj>t1?<kaèÿiÏOI.OÂ@TÊérJüDL+Ô?ËBOu2ÿËIi}ÞnAdiýInê65eaj|??l/ÍËOÊcGoEzIèñõÒyøèàIpiAEÞÒ$SalI?üILFÅ6ÐñnFOBËða&iÚycóEù÷Sl÷uwwèa}ÆÂN%O~{hr",
"netherPortal24": "0g0gOèöâäéâõJSÆ$Þ-aÖ;aŒÙÊSÑ;EáË)Us(QbÚK;ESb$ëöâÀs(SbÚÀrRÙ{S;aEXeG)9OSaœ]bE-aFÕ;SK$E{bR-aEÆs(Ê$ÞÆsÞXaGèéâÑ;SëöGáÚ)ÝË)-9dür-;b$At-IeGÀbRcu-c=åÕ{SäÚâ{bE-aEüRSëaG0gîgÁñwJô$I{EløF4{-Uú|5lÆciEsn-ciÎþÿVEþlIÌ%SCcýõgImÓ8[ÈxNöüsÝm3?L[lÄAdnÁC5õRPcÄÂóE?õhÒ56ÓXUc5TlXaclörÄú2^ÊDÿeOï/7?ÏëilqP]ÿ!d?#ENó×L4giïS+EöÓþa2aÓSaPcE]idTkbi@PÇ7kÙJAúmÞ$FgÖNCæLîá.bHr3gÇuáúÀã+E",
"netherPortal25": "0g0gNèéâëöGc&åÆsÞ;aESaœÝË)Ù{SÆs({bEäéâÕ;S;aŒSb$]bEùJSÆ$ÞQbÚÕ{S-aE-aFUs(ÀrR-aÖK$EõJSÀs(K;E)aEèöâÊ$ÞäÚâ{bRXaG)9O-aEIeG-9oáÚ)SbÚëaGÑ;Sc=åüRS-aŒXeGùnSëaâÑ;E;aœ0gîgÁñsí^$Id-shAX÷.OiEO5U?ÄMl{wOjK?Åh>õ|1ýFþao??ÝLÁÎlAÇsý4áVëÒ>tCAModVrl×j÷ÎñïNzÁ(*}koJ6>cMk?Õ*Å.ÕïaûdA)hülõÄ?CwæoDDi{g3öUKCÞeÐÐw-*ÿõaœAãatÑh*ÃÃå7úÊAcMkÃÕÓogAJ.lcõ?ÁáÏ?^?CÖÉLÉ5[pn?í×AÍkAIcÈ>5Ã",
"netherPortal26": "0g0g)ëöGXeGae-K$E;aE-aEK;EáÚ)èéâUs(ÀrRXaGÊ$ÞQbÚùnSÑ;S{bR]bEÑ;ESb$Ù{Sèöâ-aE;aŒÀs(ÀbR;b$ÆsÞQbEÆs(äéâÆ$ÞëaG-aÖSaœÕ;SõJSÝË)õhSëöâäÚâ{bE-aF)9O-9oIeG-aŒáË)Õ{SüRSSbÚÙÊS0gîgÁñwJô(Td(?kFkûEÁUUlÿd4ÆÊ@ÈÚhgFiIkQÃllcu2ÌÀl|ïk?÷SnS)É4s?@Ä3AÑÀï)ÅNàaêXPéslËÑÃËSkóAúüáØ*4J+JÙ?rjþLÛÀSjï,ÃM?ÆãÇ>üz4|E^XCÆHÊMb7iIsLloï@ñKÁðJd2ÎM$den|{üÎQeIa5i|+4d1ÀVÃ%hc3Aú?!)ÝýGniåvháeÁIòBeÎ",
"netherPortal27": "0g0gMÕ;Sëaâc&-K$ESb$SaœÙ{Säéâ]bEÆs(IeGÊ$Þ-aEüRSÆ$ÞUs(ÀrR{bE-aFÑ;EÝË)QbÚ-aÖÀs(;aœSbÚ;aŒIhGÆsÞÕ{S)9OK;Ecu-ae-;b${bRäÚâÀbR)aEáÚ);aE-9dÑ;SdÌåXaGXeG-aEëaGünS0gîgÁñsí^$I4cLj;X4?xjÁVXdßIÎÏl-ìe<üQÕQcM+NtQaâDIåVÄê7]V*_XÕXx]K+?Òacc-CBãäjásÏÖÑEc1ùUòýA6ÂõìzhÃ?öUýÀÏcaMlcEId?ÊdIfegQUgeCsù4K%ëájhVLcImõdÃAgLÇÂLd*yaGlV2u@áIEMnUILMrIEdkeÞü;ëj<5ÔHON×èjÑUIÀs?.5Û",
"netherPortal28": "0g0g+Ñ;EäÚâùJSK$E;aŒSb$Æ$ÞÝË)Õ;S]bEXeGÀs(-aÖ;aEau-Ù{SUs({bRQbÚ-aEÕ{S-aEÀbRQbEür-ëaâÀrRXaG-aŒùnSÊ$ÞÆsÞcu-äéâ-aF)aEc=åáÚ){bEÆs(èöâÑ;SK;ESaœIeGõJSëöGõhSAt-áË))9OëöâIhGëaG0gîgÁñwúó$I?s?hSUÂ?Mk0û9<20hUmtáS]QJgÂ?{60ÑsaÀlÂ{Åcplil?cíhsANS8ÞiIÃÐêTLüi]1AJ)RQ(EÁAAòs4caCÔhCõ×ÒÂÀNÐXæqI^ÈSío=âqcN9EçgMx9G?Lhl0hCõkezRN[ü.ÂIùL;èÊiýgAMß?ei=AIgLe*AIL?RÕ(SèùOSGcküdgrüaDcýiIÕúÃ",
"netherPortal29": "0g0g*K;EÝË)õhSÆ$ÞQbESb$Õ{S]bEÑ;SXaGÀs(-9o-aEQbÚäéâcu-ÆsÞ;aE)aEK$E;aŒ-aŒ-aE{bRÙ{SÀbRÀrRUs(-aFÑ;EÆs(IhGèöâùJSüRSÊ$Þür-;b$At-áÚ)Saœ)9OëöGäÚâXeGSbÚùnS-aÖ)9DÕ;Sae-èéâëöâ0gîgÀIoß9Eed-r@Tj[*xÃEVd50>VÑgoâ?tm^ÁD?ÞlN40nëI7$Ãcãm5*úÉòïctOÐúld&VseÏdondáÃ?l?oC.IÙâARMÖR,ùÁl?õáÅdOFEgncma÷+ð4Cnem7gþ3Àl7JßCGã6lRútlÜËŠlKÕdÇái}äkcC>só(ÓilIHòÄRLÀÉIi6nØsÍiVNÊààkær(g@ÛLSdoðt>{",
"netherPortal30": "0g0g,Ê$ÞÙ{SXeGÑ;E]bESb$Æs(äÚâSaœëöâ{bR-aE-aEAt-Õ{S;aŒQbÚ-aÖSbÚK;E;b$èéâëöGÝË)Us(èöâ{bEK$EÀrRùnSüRSáÚ);aœÀs()9O;aE)aEcu-Õ;SõJSáË)ÆsÞae--9oäéâÀbRQbEõhSÆ$ÞëaâëaGIeGIhG-aFXaG0gîgÁñcëIEe48líosalkûF54U5ÿMmeÒDj<nokC?(7ÉÊÓuê4Îò8?2ÇühiiCX{hìÖÐk{e4_DGk5Gm4S4;Sz@aF0>%oT{Dþh;S4Ûo?pX#ÌSÈ$sh1íEUcoÏÝrhïhlAÊ)D1iNÅ<iõKnÑiÝaÜFió?AA?À${lCib!e6dhmnÂùgËQcTFhõ)/1sEs+UÁQ[7lCTEeDœgsb",
"netherPortal31": "0g0g*{bRäéâèéâÕ{SUs(]bEäÚâÆ$Þ;aŒ-aE-aÖAt-ëöâÕ;SèöâÊ$Þ-aESb$)aEÆsÞÀrRëaâÙ{SIeG-aFÝË)ëöGÑ;ESbÚÀs(K;EõJSK$EáÚ);aE{bEQbÚae-ùJSÆs(ëaG-aŒSaœùnS;b$ür-Ñ;S-9ocu-IhGünSIhS)9O0gîgÁ6sëigJë$I}<4??AÃlhUVÒLFì?Õ6lÝdÃÞniTgNXTvÓCz!]òíÃiQXXËJgù2øaþyS8óAgIÒOlXX5wQkEa4ìiÃhqIësKÐCzeRkgR9ÆiOF6IìTÈÒk?;iÌõÄiERaGÔ[gOIx9AtÏL30ûfsúA8ÃìÝEHÈ&ëpaû$NáèT[TUÂ_?aŠ0ùÃ?4XS2F#CX0H3LcÁc.@IÐdg",
"lava0": "0g0g*nIZlÀZneYoîZoÐHnrWiNHJgY?SZ?úHn?WlìWlÞW?2H?eY?ÁW?yY?2YoÃH?iYnrHirH?wYlÎW?(ZnrH?NZTdWrLY?cYJwYJ0Yn?ZneZriYriH?ÀZoOW?ìH?iZoCWoüWr?ZrLZ?(Y?yZikHoGHikHS*YoÐYoîYoàY0gRcTToß1Ay^EJ?)?I;C1MkûÀLTxVÿK6]5DNÁkÆåSwïÔ?CDz0ëÆÏ>ÒÑaAAOÈáî8ù9Ã(IixL^BGP-^0èoÃÆnË%âIÓEJuIIoí11d]Îm÷tSixVõgAòäíLqOAhð5ÖeheÎEVSMhïCwi?~#&tñaMVE(mnJhÍKiIoÏ9h*nCÒ[(üiKàEEcÈMÎýÆî9GùÈEÆ)|k[éKUPlI",
"lava1": "0g0g(?eYlÀZ?SZ?cYoÃH?NZn?ZJ0Y?(Z?úHnIZn?WneY?ìHlÞWlÎW?iYnrW?2HirH?wY?ÀZ?2YSÓHoüWneZ?(YlìWoCWoîZ?yZoîYnrH?cHo>WoàYoÐHnrHnLWriHJgYiNHikHJwYrsZoûZoGHriY0gîgÁìsëìACb(û}$Mø;G1<hÂ%wj9*eUii5Ò?$Oìwà?1TLÚIt0ziwyN$lABsÀAzi8,ù-sa8N^)iÉðEisaBÕNò-gRAGwcSIswídÏRa43CÞI=ë÷^x9ÀjUDENÝwðSÅ0ÕóF{àœgca4S÷^wû8qI<+íArøhhÕ;úíDùSÞÐ>)?o-aR×înGSï.^ÃÕzöPEùEÎXüùÕcC_ògP",
"lava2": "0g0g#?cY?SZ?úH?NZ?2YnIZlÀZJgYlìWn?W?ìHlÞWneYlìHnrHnrHn?Z?iY?ÀZJ0Y?wYlÎW?(YnrWS5WoÃHJwYirHoîY?(ZnLW?eY?yZoNZoCWoàYo>WiNHoûZoGHoÐHoÐY?2H0gRcT@sÎðwúP0Côkzb)?ip4PkRRP*aUIÄ5ãpk2ôP*S1DL%Ip0iIâlúkgUFiÅ8hþáx4UÑv4yv$il!6?{ÐÀÆDiUgËmENtSôÕKT8Ja4ûit)lEhýA.aÆÏüþÁNAÒ?ËpëánÃ|Mdc?vUÒ_ÊMA%V2pEV8E@eùÈ81TÚeïÝr0%ÄI$yTÁMdßE3VdÃáiiAE×0U3SwÈÖ?ïëúí",
"lava3": "0g0gC?úH?SZ?(Z?2Yn?W?cYlÀZ?(YlÞWlÎWnrW?ìHlìWneYnrH?2HnIZJ0Y?wY?eYriY?yZn?ZJwYirHoÃHo>W?iYoàY?NZoÐHoCWr?ZrLYJgYiNHoîYoîZ0gëcT@sí@wRX$h8)e]4?ì4lkkn5pkIB)L95lkÀ0pimlãnBþa0Ð18ÐLEúÿMig0gÂ4lÉ(mh425wi@lOkQðö808ogñ!8~òÝb4ùRM278,Ãòk]kJ9*l{Êji÷)aùJ5Tg08ÏÂ?gÑâáïwÎòÇE10iõpë{{ìðÚk[|3RÎìþäQjwÓy(5ìËgÇ×Äapãh4jcSKX1*î{EÅsxöÚ1ï",
"lava4": "0g0gylìW?(Y?wYlÞWn?WneY?úHlÀZ?SZlÎWnrH?2Y?cYnIZJ0Y?ìH?eYJgYoîYirH?NZ?iY?(Z?yZn?ZoÐYoGHoüWnrW?2HiNHJwYo>WoÐH0gîgÁñwKIACicMî(Mëcc8wIcoCösNë<1ú94XoÑcdiÀpk?t?QoàIÆìnKßhdücoßhwI_dÎfwÎiAhip@|-ß?Æ07wgRÎDi?jicNmAiRxI@Q?S)K9pV38àiåOlÑOiML@ÆMñQNK%rð;ß7lIIkKîxMi)N[Þk]g>m|MNëlgsX?;Î]èOüÄoÅxk?wë3(ë|0Ó4oN2Æì?F2c",
"lava5": "0g0gxlÞW?wYJwYlÎWneY?úH?ìH?cY?SZlÀZ?2Y?NZn?WlìW?2Hn?Z?(Z?(YnIZnrW?iYJ0YJgY?eYirHoÐYnrHoûZoÃH?yZiNHo>WoîY0gîgÁîcÝ8AC?wM|oM?k?kQUï1*cdÀ?kÞþ8Âl)UX*Ï?pÓlxQI)úPTk÷gXm1úIoümQÓ÷AlhwÂ0Akh)CiUXïw2]wgíËgiÇK7kLhAÂ2wI5ÇVðMÞP*[SQúTåOAÝ?@lddSlhÇÀ÷MK|kX9sR?(ÀPxÀl(k8PwP-nÁÎí}á?4xmmoÁkÇUUMstxÓmwúël0Å0UJ02hwëI(Â7",
"lava6": "0g0gvlÀZJwYJgY?úHlÞWlÎWlìWnIZ?SZ?iYo>Wn?W?(Y?cY?eY?2Y?(ZnrW?NZ?2HJ0Y?wYneYn?Z?ìHirHoÐHiNHnrH?yZoüW0Q1ùïM?ëB_KqÏ0öàK0ai4ÒNÂcePTpÓwlÞIowe]@ix@Ä5eØ3RoÑh#SJRSE4dëS×yEÛc6Q1cKXxO&gìÓnlìwAtil4)eC3LÆkâNiâdCAU]dÐe4çaC×!1gGçEIÀño8ðõBJ@??dçVÕ7yoI1À;ÜèAby0(RU%1eLlg0bîne",
"lava7": "0g0gw?SZJgYlÞWlÀZlÎW?úHn?W?ìH?yZoÐYnrW?cYlìWneYn?Z?iY?(YoÃHJ0Y?wYnrHirHnIZJwY?eY?(Z?NZ?2HiNH?2YoÐHoGH0R10ÑF÷0x!8mIëöàl0ùC2CR^ØNIFcCpÖ?X2wØÇ?Coþ]4G<IxiNKRÀî6?ñùmN0>w+?ù](2SAÒzoIGTØkGGohNCcEËÚcïu(9àOAhlcpGSnGXCÂiÐiÛ6lDlcA]@å?3Iy÷ø/LAÁéÖðcF~aUCÓts6ÅoiTNBI$Çõpwi$8d",
"lava8": "0g0gy?(ZJgYJ0Y?(Y?SZJwYlÞW?cY?2H?úH?NZoîZnrWirH?eYlìWlÀZn?ZnrH?iY?wY?ìHn?WoÐYo>WneYlÎWoÃH?2YiNH?yZnIZoÐHriY0gîgÁ6síQ0C?)3øc)hPML8?QÁÒ?;lp]Þd8T10ül-ggSj|4ãìgÎicxñogöTeüp0|8NÁÀl5gù>0z|ÀJ[8B0g0í4zRÖi~kwm(ü18(RSþX4x[ÙCÀ4igSRLâl@äGidkkgãh0zÀoB4è(QÕsÃìKLkziEJQÕ0V%eü8xAèJn4zTAúî8kchÕÃÀgüÖ2À0gðk[i8S4p6ùB0v",
"lava9": "0g0gA?wYJ0YirHJwY?(YlÞWneY?yZ?úH?SZo>WoCWnrWiNHlìWJgYn?W?iY?cYoîZoÃH?ìHnIZ?NZ?(ZlÀZlÎWnrH?eYoîY?2YoÐHoûZoGHoàYr?Z0gîcx5oß90C?)T÷;NÀQáî4TQ<4LUrmQëd8(|cïlÆroAj|<ÄdAÁïgC]ÑgíB@ìlù|4RÄ;wìBÀ~0j|;ÄI4wîÑ>R;wíB6È0gr?C~8rTÑðo4gsâQp96IÒÅ0)ka?i4<ÔòBIlAj~AwoÆ0ÆÒCaëIf;ihEíoAg]ðx>4hUÝoÄ;wøwðQ8wÂ;Õ?;gQlJpcgÇ5ïò*ð9.Dòwúm",
"lava10": "0g0gyJgYJ0YirY?(Z?ÀZlìHnrWlÞWN2WoÐW?eYiNHJwY?IYnnZ?SZ?cY?RZ?yYlÎW?cHirH?wYNiH?úHlúH??Z?RYNyHn?Z?NY?ÂZoàWocY0gë00ikÎicí^$IQ40J-ÎI0I?54Â{jk-à240VMMðkgcÆgý5O2cTQ(gl;gídÞcg(S4ho0wìÇ(m0lR4S?0gëchT4wíÇSic0dÕÝh8gTd(c407Úi39>>gÞh8g>áÂõ4Ã><ñódK0Æ5õÑ0ÄhNIèkI4knx)?cgÃì?h4hsÒ-p4wìt(?4g?0ÆË4g{g)I(hf5Ò38(I{rIsSp",
"lava11": "0g0guJgYJ0YirY?wY?ÀZlÎWlìHn?ZlÞWnnZ?RY?úHirH?IY??Z?(ZlúHNyHN2HJwY?SZnrW?cY?cH?eYNiH?NYN2W?RZoîH0Q0cïMkíc_KcSõöÞkTìNczy5ŒßCgX$åÊ?4jo4hùÎxgS5OCQxLGzh(4ô0XhùkAÆg=þä4n?j8XFao#IèlNgSnüj80õL3k(rx0g0sa0aMRÏ,cF.öNS2NCIlC04edP/0BUC04aìäëIxFu0ë82/kXOciSHf3rR=øzNsiÓ",
"lava12": "0g0gpJgYJ0YJwY?SZlÎWlÞW?IYlúH??ZN2HlìHirH?(ZnrW?úH?wYirY?ÀZ?eYn?Z?cH?cYNiHNyHoÂZ0RwcXFóßc!Æa(EIMóÄ1ë1È?ì÷MÌgX(õÒy42ä30INA_g5RIÎ7?Cz5h6&4whd?kwg(ÓôNnòœc30lï$Sæhë806Q23h@?eìÕiüë8ëiCS9tiaDò]RNwEwiEð^y00ýQÏEIMeÆ02%áÛÀXxAÌ08?1Þw42ryRúœ3E(i$ôo/g?",
"lava13": "0g0gnJgYJ0YJwYlÎWlÞW?eY?úHn?ZirH?(Z?cYlúH?ÀZ?wY?IY?SZirYlìHnnZ??ZnrW?cH?NY0Rwcîx]Ãk?S8ùCñÁ]G1C1sáìŒÁq0XxrcÓ42Õ30hez8r4{KÎ1/MqÈ@ïo4whBAÙw0*ryKmòLc30dCÁ0]ew844Hy2S.üíìmsQKaQû$Cbyi^Xqþù(KoKALic?01ôàNC)$ûJ01ûOE(XxÐi0BC1%À42_ÂChF3ohEÖÏÈiùQ",
"lava14": "0g0gmJgYJ0Y?wYJwYlÞWlìH?cHn?Z?IY?eYlÎWirY?(Z?SZlúH?úH?cY?ÀZN2WnrWnnZN2H0RxùCxIáp!Æ8hgIåò50K2Cì2&åo(4xz]@X2Kigeõ$Uk0ÚIÄhIrÃoÄ1DoÄgMeiL0aN$Rh÷!aig?ùT@R*î841(z3[o<SÈól/wbQigwb]djóÁkhgëIÄIxjTL02AOo*(%Q4MíE)ÁgXxô61gXp!N03K?*<Es|gÐöô5kg×",
"lava15": "0g0goJgYJ0Y?wYJwYlìH?úHlÞWlúHN2WnnZ?ÀZirY?cH??Z?SZ?eY?(ZlÎW?cY?IYNyHnrWN2Hn?Z0RxùDM?XùóÆ{(dòxcl003õRìQxCw5Î)zh$2ëhgóe#üN0gIÄguÃ(cE2coÄgd~iL(dUÑRg2CaighÃe6cSR841hw2ðCphÉõoýT2CztNckÖÈo*JNoëëÄOGiý?0dÁA4OS(.6Mì?Ïa0XxÝë1E6kÂK03ë43|ÀióCojá6DAa",
"lava16": "0g0gpJgYJ0Y?(ZJwY?cH?eYlÞW?yYN2HlÎWirY?ÀZ?IYnrWlìH?úHlúH?wY?SZ?cYn?Z?RYNyHNiHnnZ0RxùDMõápyÀ{0eöMõl4x0Jr1&MXwFTXÅwEhkSgõ_Aþw02]Ugpö)ÑI0QIUg1)iýg1âÎíg0iaíg÷)e7x@M84MISq[ACTÀJGJT2?lhC8?Ótí*ÛE<nIVC)Iãc0eÂ)@O]M^S-÷}AJgXxghoD@óÆK0Ðg07ÁMiÌùqiüSAgb",
"lava17": "0g0gvJgYJ0Y?(ZJwY?IYlÞWlÎW?ÂZ?yY?ÀZ?wYirY??ZnrWNiH?úHlìH?cY?SZ?cHirHoÂZnnZlúH?RZ?eYn?Z?RYoàWN2HN2W0RxùïM^áA^Æ{0aöMóOXx0I0ëcMQw%KIiCEagëgë@ACwc!(mgp÷!JLëÃÀÄgëel2w1*eRg2nailì|IðBdR84(2ëp@AiÎÆLûQT1ÂdWwÆkËÜzñ(Kox2oaáE%C0ER(0NCzkëMe?óÂ0X#g2hlBiÌK0ÐÀ0nsEhCKTriëÓi2",
"lava18": "0g0gvJgYJ0Y?(Z?wYn?ZnnZlìHlÎWlÞWoàH?ÂZ?SZnrW?ÀZ?NY?eYirYJwYirH?IY?RYN2H?cHNyHN2WlúH?cYoàW?úHoÂZoûY0RxùD.ký$08}gcõØÀOð10SI18×mGi0A08]3gë0ë]wXwiM-wg$GQ~ÃëÄgKgïnkíEïdi>02Lc2pR*Ny02y8m(2SqyMixëqL;Î2rhÞnëSÓãhOGÝjÎcALÊ?Ø.oõSÕ3sAw0hMdÔç@gXgoRhwojÀk0ÞoRtËhi-Ýà|kSæ?2",
"lava19": "0g0gyJgYJ0Y?(Z?wYnrWlúHlÎW?ÀZlÞWoûYoàHirHirYN2W?SZoÂZ?IYJwY??ZiNHlìHoÐW?NY?cH?RYoûHNyH?eY?úHN2HoàWoiWnnZ?RZ0gRcT5oß9ENI4Iì4î|-?fSiI0I6$28-îñQe0]0{{E38AS4gügwí4(Sw314Mlxhþo0l8j14Io8E}Qh?ÖÝ{46k4hT|)ÈÒCT(kR41I0khdQÁ4jc(gñx4TQÁú1iI(E?ân{Ër]64ì(EIâìë8??Qwì8gÁÝKS$g>8O÷ÙÝ{4gcQj1.TI8ni00?Qj1Rlh-ñ8?á79g]Öwh",
"seaLantern0": "0g0g_ÂDYÂnYÈ,ZÂnHÂDZÈDZÄDZÌEWÈ-WÄDY}nHßGW÷šZðoZeÊYe$WIéYIÚHe;HeÊZûbHãgZ÷TWIéHlöZlCWlaZKöYJTW}7HKöZnEWnEH?EHlCW?öYPSWe$WneZnaYlöYgÊZe{YOEHOHH?EW?eZe;H^7HIöY?HWÄEW?HHYËWneY^7WlaZlEWlEHJTHIËWIÚHßgZ÷oZlöZlaZYÚWPSHãdZíiHðLYe{HãGWÂnZ}nY048wÎ01ag8KK>IiEÆIcñùy]úNïSó6Ueà6cANÕ?eÔaî/Ýg?[kxRXšzÕjAcüIC9ûC{a.S!kagÐ?sIýEÈeNÑ6òt6]?s?mxReÏ?6ÿEci?s?geÈïJÑCôXÓõLk?ÀDÈ?J?CAX2C?s?mcReÏá6P0eüRsIþ$ÈeEÑ67,ÓPrñFûCÊaMS@ò(2RnàDkc=ëš3f_A/ŠŠmCöS*29Ð}iI/6zGeñnwD/JL01JúzÞ|?>ÛâwgöI^",
"seaLantern1": "0g0g^ÂDZÂnY}nHÈ,ZÂnHÂDY}7HÈDZÄDY}nYÌ-WãGW÷TWðoYeÊZe$WIéYIÚWe;HeÊYûbHßdZIéHlöYlöZlaZlöZKöYþTWãgZIéHKöZnaYneYlCW?öYJTWPSWÄDZe$WlaZneZ?eZgÊYÈ-WlaYlaYOHH?EHe;Y?EW?HHÂnZOEHÄEWlaZIËWgÙZ^7HnaHlEHIÊZ?éYlCHIÚHIöYPSHJTHíiYðiHe{YgÊZe{H^7W04g(ìSðekwëí?3ggÆIcñùy]úNïSX8$ÎÏocA)ÑIeÔeí4(RSEgwRì2zÕLB{aTüaV!Âc^3@lðÆP×O^ÿEKIaciP98iiý$ÿeÓhæC6PBÕSi5#?!RlíüafCÙöGl|ÆxRIæü6Ê1ÕOG5{qEKhíC6P1kAš5!ÆLKIÂýi7/{PpýiùdÂdÃgðP/2MŒ?#ùwÊìàSg6Bc%A8C{aNÑIJzeickÊ-úÐgxuRGíiD{ý!ÀÂËB^p#QLS2",
"seaLantern2": "0g0gUÄDZÂnHÂnYÈ,ZÂDZÈDZãGWJšZðoZeÊYe$WIéYIÚWe{Ye;He{YûbHãgZ}nHÂ7H÷šZIéHlöZlöHlaYlöYlöYlaHKöYlöYþTWßdZJTWIöYKöZnEWlaZnaZneZlaH?öYPSW?EH?EWgÊY^7WÈ-We;HlöWOEHlaYe;W}7H?HHneYnaYÈEW?öZYËWgÙZOHHÌ-We$WlöH?eZlaZe;H}nYIËW?éYnCWIÚHãGH÷ŒW÷TWPSH}7YÂDYJTHðLHíiYgÊZe{H^7H04g(x21ag80wRî08(Þ2?bo)Ýr4TiCocÂI?oNÕ?IdøìAìaz8LB@öNàEgF0EeX×ýeÄeÈO7m%Êhí*×l!UIÈGÙaG2.JgÚÆGÙIÂÑÓ@e0%J*×l!UnÈGÓaëÝOJV×a!U?EGÓt44RJ*×ýNÛRÂGDníæŠš*×N;UdÈGcie0.>AEleÄeÊ4EÎ%ðíAÃa?cõöÈ]MiFÖy{G$õoÑiHorI?a))Os7ýn@ùü1ì00c^J_ÖdDP]0óT>",
"seaLantern3": "0g0g|ÂDZÂnY}nHÈ-WÂ7HÂDY}nYÄDZÂnHÄDYÈDZãGWJoZðoZgÊYe;W?éHIÚWe{HeÊYûbHÂ7W÷TWIéYlöYlaZKöHlaZJTWIöYKöYnCWnEW?EWlöYIéHPsZ^7HÈ,Zg{YlaYneYnaYneZe;H}7Hg{H?HHlöZe{Y^7WOHH?EHÄEW?öHgÙZlaZÌ-We$WgÊZe;He;WJTHIËWlCWIÚHPSHIÚW?öY÷ŒWãgZðLYIéWgÙYæGWPSWÂnZ04g(ìRðe0Sùë?aiwÆIcñùy]úNíhí!$eà6{aNÑIcÔ5IgÀO?DkwRì1ü]jAe<hüEÀcRïa3CñB{aTsEÀdUïÈGCÄ%2gTs#lwRcak$oEeSi4!ùxÓ?^k6]7×?i5×ùLÕïÂk6]ë2nIQEUc=dak6[ëßorkEÀEUïÈkctcer?üEÀcReÈG6ÌE2ŠŠ3EÀCRì43(_RÈ$G-ð{GNKiIM?iÈ6Oo?7+úBàeJë93%zBEc_þaÊhrIe",
"seaLantern4": "0g0g^ÂDZÂnY}nYÈ,ZÂnHÈDZÄDZ}nHÌ-WÄDYãgZ÷oZóoZeÊYe$WIéHIÚWe;He{YJTHãdZãGW÷TWlöZlaZKöYJTW?öYlCWnCWnEWPSWe$WKöZlöY?eZnaYlöZgÊY^7HÈ-We{YlaYnaZneY?EH?EWlaZe;He;HOHHe;YIéY?HHIËWÂDYgÙZneZlaHnaHlöYgÊZnEHlEWIÚHÂ7H÷ŒWIöYPSH}7HðLY^7WPsZÄnY04g(ë0ìa08Kìi3igÀeî[fwQòyÒ0XeUEroco(KIûCï78Õ?à7ea/áRîCJvcìazIúC]öp?DÃDÀcÁIØm%Êúy?ô?72IåOôn%ÑgÏOipdc?åLôÄeÈg×Iiq6cÚÁ?ôÈEÈGrIir,cnÁl&þEÈgLOi8ìg-IIEneÊRqOeudcQLSôAEÆOqOi8d2ÖESfjE;äOIgbvíÄk8Óco(ÎnðiïQó0Á-?òfuS]lRaìcèŠse?c=uQùIhí",
"prismarine0": "0g0g5ÌaH@DHa#ZæLYR6Y5({ÕIagiú|Aoí)Ic?8^m0wDAÙRSïE^KmAwkaëebÓ)?iiÈ}6R5Cj0új9í?5F0$8SFín(Qi$2ûÓC?Ñih2(zPþ00þ4{NcúÐ1X1i",
"prismarine1": "0g0g5ÌAZ&lHa#Zæ?HB?Y5({ÕIagiú|Aoí)Ic?8^m0wDAÙRSïE^KmAwkaëebÓ)?iiÈ}6R5Cj0új9í?5F0$8SFín(Qi$2ûÓC?Ñih2(zPþ00þ4{NcúÐ1X1i",
"prismarine2": "0g0g5ÌqHÖIHa#Zæ?HÇAY5({ÕIagiú|Aoí)Ic?8^m0wDAÙRSïE^KmAwkaëebÓ)?iiÈ}6R5Cj0új9í?5F0$8SFín(Qi$2ûÓC?Ñih2(zPþ00þ4{NcúÐ1X1i",
"prismarine3": "0g0g5ÌæH}qWa#ZæLY?OH5({ÕIagiú|Aoí)Ic?8^m0wDAÙRSïE^KmAwkaëebÓ)?iiÈ}6R5Cj0új9í?5F0$8SFín(Qi$2ûÓC?Ñih2(zPþ00þ4{NcúÐ1X1i",
"stonecutterSaw0": "0g0g7000lÚYZZZEEYŒEYí8WÞIW00000000000000000000000000000000000000000000000000000000ÃPë00mò?y00C^MAh1JÁòyë5oõPiI8ü_EüÆcCÛLCÀ",
"stonecutterSaw1": "0g0g7000EEYZZZlÚYŒEYí8WÞIW00000000000000000000000000000000000000000000000000000000ÂFë00)a|m00DLÖAh1,jP@Sd+A^+A5G?ÞGk9DrlDi",
"stonecutterSaw2": "0g0g7000lÚYEEYZZZŒEYí8WÞIW00000000000000000000000000000000000000000000000000000000ÃÕë00CIÒG00E_%GS1JÇÚih9J?Ûikcþ^(þÆcEÛLEÆ",
fire: "0g0g=000ggWe0WgwWgSWgwWhÀWIëWICWg(WhKWJhHJkHICWIùWIEW?rHLwYL(ZIKWIÝWJNHLÁWoEHNÞYIëWL0YLSZ?EH?CW?úZSÄZZrZRkYLTWIEHNÎHo?Wo?HSaZSÄHSäWR*HSaHŒ4WLgYo?WLwZZrWZZZNìYŒ3ZSÔWoSYSÄYT?ZRAZLgYhSWT?YZnYoiY0000000000000000000000000000000000000000gS0024g00000M18gR0000000ÁñwKS00000IEec(kS00003ö<4ÂSkh0000Ce|>VÇãfE001þö<gtåsxòÒ00A?åIÓCó×E?S0gþherIsCaÒ01>÷h{RI||ÀãS1h2Á|eIsÉAg00tÞSÓenpäIuæ3sçUÿ;wchIìh",
"fire0": "0g0g=000ggWe0WgwWgSWgwWhÀWIëWICWg(WhKWJhHJkHICWIùWIEW?rHLwYL(ZIKWIÝWJNHLÁWoEHNÞYIëWL0YLSZ?EH?CW?úZSÄZZrZRkYLTWIEHNÎHo?Wo?HSaZSÄHSäWR*HSaHŒ4WLgYo?WLwZZrWZZZNìYŒ3ZSÔWoSYSÄYT?ZRAZLgYhSWT?YZnYoiY0000000000000000000000000000000000000000gS0024g00000M18gR0000000ÁñwKS00000IEec(kS00003ö<4ÂSkh0000Ce|>VÇãfE001þö<gtåsxòÒ00A?åIÓCó×E?S0gþherIsCaÒ01>÷h{RI||ÀãS1h2Á|eIsÉAg00tÞSÓenpäIuæ3sçUÿ;wchIìh",
"fire1": "0g0g/000e0WggWgwWhSWhKWgwWg(WIëWIùWIKWhÀWIÝWIEWJkHJNHIëWL0YLSZLTWo?WR*Y?úZ?rHLgYL(ZLÁWNìYRkYoSYRkHolWŒ4W?ìYLgYSÔWZZZZZHLÎW?EHRAZgSWS@WIEHTgYoiYoLZSIZSÄYJhHR*HICWL(Z?CWNÞHIhHICWZZW0000000000000000000000000000000000000000gë0000000000gikK000000TsíPAC000002?(lø)hS0000ÏïgGd?A^o000>{wsJ|?ÄÊnë0AoÒDLÞlcíjS0ðCÊsÐJÇJÈyh0E8sd?JïòEc00khCÐAJPhog00óCEgœE_ÛJcS2Š(iãE)?Lhc03<*LPANCAú&Ñ",
"fire2": "0g0g.000e0WggWgwWgSWhÀWhKWg(WhSWIÝWIùWICWIëWIëWIhHJNHICW?rHL0YNÞH?CWLwZL(ZLSZ?EHNìY?úZLwYIKWJkHIEHoSHZZZSÔWL(ZLgYLTWgwWNÎHT?Zo?WLÁWTEWRAZSÔHSaWTEHS@WoiYSaZo?HŒ4WLÎWSaHSGZTGZNÎW00000000000000000000000000000000000000000Rcg00000004T@kÝ000000ñwJô(S000001IsÞö-s70000y?ke?P*l$ù001}<BÿÁ@pÖg00QË.?níocùŠS0MðsÇCCó|kÀë0KëcÄwíaa8000Äe)>œGoahd03cßRUE-JOJÁS0?sÌ8w.iCì×Sq6ãNœL?8rálT",
"fire3": "0g0g/000ggWgwWg(WgwWe0Wg0WgSWhKWIKWhÀWIëWIùWICWIEWIhHLgYL(ZJkHIëWJNHL0YLTWLÁWLwZJhHNìYSÔYo?HLgY?rHICWLwYZnHS@H?úZIÝWhSWErWNÎHZZZSaHoSZRkYSÄYSÄHNÞY?cZT?WSGYZrHR*HŒ3ZLSZŒ4HRAZZZWNÞH0000000000000000000000000000000000000000gîgÀ00000068ß9Eg000001T4xi$i500000igû}<4ÂwS000l)SlÇâ?Îùë0j|(ILÚIÌVRS0ÁI8äxó,Ñü(00FëkåoCAök000ADE)eE??öÀë1qE$Ad<OwhNh0ñCÅaE/URIÄd6ïNjJ*Ìów;IhbÑgCóEcê.Ch0",
"fire4": "0g0gM000e0WggWg(WgwWhÀWIKWIÝWIùWIhHJkHIëWhSWIëWICW?rHL0YLgYJNHhKWL(ZoLZNìYJhHgwWRBWo?WLÁWLwYSIYZZZRkYIEWoiYŒ4WoSYLgYICWNÞHLSZgSWZRZRkHoSZTEHSÔYSäWolWNÎH00000000000000000000000000000T4000000000wIg000000000h3kÁ000000T4MñwJôg0000{olò<4ÂEÝ004ioßkVÑòÊÝ001o8)aÖEïcw00000[tåSñ00008ic]xó*fJÀ00aA{FÑëàÂC0S2íÂ!DdwMýÒAw2dCðgUÁŒgëEh1ÏCåOCæeÉäE0æ?LåOCÓ.CAcd",
"fire5": "0g0g*000e0WggWgwWg(WhSWhÀWIëWIëWgSWIÝWIEWIhHICWJNHLÎWLwZIùW?CWNìYLgYŒ3ZSIZ?EHLwYhKWNÞYoiY?rHL0YJkHICWSaHRkYLÁW?úZNÎHSIYoSYLgYoLZZZZo?WoSZL(ZSäWo?HoEHZrYR*WNÞHZZHTEY00000000000000000000000000000R40000000000Rc(00000000x5oß9000003gÏI$IdwS000IAÂ÷<2?QÀ000R4zÂ|>Pcg00000zýÇã600006]8kÈÚDb$K00dÌAi÷)Cô-Ý00A_éÐxEMCõeQ2DüúELãÇ÷ècë2àEDAÖDEœgù0D?ÜiAÖitdòníd/ÓAAÏAÐGÎoS",
"fire6": "0g0gM000e0WggWg(WhSWg0WgwWgSWhÀWIÝWIëWIKWICWL0YJkHhKWL(ZIëWgwWErW?ìYoSYLÁWNÞHIhHIEWIùWICWoLZNìY?rHLwZJhHLgYJNHoiYZZZ?úZoEHSaWTGZRkHSòWSGY?CWNÎHRkYSIZLTW00000000000000000000000000000040000000000RcT2000000kÎiACôgg0002oÎc)?ô;K00000iÀS?Â4000001OkVÐî00001ñ02ÀËÓ9$w01C^82pÕeiÙS002?Alt;wNéi026jïÒC/*?Qëh1ûtJPAJÇ|AS0aãcCPAclCèJSJEœßP%äIEïEhH.Aûct5oaÑDS",
"fire7": "0g0g%000e0WggWgwWhSWhÀWg(WErWgwWIÝWIEWIùWgSWJNHICWLwZNÞYL0Y?rHL(ZLgYhKWIëWIKWLSZLgYJkHJhHIhHIëWZZZSGYLÁWNÎHSÔHo?HZrYZnWRkHo?W?CWLTWLwYSÔYSÄZ0000000000000000000000000000004wë0000000gîgÁ@800000si9Ee{o0000001|)nR00000002~Tii00000101Â|Ric0005Qs1þAÃ5Êw0035gDp(iaÕÀë1â?ÚmÊ.)ËUKS1âAåOCê6q;ë0ïlCòOC÷3?]ÀhþÖNcOc)ÄÐ)ùëCñCæül8ÂE%VSFENå(Io3t&IN",
"fire8": "0g0gO000e0WggWgwWgSWIÝWhKWg(WIùWICWhSWJkHLgYIhHIEH?rHIKWhÀWgwWIëWJhHIEW?rYZZZZZYo?WLgYICWLwYRkHTnW?CWRkYoEHNÞHNìYT?HLÁWLTWL0YNÞYTEYTgHLSZJNHSÄYL(ZoiYŒ4WLÎWZnY0000000000000000000000000000018(I00000000QkÎI40000000iAÁh00000002ô(?ë00000001j;G340000i00úoQñs0000îcÂJ]0?{(00Mi{Lil?@gw00áÄËïlÒcI)g0ÚUsââNèIN)Ý0ïsAöåBÁlÓ)C0CóÅEgf8R$kSh?_ÅÌNí80ilTrËSÞGAU}(ì@?I",
"fire9": "0g0gO000e0WggWg(WhÀWIKWgSWgwWIùWIhHIëWIëWIEWErWIÝWhSWIEHRBWS?ZSäWR*YNÎHJkHgwWhKW?NHoiYSIYTgYSÄZJNHJhHNìY?rHL(ZLgYLÁWSGZSÄYL0YLSZZZZLwZICWRAZLwYLgYLTWoSH?CWSaW0000000000000000000g0000000002c(ë00000000QkKë00000001iACh00000000ô(ìì000000003oÝí400001)Nj803;g000îgE5;?îsk000k?ALVÐe-00Ëî?ÖgtVON$g0ðENJÇC(RDwÝ0yXdAdI8ÞØgÝ08?FDkì40ði?E×SlI>jigSpOëC;ËÈ3IIÃDIÞd",
"fire10": "0g0gL000ggWe0WgwWg(WhÀWIëWIKWhSWgSWgwWhKWNìY?CWoLZ?cZL0YIùWIÝWIEWNÞHRkHS?Zo?HLwZJkHIhHIEHLwYŒ3ZoSYLgY?rHZZZJNHICWo?WLÁWoiYIëWICWLTWJhH?úZSÄYo?WL(Z0000000000000000004w0000000003gg000000000ïoÀë000000005oÝS000000001cg00000000y9001400002EÂIcú180000@(løTkòA000NûÁVÿÎ)Àk00tþaÞlcQüasw0i3cå8c8iÂgw01pxï0S003hDñí4OAÎ9!Ý0!XS}!Ódi>a2ŒÝM04laè_xGcaGmS",
"fire11": "0g0gL000e0WggWgwWhSWgwWhÀWg(WErWL0YL(ZLTWLwYIEWhKWgSWg0WIëW?CWoLZNìYJNHIKWIëWIùW?rH?úZIÝWNÞHZZZIhHTEYICWLSZLÁWIEHJkHLwZNÞYo?HICWZrZRBWRAZRkHSÔYSÔW000000000000000001800000000003gÀ0000000003oÝ000000000840000000000í0000000004Ái4wS000004AC?)?I80004hMALVlös005áÆÒCaÙÞÿ;000ltÖÅa4hQ8001GcâÀë0019gìÆ?xÂxR4r09gëgLÏ÷SiülIäwS0döùån]àABL0c,×EaœãlËãra",
"fire12": "0g0gM000e0WggWErWgwWICWJkHJNHIhHIÝWg(WhÀWLÁWNÎHL(ZIEWgSWIKWhKWLTWLgYSÔWLSZICWR*HTgWIùWLwYL0YIëWIEHNìYZZZgwWZrW?EHoiYoLZŒ3ZoSZTEWLwZolWRkY?rHSIZŒ4WZZHR*Y0000000000000000018(0000000001gw000000000000000000000000000000000S000000002kÎiACë00000boI};Gh40012Lx)i]Rô8000ýlÆï?00Q0000eoÑëS0000c04þaMhë0g012ë5LsËÝìåhqAg00ÓLÊdNNkhqASösAédÓíäwCAe2?KGSÑî4lM-w",
"fire13": "0g0g%000e0WhÀWIëWIùWIÝWg(WgwW?rHLgYJNHggWgwWgSWL0YJhH?CWICWoiYŒ4WhSWLgYIhHIëWIKWJkHLwYZZZo?WLwZS@HLÁWNìYoLZ?úZSÔHTEWNÎWRkYoEHRBWL(ZL(ZSaYRAZ0000000000000000004000000000000000000000000000000000000000000008M5og0000007gí^kÏI0000jdg?X)i?0000lkxh|0010000ÐJ{SS0000g01T]Ur00000ES1TmÊÀSKKRo000@?kia-ed?IëFlcU-xÛE?{OÈ1aaCïOÛóVEþl1ücÈ6ŒEilÚGl",
"fire14": "0g0gL000gwWgSWhSWg(We0WhKWIEWIhHIùWggWIÝWIëWLwYhÀWJhHLÁWNìYJNHIKWJkHTgYL(Z?CWL0Y?úZSÄY?EHo?H?ìY?rHSGYNÎHIëWZZZoSYLgYLwZSÓZSIZL(Z?cZT?ZTgWT?HSäWŒ3Z0000000000000000000000000000000000000000000000000004wik00000005oß9cC500000aoíb4050000cdseì0000000ÃkQE00000000hø]ù00000000hò{(04Àak000?}cclwÁT|ÎS.??x*aÖÓNâ[ô0ânìAÇó.oÏ]C0ABy8D÷-CóECCFouAEægÙGEE",
"fire15": "0g0g(000e0WggWg(WIÝWIëWhKWgwWIëWIùWhÀWhSWIEHL0YLgYgSWICWIEWoiYErWLwY?NHLSZoEHJNHLwZLÁWoLZLÎWZZZ?CW?rHJkHSÄZo?WL(ZRkHSIZTEYŒ4WNìYSGZRAZSäW?úZSòWo?HNÞH0000000000000000000000000000000000000000gì000000000cT@s00000000cí^40000002?kCI00000002d-C000000003kQK000000000i$Ý00000000yîsiik0jdg00ïcggÄËðÈÀJR0Äa.úÊâONìsÏ0Òv@,ÑËFËãÔÓ<?JCñÖêEBelÙãlËãOËã0iâLR",
"fire16": "0g0g)000e0Wg(WgSWgwWggWhÀWgwWIÝWIEWIhHIëWLgYhSWICW?rHLSZICWJNHIKWLÁWJkHLwYZnYLÎWIEH?CWL0YZZZoiYNìYoSZTgYS@WTEH?úZJhHRAZ?EHNÎHR*YSÄYL(ZR*ZolWIëWZZHSGZZRZo?WIùWo?H0000000000000000000000000000000000000004wi000000000kÎñ00000001]oxh00000001òEw000000001i$w000000001>gg000000001541õc004K00LI)àøTiJFMë0ÐLVULËíò.þa0BV?gtåONßnt6E?%[B=ÖocI!ßgsßIsÞÃÚgI~-IÊßS(IBßJIs",
"fire17": "0g0gL000e0WggWgwWg(WIÝWhÀWICWhSWIEWJkHhKWIëW?rHIùWJNHŒ4HLgYIëWIhHRAZNÞHLSZNìYRkHT?Yo?WZZZLwYoEHLwZIKWoiYLÁWo?HRkYTgWolWTgHSÔHSaZ?CWLgYoLZZnZSäWZrH0000000000000000000000000000gì0000000000M1000000004cwS00000000Ikw000000000@ow000000000280000000000S00ñ8000w00x]8hPEe{kSë0N|-IøTjõki?0hIP*lÇÒ?ÒDN1l÷éoN!lCöGiJÇaÚLlÚM÷Có}êElÛãœE?Jega1EýgGr-olÚðl",
"fire18": "0g0g+000e0WErWg(WgSWgwWgwWggWIÝWIëWICWhÀWIEWNÞHJhHIKWICWhKWIùWNìYLwYL0YLwZŒ4WNÞYRBWLgYJkH?rHS?ZIhH?úZoLZZZZZZYS@WSIYoSYR*YoiYT?HTGZ?EH?cZSÄYJNHLÁWRAZRkH?ìYNÎHZrWIEHL(Z0000000000000000000000000000gS000000001800000000003g00000000005o0000000000100000000000000400000000I018A(icg00ya$E?)??$G703i?ALVVûËðÂ1Di%I|åDcíoòè?nï.xXiLþÐ_pIoðÕÖÐü]Er!2rÛHoÑ]AÎñ8Î0tÎg$lÄoÎc|]",
"fire19": "0g0g;000ggWe0Wg(WgSWhÀWgwWgwWIÝWL0YIëWhSWIKWJkHJhHIhHLgYNÎHLwYNìYIùWIEW?CWLwZICWJNHLTWSÔHR*YoLZZZZT?HLÁWRkHS@WIëW?úZo?WL(ZSäWTEYŒ4Wo?H?rHŒ4HolWT?ZRBWSäHoSYSaYLSZNÎWSÓZ?rYoiZLgYSGY?EHIEH00000000000000000000000000000000000000140000000000280000000000000000000000000200000000ë00>gwí80000IoÝ]Ac3sMS00?ci|-SÀ?AI1RôdVÿKLÈ|g4*7Ìê8ÌòR?JÇì0?DCÿa{ì5?oe2IÓGOeÀõuçsd0ÆuK||?OCNN3nrÎŒg5úOaúíu",
"fire20": "0g0g*000e0WggWgwWErWhSWICWhÀWg(WIEWIùWIhH?rHJhHgSWIëWL(ZJNHIëWL0YL(Zo?W?CWNÎHZZZŒ4WLgYoEHIÝWLTWNìYICWRAZS?ZoiYT?YRkHhKWLwZLgY?úZSÄYoLZIKWolWZrZSIZoSYJkHSÄHoiHLSZ?EH00000000000000000000000000000000000000000000000000000000000000000000000000000180000000>4S5oÝì4gë00î8í@ECô(l00nI8sh]ÏÃÁVìkg?ÒcAÚisâ?01SNðE?ãÀIañA1ßOCþ!=goGEk0òralr?ðoÜ4RFòrËS7ËðlášofncÎð&Îõðc$s",
"fire21": "0g0g*000ggWhÀWgwWe0WIKWhKWIÝWICWIëWIùWJkHIhH?rHNÎHLwYL0YR*YNÞHLTWS?ZgwWL(ZLwZoiYoLZNÞYR*HoEHLgYhSWg(WSÄZJNHICWLÎWoSYSÔHNìYLÁWZZZSÄH?CWolW?úZZnWIEHL(ZLgYo?WRAZ?cZTgH0000000000000000000000000000000000000000000000000000000000000000000000000000018(00000040h?oÎñwJë00igyi8ß{)?h0áh]GL{BRTÐ00â?ÒDNâNÍ+5I2oö÷PÓsFoD×C0-ØTçcNó%Egëêñe;cÌHóphÝöhüeCóNCõicj|0krCóp&m{Ûö4",
"fire22": "0g0gM000gwWg(WgwWgSWhÀWIëWIÝWIEWL0YIEHNìYIùW?rH?úZggWIhHhSWJNHNÎHNÞHL(ZoEHJkHJhHLwYo?HL(ZhKWSÔWoLZLSZe0WICWLÁWLTWICWS@WZZZSÄZNÎWRAZTEH?CWSaWoiYSIZo?WSÄH00000000000000000000000000000000000000000000000000000000000000000040000000000í8wikSë0000Mñ8T@wJë0ybAI})ziS?ë1kûÁVûÊw1FÒh0IAÑoaÝzËåS?28Ï]A?JÇdCc02Aa]ÞQCde]ÀA2ñ?EÖeAOA=970seAÖePAn/þëNÓeAÖEþÖDAÐ0",
"fire23": "0g0g)000e0WggWhSWgSWgwWgwWhÀWIÝWICWIKW?rHIEWLwYICWIùWLgYLTWIëWL(ZNìY?rY?CWLÎWL0YJNHJkHIëWTGZo?HLwZhKWg(WRAZTEYNÞHIhHLgYŒ3ZZZZSIZNÎHRkYLÁWErWIEH?úZoSYTgWRkHSdZSIY00000000000000000000000000000000000000000000000000000000000000000T8gR8w00000gi8ÁñwJë0iôAcd-À?;Ih0Ãg)GÀ-w1POh0Nò%llcÂÄËðS02oMDiÚÔtä?ë1ãpMRw×ocù(ì1òÃAæFCEKaIi0rÛCåLÖCiTQSiçECåoHèDCãhièdCåOCåOCè?",
"fire24": "0g0gM000ggWe0WgwWgSWIKWgwWIùWhKWg(WIÝWIEHJhHJkHIEW?rHhÀWhSWIëWL0YLwYIhHLgYL(ZoSYNìYICWIëW?EWRAZLSZ?ìYZZZolWo?HoEHLTWTEYTgHNÞHSÄZNÎHZrY?cZR*HTNZLÎWSÄH?CW00000000000000000000000000000000000000000000000000000000000000000T00îgÀh01ñwJôkw1wCh02õ)?JEw0SL00kÂ%*lAxÄ|Áh04}s??xãp<x00LLÚhîÖIÌÕùë0?~ê8Äó*i81ë01?þÕDMÃ?VOS2ñdíÐxEbwí?SGbNí8wí8wí65y8wí8wí8mùNw",
"fire25": "0g0gM000ErWggWgwWgSWgwWg(WIÝWIëWIùWIëWICWhÀWIhHJkHIEWIKWNÎHLwYhKWLTW?CWL0YICWLwZRkYLÁW?rHe0WS?ZSIHL(ZhSWNìYL(ZZZZSaW?úZTgWoEHT?WR*ZoSYSIYZnYLSZJNHNÞYLgY0000000000000000000000000000000000000000000000000000000018(0004kxño00oS0018ACIg00oëë01{wlI81ø;î001[Sí{o?Â*(ë11I{Kít?Äsw015KÎþ÷?DkÝ7004mÒlc;ENseh2m?÷]O×Öo÷ú0//e÷-?÷-?÷-Ri-?E-?÷-?GŒŒ÷-?H-?÷*^IAI",
"fire26": "0g0gM000e0WggWg(WhÀWhSWIKWgwWhKWIëWIùWIÝW?rHJkHgSWLSZIëWNÞHJNHL0YLgYIhHJhH?cZoLZo?HIEWSÄZRBWSaHLÁWLgYoSYRAZZZZoEHR*Y?úZŒ4WTGZTgZT?YZRZTEWL(ZL(Z?CWoiYT?W00000000000000000000000000000000000000000000000000100î4004w000XgÁXs008À000>wJI40@$Th00?kìîsûdAN00à÷cwTgIJgg00Mù*kó|?Q00001ÄËðÃEJI-ëh1CûÚIÌê7cóMhqPÓCECó!FEDhaECEECóEEg#hóECGECó#I^oI^ECiECóEeóEó",
"fire27": "0g0g,000e0WggWgwWg(WgwWhÀWhKWgSWhSWIùWICW?NH?rHIEWJhHL(ZNÎHNÞHIhHIÝWIKWJkHoLZoiZŒ3ZLgYLÎWL0Y?úZZZZLSZNìYS?ZSÄHSÄZSGZSIHSÔWTEHZrZLwYIEHSäW?CWoiYIëWLTWoEHTGZZrHRkYSÄYZrYSIZ000000000000000000000000000000000000000001000000002cM50000w0002gÎi005g(0003cR24Jóow000î8g0keag000h6ELñ-rX00000iTkûÁÁí8(01?mËðÈÇgtårSa7nïOCåocJUh2ÔdaOCåogcÐ×eOCeOCåŒÛ/t0|OCIOCåOùåOðrDCç,GçÅCåOG",
"fire28": "0g0g:000e0WggWgwWg(Wg0WgwWhÀWIÝWICWIKWIùWhKWJNHL0YhSWErWLÎWNÞHNìYJkH?rHIEHLwZS@W?rYLSZolWZZZo?HoSYŒ4WoLZR*YRkYSIZLwYIhHIEWgSW?úZ?CW?EHIëWL(ZSIHSaHLgYZZWZnHSÄHZRZT?ZZrWLÁWoEHTEWNÎHTgW00000000000000000000000000000000000000000T0000000008M2000kg00004xë0xIg000000004í^80000ðseiwEð00000{)?ôsRg0000O??ALBVÿKk01ýÈÚIsÞIÌéL027xòIsÞi?/ÇdcIscIsÞie$Œ0%IsGOsÞILi,6i,sÞœßK[*ÞIva|gnJŠàEßÞiR",
"fire29": "0g0g,000e0WErWggWgwWg(WIKWhÀWgSWIùWIhHIEWhKWL0YLwYICWIÝWIëWJhHNìYIëW?rHNÞYZnWZZZSaH?ìY?úZNÎHLÁWR*HoLZT?YRBWJNHSäHT?ZJkHS?ZR*YZrYSaYRAZoSZSGZoEHZZHSaZSòWZnYSIZSäWIEHZRZNÞH0000000000000000000000000000000000000000gS0000000000wS00i4000000000Áï000001gÞ1kß1000005AC?kSh000016)?øSsÂ|S00JlÇãoÎüLÚi01lcê6oÎI|Is0Ä-N}@oÎð?SdSN+AAæoÎóVEg06?&Ï-ODs(Isû6ÅÚöXSÐ;CIõÏã+dÃ[â?Lã?mo",
"fire30": "0g0g+000g0Wg(WggWgwWgwWhÀWIÝWe0WgSWIEWJkHhKWhSWIëW?rHLwZRBWTgWo?HL(ZL(Z?NHoLZNÎHSÄZZZZR*YoiZJNHIEHSÓZIëWNìYoSZoSHTEH?CWSÔHT?ZSÄYSIZLgYSäWoSYŒ4WSÔWIùWLÁWJhHLwYZrWRkHSaH0000000000000000000000000000000000000000000000000000000gî0000000(0cTS000003oÞicë0000009EEIAI};ù00úiTkJP)kUr01ÑnÎþAÖgtä?St5?ÎsAPCIq3ëal?ó.iPCôðpS1åACUÂPCúCþE1oLEgÂÖCRceóT+eHLAÖH%×AÈuáR~$LPt(Eþg",
"fire31": "0g0gB000gwWe0Wg(WIëWLSZgSWJkHJNHLwYoiYNÞHL(ZŒ3ZR*HSÓZhÀWIÝW?CWoSZT?WZZZLgYo?HolWICWL(ZLÁWRAZRkYoSYICWL0YoiZS?ZLwZ?rH0000000000000000000000000000000000000000000004000000wë00T0000000wi0gT0000008TQ4(@00000igÁisÁI000029kì^ECI4000O8gJö-??t001iÂ|z~<?~ÇÒë1jj]glVVe;op0+aÚ+üVV~USp?lahslVVx;?Aq8cÛ]ýVVcX?÷íBÏèâVV>üVVm",
"soulLantern0": "0g0gb000<lWP@HAeZ2ÇY#$ZzcHÜYWSRZIZZTBZ1yg000002hw002h0iyx00130kVT00130CGÏ003j0Dòß00000DAß00130mGÎ003j0iyx00000hEh00000qyc002h0Cy!00130Cy!00000qyc00000hEh0000000000000",
"soulLantern1": "0g0ga000<lWP@HAeZ2ÇY#$ZçnYZZZlZZTBZ1yg000002hw002h0iyx00130kVT00130BÓÂ003j0CäÏ00000CñÏ00130lÓÁ003j0iyx00000hah00000pyú002h0JyF00130JyF00000pyú00000hah0000000000000",
"soulLantern2": "0g0ga000<lWP@HAeZ2ÇY#$ZGKHZRYlRYTBZ1yg000002hw002h0iyx00130kVT00130BÓÂ003j0CäÏ00000CñÏ00130lÓÁ003j0iyx00000hah00000pyú002h0JyF00130JyF00000pyú00000hah0000000000000",
"lantern0": "0g0gc000<lWP@Hò>Wì2WAeZIíWrQYTCHZTHZsYTBZ1yg000003Q(002h0iyx00150@GÑ00150,Ià005l0-Aî00000-dî00150[Iá005l0iyx00000hgh00000rye002h0Ey#00150Ey#00000rye00000hgh0000000000000",
"lantern1": "0g0gd000<lWP@Hò>Wì2WAeZhÞZr4HSmWZTHTOZrkHTBZ1yg000003Q(002h0iyx00150@GÑ00150,Ià005l0-Aî00000-dî00150_IG005l0iyx00000h?h00000syI002h0iy$00150iy$00000syI00000h?h0000000000000",
"lantern2": "0g0gc000<lWP@Hò>Wì2WAeZgÞZr4HS5YZTHTOZTBZ1yg000003Q(002h0iyx00150@GÑ00150,Ià005l0-Aî00000-dî00150[Iá005l0iyx00000hgh00000rye002h0Ey#00150Ey#00000rye00000hgh0000000000000",
"magma0": "0g0g9SÁHI(HÑCYÀÎYsiWOúWÝIWšcYšáH1z3Aw2ÁzÓ(0Bz6TNGÄyÁNÕNUÄ)liUìzxÃxÁzyÒwNg2@(3N@zw+íÐ06ìUiÏXVzAihTlmxÂÁzBzÂwNki(ANR(3Bw2í6Xz0Bz2RjÏÂ(ANÐÂTNÃyÆUìxxV]XÓzÄN*iC@(Nkw",
"magma1": "0g0g9SÁHOúWÑCYÀÎYI(HsiWÝIWšcYšáH1z3xw2?ÐÓ(0Îz2hNnãCVNxNhm*]ðTlÐA>A?ÐyÕK+S2m(3+ÂÐwNÃz02hUizÁlÐAmïVÁRÕðTzÎzmw+Ái(BNR(3Îw2Â2kz0Az2mÃyi(ÑNÐRoNÃCìTÁAÕUTÆÏzðN)iy@(+]K",
"magma2": "0g0gaSÁHOúWÑCYÀÎYsiWI(HÝIWšáHšcYSRH1z3Aw2?zC(0Dz2âNoðy?NDNhm,ÁRk?zx>FVzyxwNÝ2m(3Nizw+RÐ06?ÁizlÁzÔãklhÂxÂ[ÐAziwNÁm(xNã(3Bw2i6ÞÐ0xz6@jy@(ÑNÏãTNjCnánÎBlVnÓÐ@NMRyi(NÁw",
"crimsonStem0": "0g0g8QîWÀÎWEJH]ûHä0WüÁHI(ZUeZ0DnCMI0knce8/ijIíÞTi1IGÚLAÇïSdvAç(EÞOSvojôKe3tiÉhgÎdAW)Ó?X]ç!ús(i?cíZis1Jiv(óT$?3iN÷7h8)GÖ2þw!úI",
"crimsonStem1": "0g0g8QîWÀÎWI(Z]ûHä0WüÁHUeZEJH0DnC(I0hnce]Ni?>2åTi1[-ÚLoÇï?úroà(EÁWÐuijbeO3?iÉCgÎdü+E@?XAà!hE(L?ïíshu1öCuEóT$l3CO{7ú8)GÁ2þw=ú8",
"crimsonStem2": "0g0g8QîWÀÎWI(Z]ûHä0WüÁHEJHUeZ0DnXM]0hnïeINi?îíÖìi1ñG×LAÇïShvAçEEÎOrcoJôøe>tNÉëgÖdAW(@jC!çNhs)C?ïíZ9k1öLvEIT$l3XOc6ú8(GÎ1mwNh8",
"crimsonStem3": "0g0g8QîWÀÎWä0W]ûHI(ZUeZüÁHEJH0D?Q(I0C?ïEIFi?ííÁTC1iGÂ&üÇILúmAØ;EÁ!ladiô}eIGiÉSgÞdü%ECjXAØFhÕ(C??íR9k1|?tEXT$iîQNó6gIEGÁ1mgFgI",
"crimsonStem4": "0g0g8QîWÀÎWI(Z]ûHä0WüÁHEJHUeZ0DnCM]0CncEI!JJIíÁì?1dGÑLAÇ?SxvAçEEÎOSÍojbøEîtiÉSgÎdAWE@?X]ç*hs(i?IíZio1eiv(XT$I3XO|6h8(GÞ2mw!h]",
"crimsonStemSW0": "0g0g8QîWÀÎWI(ZüÁHEJH]ûHä0WUeZ0D^QoS6logkëÕLhZTòBKÁHAÊCJEDÏ?rbO?úÚiÍjnkã2tMHJòBgÝt?aõRöOi9Ñs?-no+îeiš%kGãis]@h]ECß$ìHc+ò5iLGþS",
"crimsonStemSW1": "0g0g8QîWÀÎWä0WüÁHI(Z]ûHEJHUeZ0C_ÑoS6lwgkëäLëZšòBhÁHüUCJEBy?9bO]úÚQÍinkÂ2thHJòBùÀtdr?iöOi9Ño?Eno+ín@š%kHÑQk]?ú]EiÊ(ìHD[ò5iLGþS",
"crimsonStemSW2": "0g0g8QîWÀÎWä0W]ûHUeZI(ZüÁHEJH0C^QkS5Eù×(ëGGëJ@òDKÁÝüVKJoBy>97pLùlQ.ee(Â1i.ÞJòBgÝùCJ]lôðJ9Qq>-go%îÖIircEã?k]?gi)CêEë?ÒËò5isÙAS",
"crimsonStemSW3": "0g0g8QîWÀÎWä0W]ûHUeZI(ZüÁHEJH0C^QkS5Eù×(ëUGëJ@òCNÁÝüÂKJoCC>97psùlQ.ee(Â1iMÞûPBgÕùR×]c_ñJ9Qk>-go%íúcircCÂQk]?giECÂEë?ÒAò5isÙüS",
"crimsonStemSW4": "0g0g8QîWÀÎWüÁHEJHI(Zä0W]ûHUeZ0D{CqS7ÏCln0GR0ZtòCkÖNþÑhJ(By@möRIúGCÜJrNÚ3êFniòCùÕtiLül}oi9Cq@)Rr:3Ödè+oiÚCq]?hI)LÏ$ìYil95i,?AS",
"warpedStem0": "0g0g8QîWQgZmÄZ]ûHlïYi6HhGYUeZ0DnCMI0knce8/ijIíÞTi1IGÚLAÇïSdvAç(EÞOSvojôKe3tiÉhgÎdAW)Ó?X]ç!ús(i?cíZis1Jiv(óT$?3iN÷7h8)GÖ2þw!úI",
"warpedStem1": "0g0g8QîWQgZhGY]ûHlïYi6HUeZmÄZ0DnC(I0hnce]Ni?>2åTi1[-ÚLoÇï?úroà(EÁWÐuijbeO3?iÉCgÎdü+E@?XAà!hE(L?ïíshu1öCuEóT$l3CO{7ú8)GÁ2þw=ú8",
"warpedStem2": "0g0g8QîWQgZhGY]ûHlïYi6HmÄZUeZ0DnXM]0hnïeINi?îíÖìi1ñG×LAÇïShvAçEEÎOrcoJôøe>tNÉëgÖdAW(@jC!çNhs)C?ïíZ9k1öLvEIT$l3XOc6ú8(GÎ1mwNh8",
"warpedStem3": "0g0g8QîWQgZlïY]ûHhGYUeZi6HmÄZ0D?Q(I0C?ïEIFi?ííÁTC1iGÂ&üÇILúmAØ;EÁ!ladiô}eIGiÉSgÞdü%ECjXAØFhÕ(C??íR9k1|?tEXT$iîQNó6gIEGÁ1mgFgI",
"warpedStem4": "0g0g8QîWQgZhGY]ûHlïYi6HmÄZUeZ0DnCM]0CncEI!JJIíÁì?1dGÑLAÇ?SxvAçEEÎOSÍojbøEîtiÉSgÎdAWE@?X]ç*hs(i?IíZio1eiv(XT$I3XO|6h8(GÞ2mw!h]",
"warpedStemSW0": "0g0g8QîWQgZhGYi6HmÄZ]ûHlïYUeZ0D^QoS6logkëÕLhZTòBKÁHAÊCJEDÏ?rbO?úÚiÍjnkã2tMHJòBgÝt?aõRöOi9Ñs?-no+îeiš%kGãis]@h]ECß$ìHc+ò5iLGþS",
"warpedStemSW1": "0g0g8QîWQgZlïYi6HhGY]ûHmÄZUeZ0C_ÑoS6lwgkëäLëZšòBhÁHüUCJEBy?9bO]úÚQÍinkÂ2thHJòBùÀtdr?iöOi9Ño?Eno+ín@š%kHÑQk]?ú]EiÊ(ìHD[ò5iLGþS",
"warpedStemSW2": "0g0g8QîWQgZlïY]ûHUeZhGYi6HmÄZ0C^QkS5Eù×(ëGGëJ@òDKÁÝüVKJoBy>97pLùlQ.ee(Â1i.ÞJòBgÝùCJ]lôðJ9Qq>-go%îÖIircEã?k]?gi)CêEë?ÒËò5isÙAS",
"warpedStemSW3": "0g0g8QîWQgZlïY]ûHUeZhGYi6HmÄZ0C^QkS5Eù×(ëUGëJ@òCNÁÝüÂKJoCC>97psùlQ.ee(Â1iMÞûPBgÕùR×]c_ñJ9Qk>-go%íúcircCÂQk]?giECÂEë?ÒAò5isÙüS",
"warpedStemSW4": "0g0g8QîWQgZi6HmÄZhGYlïY]ûHUeZ0D{CqS7ÏCln0GR0ZtòCkÖNþÑhJ(By@möRIúGCÜJrNÚ3êFniòCùÕtiLül}oi9Cq@)Rr:3Ödè+oiÚCq]?hI)LÏ$ìYil95i,?AS",
endRod: "0g0gcSõZÞþH000ZZZSEZEGYSjHó7ZZNHZnHZJHZHZ00hyyz2yQ0ÁyywNyÑnÞyyyyyIâÅyyyyyîâÅyyyyyOâÅyyyyyOâÅyyyyyOhhyyyyyûyyyyyyyIyyyyyyyIyyyyyyyóyyyyyyyGyyyyyyyGyyyyyyy0yyyyyyyyyyyyyyy",
endRod2: "0g0gc000SõZZZZÞþHó7ZEGYSEZZNHZJHSjHZnHZHZ000000000000000000000000i0000000x00000000000000000000000000000000000000000000000O)Q>0000*?VÃ0000h?VÃ0000h)Q>0000mÔyyDäÓgmÿßydGgg",
itemFrameIcon: "0g0gi000AJHOÇYl8HGðWúsWÞ2YìyYCBWâûWýNYcÃWCDZZZZADZEÝYþnYilH0000000000000000000000001800000ðx8>gðxõë0iÂücF^ÂùC0óÐoOMjÐxw0óÐdØÉqàgC0iâ%ØàÆccw0óâerØüeúw0iÒeRìLegC0iâpRæþccw4^ÐHiÂLàxw4^Ðso.?àhw1gRwIT8Rxw1ÂUüd^^ücw0000000000",
kelpPlant: "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ00aÙ0000i00006i000001ë000É@÷kEmHNÍgÕ07tögÕ00uS00006}k000ucE0001öë0006S002lÌS00mltëÉSk6NâG000cTE0",
"kelpPlant0": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ00aÙ0000i00006i000001ë000É@÷kEmHNÍgÕ07tögÕ00uS00006}k000ucE0001öë0006S002lÌS00mltëÉSk6NâG000cTE0",
"kelpPlant1": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ00aÚë006i00006i000001ë002Li÷ë0mgNÍgÕ06tögÕ00uS00006Rk000uaE0001öë000N000mLr000GYs0bSC6sãlS00cTG0",
"kelpPlant2": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ00aÙ0006i00000i000001ë00mLiõ002YNÍgÕ06tögÕ00q06h00N2ë000srë000cÚë000N000GLr000CYs01S06sãlS00cTL0",
"kelpPlant3": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ00aÚë000?S0000pS00001ë00mL6õ000ÅÌÍEE07tögÚ00NS6?006S0000sãë000crë0mkNK00GLr000CYs00006sã?S00cTlS",
"kelpPlant4": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ00aÚG000?S0000pS00001C00iS6E002]NÍE00+tegw00NS6N006S0000tÎë000dRë0i]NÙ00J=r000ë,S00000Sß1000dTI0",
"kelpPlant5": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ001}P000?S0000pS00001C00i06E00iPuÍg02[tegA06NS04006S0000uK0000dr002]NÝ00J=r0000,S00000SÙ0000dTIw",
"kelpPlant6": "0g0g8000VúZ?ÁYÌ3WÁiZÈcW|ÞYËiH001|IS00?S/000pS00001h00k07jL0mlÍÂ:S1GOJEo00nS00007S0000v?00001?ë0mk/dE0âiš0000.=00000tG00001L:Õ",
"kelpPlant7": "0g0g8000VúZ?ÁYÌ3WÁiZÈcW|ÞYËiH001|IÕ00?S:S00pS00001h00007jlSkÉÍÂ:ÕmlDJL006nS00007S0000vjë0001?k0GL7|k0liš0000,=00000IL00001L(E",
"kelpPlant8": "0g0g8000VúZ?ÁYÌ3WÁiZÈcW|ÞYËiH001|?S00pS,Õ00lE00001h00007jlSkbÍÂ:ÕmlDJE02LnS00007S0000v?00001Lë0mL7}À00.ÍTk007Dh0000n?00001L(0",
"kelpPlant9": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ001|gw003E0w00rE00001C00006EPw01CÍGwi[teE02]NS00006S0000uE00001H00iS6~h02WuTE00,tC0000NE00001YŠ0",
"kelpPlant10": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ000FëN003E0000rE00000)P0006EGw00uÍGwi@teE02WNS000+6S0000uE00001hh0i06|h0iPuS002WtC0006NE]0001Yg0",
"kelpPlant11": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ000FG400rE00003E00001cI0006eSw00uËEwg9teë0i@NS002@6S0000ueë0001YE0200IE02[?i000]ZL0000rlIA000,SA",
"kelpPlant12": "0g0g8000VúZ?ÁYÌ3WÈcW|ÞYËiHÁiZ000FE400rE00003E00001ci0006eSw00uËE009teë02=?i00i+0i00003lG0000*i0000i-00TAÕ000Pvs0000ráPw000,SA",
"kelpPlant13": "0g0g8000VúZ?ÁYÁiZÌ3W|ÞYÈcWËiH000Fh001xS0000xS00001CÚë007e.E01d|h03ÕnE00rÚDS00g07S00004SN0000+{0000o000K+I000Úcá000dGü|G000+.ð",
"kelpPlant14": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ000FE000?S0000?S00001ìlÕ006øSS0ÉÌËE02ltöë0mëNS00006S00003lL0000MG0000i00003Õ002lÍr7Õ0ÈT?HR000OsI",
"kelpPlant15": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ001|ë000pS0000?S00001ëÉÕ006÷s02LNÍE0mltöE0k6NS00006S0000uCk0000&ë0000i00003i002LZk:Õ0Ål?tR06hOG5",
"kelpPlant16": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ001{0000?S0000pS00001ëbÕ006÷lS2lÌÍG0mltöE0k0NS00006SÀ000uCk0001öë0000i00003i002ìHkÉS2ll?SÚ0ÈIcG0",
"kelpPlant17": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ001{0000?S0000pS00001ë1Õ006÷lÕmlÌÍgSkÅtöG000NS00006Rk000uak0001öë0006S00003i000aZkÉS2lNøSÕmL1aE0",
"kelpPlant18": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ001{0000L00000pS00001ë0E2L6÷lÆmlÌÍgSkÈtöE000NS(0006Rk000uCë0001õ00006S0000NS002ltìlÕmHNøSSk01aE0",
"kelpPlant19": "0g0g8000VúZ?ÁYÌ3W|ÞYÈcWËiHÁiZ001|ë000i00006iw00001ë002Li÷LEmYNÍgÕkatöG000uTE0006Rk000uaë0001õ00006S000ÉÌS002ltëÉÕmëN÷s0001cE0",
kelp: "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ0000000000000000000000000000000000000000000000ù0000Aù0001Eë0001{00004E000JÊC004þühiS46NÒE000=PE0",
"kelp0": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ0000000000000000000000000000000000000000000000ù0000Aù0001Eë0001{00004E000JÊC004þühiS46NÒE000=PE0",
"kelp1": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ0000000000000000000000000000000000000000000004ù0001Aë0009?ë000aw0000BK004JO000AGD02Sw6oÑJS00=PE0",
"kelp2": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000000Aë0001A0000aw0000qw0000BK00AJO000wGD00S06oÑJS00=PJ0",
"kelp3": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000001Aë0009A0000aw0000qK004ùB000AJO000wGD00006oÑùS00=PJS",
"kelp4": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000001A00009w0000aw0000qK004JB000AGO000w+D00000oÑëS00=PJS",
"kelp5": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000w00001w00009w0000aK0000i0000JB000AGO0000+D00000oÙ0000=PJ]",
"kelp6": "0g0g8000ÈcWÌ3WÁiZËiH?ÁY|ÞYVúZ000000000000000000000000000000000000001000009000009w0000ôw0000û0004ùc000?)c0000Co00000DA00007JC]",
"kelp7": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000100000900000Pw0000^A0000qK00AþsC005CO0000+D00000ii00007I(8",
"kelp8": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000800000900000P00000Áw0000^K004JsC000)ÊC0006üh0000N?00007I(0",
"kelp9": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000800000900000Pw0000^w0000aK004ùsC000GÊC000+üh0000N?ë0007IyS",
"kelp10": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000S00000P00000P00000Áw0000aK004ësC004JÊC000Güh0006N?J0007INS",
"kelp11": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000000000P000009w0000aw00009{000ë3ü000þôü000iLA0000raJP000ŠCP",
"kelp12": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ00000000000000000000000000000000000000000000P000009w0000aA00001{00003ü000gPá000iÈÆ0000räi]000ŠCP",
"kelp13": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000009w00009A00001Që0003{00003ü000g9á000iÈÆ0002_äNP000ŠDT",
"kelp14": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000009w00001A00001Që0001Öë0003ü00003á000JÈÆ6]0ilaGI000ŠCI",
"kelp15": "0g0g8000ÈcWÌ3WÁiZËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000001E00009A00000Aë0000{ë0000ý00002ü000JaAy]0kLa+ò04ëŠC1",
"kelp16": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000009w00001A00000Eë0000Õë0000ýë0003ü000ëÂAiS0þaaDP0iIIN0",
"kelp17": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000009A00001Aë0000Eë0000Õë0004eë0003ü0002LAiS0þAJC]4þ7IE0",
"kelp18": "0g0g8000ÈcWÁiZÌ3WËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000001A00000Aë0000Eë0003{ë0004E0000NC000þüIJ]4GNJCS407IE0",
"kelp19": "0g0g8000Ì3WÈcWÁiZËiH?ÁY|ÞYVúZ000000000000000000000000000000000000000000000F00000P00002|00001Ñ00004C000AõC001yNhAù90{IN0007Jù0",
tallSeagrassBottom: "0g0g100W",
tallSeagrassTop:"0g0g100W",
"tallSeagrassBottom0": "0g0g6000/SH&0WFhWÂÂYxKW0Cód000Cí5002wíh002wíh0w2(ihë82ÁRNëg2EiýES2ùRëùë2CîíCë1CýìCë2ClCCh2C?CChlÀocÈhlkoâLëlÀEgÈëmLJGlS",
"tallSeagrassBottom1": "0g0g6000/SH&0WFhWÂÂYxKW0Cód000Cí5002wíh002wíh0w2(ihë82ÁRNëg2EiýES2ùRëùë2CîíCë1CýìCë2ClCCh2C?CChlÀocÀhlkoÎLëlÀEgÈëmkJG?S",
"tallSeagrassBottom2": "0g0g6000/SH&0WFhWÂÂYxKW0Cíd000Cí5002wíh002wíh0w2(iMë82ÁRyëg2EiìES2ùiíùë2CûíCë1CýìCë2ClCCh2C?CChlÀ!cÀhlk!âkëlÀogÀëmkJG?S",
"tallSeagrassBottom3": "0g0g6000&0W/SHFhWÂÂYxKW0iR8ë00iR8ë00iIwë00gIKëw0(ITëg2ÁTRÀ82EpíEë2ChíCS2ùbíùS1ùdìùS2ùbCùh2ùaCùhkkFCkhlkFâkSkLFGkSmLPG?S",
"tallSeagrassBottom4": "0g0g6000/SH&0WÂÂYFhWxKW0khSC00khSC00)iTC00)iìCo0-yxh80/!xkS0]yÏhS0iaÏùë0AkÏCë0ElÏwë0EkCc00AhCc0kU!cÁ0mÀ!þÀÐlÈ!gÁÕmLJG?À",
"tallSeagrassBottom5": "0g0g6000/SH&0WÂÂYFhWxKW0khSC00khSC00)iTC00)iìCo0-yxh80/!xkS0ÆyÏhS0ÂaÏùë0UkÏCë0QlÏwë0AkCc00AhCc0gÆ!cÁ0m^!þÀÐmÈ!gÁÕmLiG?À",
"tallSeagrassBottom6": "0g0g6000/SH&0WÂÂYFhWxKW02hSC00khSC00)iTC00)iìCo0-yxhh0/!xkS0ÆyÏhS0ÂaÏùë0UkÏCë0QlÏwë0UkCc00UhCc0gÈ!cÁ0m]!þÁÕmÉRgÁÕmlRG?À",
"tallSeagrassBottom7": "0g0g6000/SH&0WÂÂYFhWxKW02úSk002úSk00)iS)00)ië)h0-yw-h0/!w/S0ÆyKÆS0ÂaKÀë0UkKwë0QlKwë0UkCF00UhCB0gE!CÉSm]2üÉÕmÉRgÇÕmlRG?À",
"tallSeagrassBottom8": "0g0g6000/SH&0WÂÂYFhWxKW02úSk002úSk004iS)00)ië)h0-yw-h0/!w/ë0ÆyKÆS0ÂaKÂë0UkKUë0QlKQë0UkCUë0UhCÈëg!!CÉSm^2üÇÕmÈ2GÇÀmlRGlÀ",
"tallSeagrassBottom9": "0g0g6000/SH&0WÂÂYFhWxKW02úSk002úSk006iS)00)ië)h0-yw-S0/!w/ë0ÆyKÆS0ÂaKÂS0UkKUë0QlKQë0UkCUë0UhCUëg!!C#Sm^2üVÕmÈ2GVÀmL2GlÀ",
"tallSeagrassBottom10": "0g0g6000/SH&0WÂÂYFhWxKW02úS4ë02úS4006iS)00)ië)h0-yw-S0/!w/ë0ÆyKÆS0ÂaKÂë0UkKUë0QlKQë0UkCUë0UhCUëg!!C#Smi!üVÕmÈ2GÇÀmL!G?À",
"tallSeagrassBottom11": "0g0g6000/SH&0WÂÂYFhWxKW02úS4ë02úSk004iS)00)ië)h0-yw-S0/!w/ë0ÆyKÆS0ÂaKÂë0UkKUë0QlKQë0UkCV00UhCV0g!!CFSm^!üÇÕmÈ!GÇÕmL!GlÀ",
"tallSeagrassBottom12": "0g0g6000/SH&0WÂÂYFhWxKW02úSk00khSk00)iS)00)ië)h0-yw-S0/!w/ë0ÆyKÆS0ÂaKÂë0UkKUë0QlKQë0UkCV00UhCÇ0kÆ!CÇ0m^!üÇÕmÈ!GÇÕmL!GlÀ",
"tallSeagrassBottom13": "0g0g6000/SH&0WÂÂYFhWxKW0k1Sk00C1Sk01CiS)01Cië)h1hyw-S1k!w/ë2hyKÆS2ùaKÂë2CkKAë2wlKAë1!kCB01EhCF0mi!CÇ0m^!üVÕmÈ!gÉÕmLyG?À",
"tallSeagrassBottom14": "0g0g6000/SH&0WÂÂYFhWxKW0kìSC00üìSC01CJTC01CJìCh1hyxhS1k!xkë2SyÏhS0ùaÏùë1gkÏCë1glÏwë1qkCc01!hCc0mE!cV0mÈ!þUÐlÉ!gÉÕm?yGlÀ",
"tallSeagrassBottom15": "0g0g6000/SH&0WÂÂYFhWxKW0CìSC01wìSC01wíTC01wíìCh1I2xhS1?Rxkë2híÏhS2ú2Ïùë2ckÏCë2xlÏwë2ekCc02ehCc0lÈEcÁ0mÈEþUÐlÉ!gVÕm?yGlÀ",
"tallSeagrassBottom16": "0g0g6000/SH&0WFhWÂÂYxKW0Cìd000Cì?002wíÁ002wíÎ0w2(ixë82ÁRy0g2EiíES2ùRíùë2ClíCë1ClìCë2ElCCh2E?CChlÈocÈhlLoâLÐlÈogÄÐmLLGlÕ",
"tallSeagrassBottom17": "0g0g6000/SH&0WFhWÂÂYxKW0Cíd000Cì5002wíh002wíh0w2(iMë82ÁRNëg2EiìES2ùRëùë2CîíCë1ClìCë2ElCCh2E?CChlÈocÈhlLEâLÐlÈEgÈÐmLJGlÕ",
"tallSeagrassBottom18": "0g0g6000/SH&0WFhWÂÂYxKW0Cód000Cí5002wíh002wíh0w2(ihë82ÁRNëg2EiýES2ùRëùë2CîíCë1CýìCë2ElCCh2E?CChlÈocÈhlLoâLÐlÈEgÈÐmLJGlÕ",
"tallSeagrassTop0": "0g0g5000ÂÂY/SH&0WFhW0000000204000i0A000y0Q000N0Ñ000ySQ001ù8Ñ001ùgÑ001CoÕ002w8I002w8I002wbI001CjÕ001Ckc001Ckd002(jdë0",
"tallSeagrassTop1": "0g0g5000ÂÂY/SH&0WFhW0000000004000i0A000y0Q000N0Ñ000y8Q000i8Ñ001ù8Ñ001CbÕ002waI002wbI002wb8001Cjc001Ckd001Ckd002(jdë0",
"tallSeagrassTop2": "0g0g5000ÂÂY/SH&0WFhW00000000S40002SA000y0Q000N0Ñ000y8Q000N9c000Nacë00wbd002wah002wbh002wbh001Cjd001Ckd001Ckd002(jdë0",
"tallSeagrassTop3": "0g0g5000ÂÂY/SH&0WFhW00000000S0ë002S4ë004S8ë006Scë00y08ë00N9cë00Nacë00)bd000Qah000Abh000Abh000Ajd000Akd000A4d000@3dë0",
"tallSeagrassTop4": "0g0g5000ÂÂY/SH&0WFhW00000000S0ë002S4ë004S8ë006Scë004T8ë006T8ë00N18ë00)1d000Q2d000Q3d000Q3d000)31000)21ë00)21ë00@2200",
"tallSeagrassTop5": "0g0g5000ÂÂY/SH&0WFhW0000000080g000S0ù004S1g006S1ù004T1g006Txù006TTù00)1ÎC00Q1Rw00Q12w00Q12w00)2ÎC00)2ìC00)2ìC00@qÏ(0",
"tallSeagrassTop6": "0g0g5000ÂÂY/SHFhW&0W0000000080g000]0ù000I1g000S1ù004T2g008Tyg008TRg008ììC006ìTw006ììw006ììC008íìC008íÎC008íÎC009yìS0",
"tallSeagrassTop7": "0g0g5000ÂÂY/SH&0WFhW00000000802000]0i000I0y000S0N004T0y006TwN006TSN006ìK)008ìSQ008ìKQ008ìKQ006íK)006íë)006íë)006LK@0",
"tallSeagrassTop8": "0g0g5000ÂÂY/SH&0WFhW00000000802000]02000S0y000S0N004T0y006TwN006TSN006ìK)008ìSQ008ìKQ008ìKQ006íK)006íë)006íë)006LK@0",
"tallSeagrassTop9": "0g0g5000ÂÂY/SH&0WFhW00000000S00S02S02S04S04S06S06S04T04S06Tw6S06TS6S06ìK6ë08ìS4ë08ìK4ë08ìK4ë06íK4ë06íë4ë06íë4h06LK@h",
"tallSeagrassTop10": "0g0g5000ÂÂY/SH&0WFhW00000000S00S02S02S04S04S06S06S04S04S06Tw6S06TS6S06ìK6ë08ìS8ë08ìK8ë08ìK8ë06íK6ë06íë6ë06íë4ë06LK6h",
"tallSeagrassTop11": "0g0g5000ÂÂY/SH&0WFhW00000000S00S02S02S04S04S06S06S04S04S06Tw6S06TS6S06ìK6ë08ìS8ë08ìK8ë08ìK4ë06íK4ë06íë4ë06íë4ë06LK6h",
"tallSeagrassTop12": "0g0g5000ÂÂY/SH&0WFhW00000000S02002S0i004S0y006S0N004T0y006TwN006TSN006ìK)008ìSQ008ìKQ008ìKQ006íK)006íë)006íë)006LK@0",
"tallSeagrassTop13": "0g0g5000ÂÂY/SH&0WFhW00000000S0g002S0ù004S1g00601ù00411g0021xg00N1Rg00)1Ïw00Q1Rw00Q1KS00Q1KQ00)2K)00)2ë)00)2ë+00@2K@0",
"tallSeagrassTop14": "0g0g5000ÂÂY/SH&0WFhW0000000200ë00i00ë00y00ë00N00ë00y11000N1xù00N1Tù00)1ÎC00Q1Rw00Q1Ïw00Q1Ïw00)2ÎC00)2ìC00)2ìE00@2Ï(0",
"tallSeagrassTop15": "0g0g5000ÂÂY/SH&0WFhW0000000200ë00i04ë00y08ë00N0cë00y88ë00N9cë00Nacë00)bd002)ah001Cbh001A3h001w21001w21001w2ìë01(2Ï(0",
"tallSeagrassTop16": "0g0g5000ÂÂY/SH&0WFhW0000000204000i0A000y0Q000N0Ñ000y8Q000N9c000gacë01Cbd002wah002wbh002wbh001Cjd001Ckd001Ckd002(3dë0",
"tallSeagrassTop17": "0g0g5000ÂÂY/SH&0WFhW0000000204000i0A000y0Q000N0Ñ000y8Q000g8Ñ001ù8Ñ001CbÕ002waI002wbI002wbg001Cjd001Ckd001Ckd002(jdë0",
"tallSeagrassTop18": "0g0g5000ÂÂY/SH&0WFhW0000000204000i0A000y0Q000N0Ñ000ySQ001ù8Ñ001ùgÑ001CoÕ002w8I002w8I002wbI001CjÕ001Ckc001Ckd002(jdë0",
seagrass:"0g0g100W",
"seagrass0": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000k10000m0S0004I00S06I00S0þi00g8G30whKiw11SÓww1ô]E+ocaëE+XK^ÐliLJTS",
"seagrass1": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000C80000m20000C302006I0200mi00ë8Gw10hcIo11SÓx01ô]E+oc9ÀeiXc^ÐliLi_S",
"seagrass2": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000C80000Di0000)30200+I00S0ki00ë8üz10hcIo11ÕÓB01ô]E+zc9ÀgiXc]AliLg_S",
"seagrass3": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000C80000Eg0001)300S0+100S0ki00ë9k310hciK11ÕÓlo1ì]GCcc9ÀliXc]AliLg_Æ",
"seagrass4": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000C80000E20001(30080)100S0+g00ë1kA10hdRK11Õ×Awdì]G@Xc1ÀliXc8kliLg_Æ",
"seagrass5": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k10000Eg0001(o0080+800S0Gg00ë1mî10o1AQ10Ecizc1]l@îc1ÀliXc9ÀliLgTÆ",
"seagrass6": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k10000Eg0001(o0080+800]0Dg00ë1kA10?1þ480Ecizc1ÀliXc18miLc9ÀliLgTÆ",
"seagrass7": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k10000D20001(o0080C800I0Gg00ë1üo80hcCw81]cizc0!eiLc1Emikõ9ÀliLgTÆ",
"seagrass8": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k10000m20001+b0080Cë00I0Eë00ë5Co10hciw81]cizc0!2iLõ0!mGkõ1iliLgPÆ",
"seagrass9": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k0w000m20000C30080+80085Eë00ë5Ch10hciw11Scizc1]2Ðkõ0!2Gkõ1!liLgPÆ",
"seagrass10": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k0w000m20000C30080+80088Gë00g5Eh10ëchw10hchN1ìÀ2?kÙ0r1Giõ1!mi?gPÆ",
"seagrass11": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000200000k0w000m0S000C30010+80080Gë00g8Gh10g6h010]ÒhN1ìSm?kÙ1Æ1g4õ1imi?gPÆ",
"seagrass12": "0g0g6000ÂÂY/SH&0WxKWFhW00000000000000000000000002000002ëw000khS000C30010+80010Gg00i8Gh10g6h0108ÒhNd0Eâ@ëÙ1Æ1I4Ù9gli?gTÆ",
"seagrass13": "0g0g6000ÂÂY/SH&0WFhWxKW00000000000000000000000002000002ëw0002hS0004hK010+10010Gg0028Go0wkÓúS108ÓcÆc0whÄIK1ghl?ÙbghLRkÁo",
"seagrass14": "0g0g6000ÂÂY/SH&0WxKWFhW00000000000000000000000002000004ëw0002hS0004hK080C10010Gg0028Go0w3×O010EExoc08e(IÕ1ÀlIsÕ^ùliNùTÆ",
"seagrass15": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g000004ëw0002hS0004hK080CI0080G20028Go0w3KI010E×whc1]EM0Õ1SdIzI^ùliLùTÆ",
"seagrass16": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000A0w0002hK0004hK0S0CI0080G200i8G30w3Kiw0wEÏwhd1]EM0Õ0ëe*zë^ùliLùTÆ",
"seagrass17": "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000k100002hK0004hK0S06I0080G200g8G30woKiw0xSÏAw1ì]E)ocaëE)wK^ëliLùTÆ",
seagrassIcon: "0g0g6000ÂÂY/SH&0WxKWFhW0000000000000000000000000g00000C80000Eg0001)300S0+100S0ki00ë9k310hciK11ÕÓlo1ì]GCcc9ÀliXc]AliLg_Æ",
waterFlow:"0g0g100W",
"waterFlow0": "0g0gaEEeDAÚCó%Ic%lËÚE?%K;REGRGŒeCåR0ixz?xhC1yxzÔxhA2yxzKyhE2yyEMxxDRyyþìh1gRiyüß12hNiyü1h2iìiJA1h1hëiJEhihhÄ2úDh21h42úwh21xk2xwn21wk2xwEi1Bm2xw8h1AkixD8h1AoixAäxhA",
"waterFlow1": "0g0gaEEeDAÚCó%Ic%lËÚE?%K;REGRGŒeCåR0ixz?xhC1yxzÔxhA2yxzKyhE2yyEMxxDRyyþìh1gRiyüß12hNiyü1h2iìiJA1h1hëiJEhihhÄ2úDh21h42úwh21xk2xwn21wk2xwoi1Bm2xw8h1AkixD8h1AoixAäxhA",
"waterFlow2": "0g0gaEEeCó%DAÚIc%lËÚE?%K;REGRCåRGŒe0hij?iyj2hijÔiyk1hijKiyk1hhòNiinThhðJy2wTxhXÞ21yMxhX2y1xJxìò2y2yùxìpyxyyÄ1íny12y41így12iA1igD12gA1igFx2lC1ig9y2kAxin9y2kBxikâiyX",
"waterFlow3": "0g0gaEEeCó%DAÚIc%lËÚE?%K;REGRCåRGŒe0hij?iyj2hijÔiyk1hijKiyk1hhòNiinThhðJy2wTxhXÞ21yMxhX2y1xJxìò2y2yùxìpyxyyÄ1íny12y41így12iA1igD12gA1igFx2lC1ig9y2kAxin9y2kBxikâiyX",
"waterFlow4": "0g0gaDAÚE?%Có%lËÚEGRCåREEeIc%K;RGŒe12wzTw0ÃÓ2wDMw0EKywDXw0zÏywDðy0FÏyyFÝwwANyyÆù0K6N2yÃRKÏ0ß2yÃK0Ï2ù2ÂÇK0K0þ2ÂF0200oÏÀA0ÏK0ÐÏÀC0ÏKw3ÏwC4ÏKC3ÏwC92Kx8ÏwCÖ0Kz32wAÖ0Kz",
"waterFlow5": "0g0gaDAÚE?%Có%lËÚEGRCåREEeIc%K;RGŒe12wzTw0ÃÓ2wDMw0EKywDXw0zÏywDðy0FÏyyFÝwwANyyÆù0K6N2yÃRKÏ0ß2yÃK0Ï2ù2ÂÇK0K0þ2ÂF0200oÏÀA0ÏK0ÐÏÀC0ÏKw3ÏwC4ÏKC3ÏwC92Kx8ÏwCÖ0Kz32wAÖ0Kz",
"waterFlow6": "0g0gaDAÚGŒeCó%lËÚEGREEeIc%E?%K;RCåR12wzTw0zVywC,w0CÀywCXw0zÂywCïw0zÂyyúKwwANyyAg0À5N2yûRÀÂ0Ï2yûÀ0Â2g2JúÀ0À0l2Jx0200äÂùA0ÂÀ0ÃÂùB0ÂÀw3ÂwB4ÂÀB3ÂwB12ÀD8ÂwBÁ0Àz32wAÁ0Àz",
"waterFlow7": "0g0gaDAÚGŒeCó%lËÚEGREEeIc%E?%K;RCåR12wzTw0zVywC,w0CÀywCXw0zÂywCïw0zÂyyúKwwANyyAg0À5N2yûRÀÂ0Ï2yûÀ0Â2g2JúÀ0À0l2Jx0200äÂùA0ÂÀ0ÃÂùB0ÂÀw3ÂwB4ÂÀB3ÂwB12ÀD8ÂwBÁ0Àz32wAÁ0Àz",
"waterFlow8": "0g0gbDAÚIc%Có%EGREEeGŒeCåRTRelËÚK;RE?%12wz?00Ô52wB*w0E42wBAw0x02w!îw2E22w!kw2EN2yÎÀwyziyÏÕCwR4i2yÖNS20i2yÖR020À2yÕS020U2yxS200ERw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
"waterFlow9": "0g0gbDAÚIc%Có%EGREEeGŒeCåRTRelËÚK;RE?%12wz?00Ô52wB*w0E42wBAw0x02w!îw2E22w!kw2EN2yÎÀwyziyÏÕCwR4i2yÖNS20i2yÖR020À2yÕS020U2yxS200ERw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
"waterFlow10": "0g0gbDAÚIc%Có%EGREEeGŒeCåRTRelËÚK;RE?%12wz?00Ô52wB*w0E42wBAw0x02w!îw2F22w!kw2EN2yxÀwy!iyÏÕCwR4i2yÖNS20i2yÖR020À2yÕS020U2yxS200ERw!0240?RwA02Sw]RwA42Qw9RwA!0QA8RwAT44F",
"waterFlow11": "0g0gbDAÚIc%Có%EGREEeGŒeCåRTRelËÚK;RE?%12wz?00Ô52wB*w0E42wBAw0x02w!îw2F22w!kw2EN2yxÀwy!iyÏÕCwR4i2yÖNS20i2yÖR020À2yÕS020U2yxS200ERw!0240?RwA02Sw]RwA42Qw9RwAa0QA8RwAT44F",
"waterFlow12": "0g0gbDAÚlËÚEEeCó%Ic%K;REGRGŒeCåRTReE?%1z(NA22*43(+D00ò73(,Ô(0M23(,È(0)03(/m(3M33(/R(3MÐ3OXÝ(O+>OîìC(z2>3OïÐw30>3Oïz030Ý3Oìw030ß3O)w300Ez(/0320Dz(N03w(xz(N23y(5z(Na0yN",
"waterFlow13": "0g0gbDAÚlËÚEEeCó%Ic%K;REGRGŒeCåRTReE?%1z(NA22*43(+D00ò73(,Ô(0M23(,È(0)03(/m(3M33(/R(3MÐ3OXÝ(O+>OîìC(z2>3OïÐw30>3Oïz030Ý3Oìw030ß3O)w300Ez(/0320Dz(N03w(xz(N23y(5z(Na0yN",
"waterFlow14": "0g0gbDAÚlËÚEEeCó%Ic%K;REGRGŒeCåRTReE?%1z(NA22*43(+D00ò73(,Ô(0M23(,È(0)03(/m(3*33(/R(3MÐ3O)Ý(O/>OîìC(z2>3OïÐw30>3Oïz030Ý3Oìw030ß3O)w300Ez(/0320Dz(N03w(xz(N23y(5z(Na0yN",
"waterFlow15": "0g0gbDAÚlËÚEEeCó%Ic%K;REGRGŒeCåRTReE?%1z(NA22*43(+D00ò73(,Ô(0M23(,È(0)03(/m(3*33(/R(3MÐ3O)Ý(O/>OîìC(z2>3OïÐw30>3Oïz030Ý3Oìw030ß3O)w300Ez(/0320Dz(N03w(xz(N23y(5z(Na0yN",
"waterFlow16": "0g0gbEEeK;RCó%DAÚE?%lËÚCåRIc%EGRTReGŒe12z))O(w56z)5((x72z-7w(Ö/NzwazOB(NzwázODONzwÐzNBNNywCzNB2NyB>zN)RNÏÒîzN(RyyÎí3NORNyÎ2ONO>NyÒ3ON(>NyD3NOOë2yE3N(O82zwON(z52zA(N(z",
"waterFlow17": "0g0gbEEeK;RCó%DAÚE?%lËÚCåRIc%EGRTReGŒe12z))O(w56z)5((x72z-7w(Ö/NzwazOB(NzwázODONzwÐzNBNNywCzNB2NyB>zN)RNÏÒîzN(RyyÎí3NORNyÎ2ONO>NyÒ3ON(>NyD3NOOë2yE3N(O82zwON(z52zA(N(z",
"waterFlow18": "0g0gbEEeK;RCó%DAÚE?%lËÚCåRIc%EGRTReGŒe12z))O(w56z)5((x72z-7w(Ö)Nz-awOB(Nz(æzODONz(ÐzOBNNywCzNB2NyB>zN)RNÏÒîzN(RyyÎí3NORNyÎ2ONO>NyÒ3ON(>NyD3NOOë2yE3N(O82zwON(z52zA(N(z",
"waterFlow19": "0g0gbEEeK;RCó%DAÚE?%lËÚCåRIc%EGRTReGŒe12z))O(w56z)5((x72z-7w(Ö)Nz-awOB(Nz(æzODONz(ÐzOBNNywCzNB2NyB>zN)RNÏÒîzN(RyyÎí3NORNyÎ2ONO>NyÒ3ON(>NyD3NOOë2yE3N(z82zwON(z52zA(N(z",
"waterFlow20": "0g0gbEEelËÚCó%DAÚE?%K;RCåRIc%EGRTReGŒe12zA(N(z52z))O(w16z)1((B72z-7w(Ö/NzwazOx(NzwázODONzwÐzNxNNywCzNx2Nyx>zN)RNÏÎîzN(RyyÒí3NORNyÒ2ONO>NyÎ3ON(>NyD3NOOë2yE3N(O82zwON(z",
"waterFlow21": "0g0gbEEelËÚCó%DAÚE?%K;RCåRIc%EGRTReGŒe12zA(N(z52z))O(w16z)1((B72z-7w(Ö/NzwazOx(NzwázODONzwÐzNxNNywCzNx2Nyx>zN)RNÏÎîzN(RyyÒí3NORNyÒ2ONO>NyÎ3ON(>NyD3NOOë2yE3N(O82zwON(z",
"waterFlow22": "0g0gbEEelËÚCó%DAÚE?%K;RCåRIc%EGRTReGŒe12zA(N(z52z))O(w16z)1((B72z-7w(Ö)Nz-awOx(Nz(æzODONz(ÐzOxNNywCzNx2Nyx>zN)RNÏÎîzN(RyyÒí3NORNyÒ2ONO>NyÎ3ON(>NyD3NOOë2yE3N(O82zwON(z",
"waterFlow23": "0g0gbEEelËÚCó%DAÚE?%K;RCåRIc%EGRTReGŒe12zA(N(z52z))O(w16z)1((B72z-7w(Ö)Nz-awOx(Nz(æzODONz(ÐzOxNNywCzNx2Nyx>zN)RNÏÎîzN(RyyÒí3NORNyÒ2ONO>NyÎ3ON(>NyD3NOOë2yE3N(O82zwON(z",
"waterFlow24": "0g0gbEGREEeDAÚCó%E?%lËÚIc%K;RGŒeCåRTRe1iOAyzxM5jOCxzwMnjOEANxMljNE5MxýmzNAlMxAAzNwoMy*xzNxoNy+yzNxgNy*zzOxhNy*jzû*iNyAjOO*iNNhjOO*2iNijNOþiiNiiNO+iyNx2yO)izOx2iOMizMx",
"waterFlow25": "0g0gbEGREEeDAÚCó%E?%lËÚIc%K;RGŒeCåRTRe1iOAyzxM5jOCxzwMnjOEANxMljNE5MxýmzNAlMxAAzNwoMy*xzNxoNy+yzNxgNy*zzOxhNy*jzû*iNyAjOO*iNNhjOO*2iNijNOþiiNiiNO+iyNx2yO)izOx2iOMizMx",
"waterFlow26": "0g0gbEGREEeDAÚCó%E?%lËÚIc%K;RGŒeCåRTRe1iOAyzxM5jOCxzwMnjOEANxMljNE5MxýmzNAlMxAAzNAmMx*xzNxoMy+yzNxkNy*zzOxhNy*jzûBiNyAjOO*iNNhjOO*2iNijNOþiiNiiNO+iyNx2yO)izOx2iOMizMx",
"waterFlow27": "0g0gbEGREEeDAÚCó%E?%lËÚIc%K;RGŒeCåRTRe1iOAyzxM5jOCxzwMnjOEANxMljNE5MxýmzNAlMxAAzNAmMx*xzNxoMy+yzNxkNy*zzOxhNy*jzûBiNyAjOO*iNNhjOO*2iNijNOþiiNiiNO+iyNx2yO)izOx2iOMizMx",
"waterFlow28": "0g0gbEGRDAÚEEeCó%E?%lËÚIc%K;RGŒeCåRTRe1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiýCjMkBNiAkjMgENh*ijMiEMh+hjMiwMh*jjOiyMh*zjû*xMhkzOO*xMMyzOO*1xMxzMOþxxMxxMO+xhMi1hO)xjOi",
"waterFlow29": "0g0gbEGRDAÚEEeCó%E?%lËÚIc%K;RGŒeCåRTRe1xONxjNi2zOkhjiN5zOmijgNDzOokMiNBzMo5NiýCjMkBNiAkjMgENh*ijMiEMh+hjMiwMh*jjOiyMh*zjû*xMhkzOO*xMMyzOO*1xMxzMOþxxMxxMO+xhMi1hO)xjOi",
"waterFlow30": "0g0gbEGRDAÚEEeCó%E?%lËÚIc%K;RGŒeCåRTRe1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiýCjMkBNiAkjMkCNi*ijMiENh+hjMiAMh*jjOiyMh*zjûlxMhkzOO*xMMyzOO*1xMxzMOþxxMxxMO+xhMi1hO)xjOi",
"waterFlow31": "0g0gbEGRDAÚEEeCó%E?%lËÚIc%K;RGŒeCåRTRe1xONxjNi2xOkhjiN5zOmijgNDzOokMiNBzMo5NiýCjMkBNiAkjMkCNi*ijMiENh+hjMiAMh*jjOiyMh*zjûlxMhkzOO*xMMyzOO*1xMxzMOþxxMxxMO+xhMi1hO)xjOi",
"waterFlow32": "0g0gaGŒeDAÚCó%EGREEelËÚIc%E?%K;RCåR1hyjQixk1TykQiAk4TyghiAA5iymkiDAäix@gxnA+iúS*AjýSiúS*AjýnTxn@AkBkhxkSAhChhxk[xhBihykQxhBihJghxh[RhywThhQRxyDMTxTRxyÿTTxQThyDTRxQ",
"waterFlow33": "0g0gaGŒeDAÚCó%EGREEelËÚIc%E?%K;RCåR1hyjQixk1TykQiAk4TyghiAA5iymkiDAäix@gxnA+iúS*AjýSiúS*AjýnTxn@AkBkhxkSAhChhxk[xhBihykQxhBihJghxh[RhywThhQRxyDMTxTRxyÿTTxQThyDTRxQ",
"waterFlow34": "0g0gaGŒeDAÚCó%EGREEelËÚIc%E?%K;RCåR1hyjQixk1TykQiAk4TyghiAA5iymkiDAäix@gxnA+iúS*AjýSiúS*Ajý[Tú[@AkCkhúQSAkBhhúk[xhEihúkQxhBihJghxh[RhywThhQRxyDMTxTRxyÿTTxQThyDTRxQ",
"waterFlow35": "0g0gaGŒeDAÚCó%EGREEelËÚIc%E?%K;RCåR1hyjQixk1TykQiAk4TyghiAA5iymkiDAäix@gxnA+iúS*AjýSiúS*Ajý[Tú[@AkCkhúQSAkBhhúk[xhEihúkQxhBihJghxh[RhywThhQRxyDMTxTRxyÿTTxQThyDTRxQ",
"waterFlow36": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚIc%K;RCåR1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwÅiú4Äwlþ4iú4Äwlþj1xj7wgCghxg4whDhhxg3xhCihyg0xhCihJkhxh32hyA1hh02xyzÁ1x12xyû11x0",
"waterFlow37": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚIc%K;RCåR1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwÅiú4Äwlþ4iú4Äwlþj1xj7wgCghxg4whDhhxg3xhCihyg0xhCihJkhxh32hyA1hh02xyzÁ1x12xyû11x0",
"waterFlow38": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚIc%K;RCåR1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwÅiú4Äwlþ4iú4Äwlþ31ú37wgDghú04wgChhúg3xhEihúg0xhCihJkhxh32hyA1hh02xyzÁ1x12xyû11x0",
"waterFlow39": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚIc%K;RCåR1hyz12x0Thyl0ixgT1yg0iwgS1ykhiww@iyngizw-ix7kxjwÅiú4Äwlþ4iú4Äwlþ31ú37wgDghú04wgChhúg3xhEihúg0xhCihJkhxh32hyA1hh02xyzÁ1x12xyû11x0",
"waterFlow40": "0g0gaEEeCó%DAÚEGRlËÚGŒeIc%K;RCåRE?%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggÔxhCzhmgÑxi5BiBgÄxi5)gBn*xí*)gFX92í96g0mwyí05gwkyyí09iwnxyíy0iwAxyìwyiw.1yhg2xw(xihg21iN",
"waterFlow41": "0g0gaEEeCó%DAÚEGRlËÚGŒeIc%K;RCåRE?%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggÔyhCzhmgÑxi5BiBgÄxi5)gBn*xí*)gFX92í96g0mwyí05gwkyyí09iwnxyíy0iwAxyìwyiw.1yhg2xw(xihg21iN",
"waterFlow42": "0g0gaEEeCó%DAÚEGRlËÚGŒeIc%K;RCåRE?%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSyhByxggÔyhCzhmgÑxi5BiBgÄxi5)gBn*xí*)gFX92í96g3k0yí35gwnyyí09iwkxyí00iwCxyìwyiwO1yhw2xw(xihg21iN",
"waterFlow43": "0g0gaEEeCó%DAÚEGRlËÚGŒeIc%K;RCåRE?%1ihg21i3Nyhg21i0Syhi01i0Ryhg0xgwSxhByxggÔyhCzhmgÑxi5BiBgÄxi5)gBn*xí*)gFX92í96g3k0yí35gwnyyí09iwkxyí00iwCxyìwyiwO1yhw2xw(xihg21iN",
"waterFlow44": "0g0gaDAÚCó%EEeEGRlËÚGŒeIc%K;RCåRE?%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501iiÔ0h63hmiÑ1gB5g5iÄ1gB)i5n*1ë*)i9XFwëFCiym20ëyBi2k00ëyFg2n10ë0yg2410ì20g2.x0hiw12N",
"waterFlow45": "0g0gaDAÚCó%EEeEGRGŒelËÚIc%K;RCåRE?%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyÀ0hiy1i2Â0h401iiÔ0h63hmiÒ1gA4g4i@1gA*i4n)1ë)*i9ïFwëFCiym20ëyAi2l00ëyFg2n10ë0yg2510ì20g2.x0hiw12N",
"waterFlow46": "0g0gaDAÚCó%EEeEGRlËÚGŒeIc%K;RCåRE?%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501iiÔ0h63hmiÑ1gB5g5iÄ1gB)i5n*1ë*)i9XFwëFCizky0ëzBi2n00ëyFg2k10ëyyg2610ì20g2Ox0h2w12N",
"waterFlow47": "0g0gaDAÚCó%EEeEGRlËÚGŒeIc%K;RCåRE?%1ghiwxg(xghiwxgz(0hiwxgyR0hgyxgyS0hiy1i2R0h501iiÔ0h63hmiÑ1gB5g5iÄ1gB)i5n*1ë*)i9XFwëFCizky0ëzBi2n00ëyFg2k10ëyyg2610ì20g2Ox0h2w12N",
"waterFlow48": "0g0gaDAÚCó%EEeEGRE?%CåRGŒeK;RlËÚIc%1gh2013R1ghgwxiSxglÀwxgOK0lg0xgOß0lg2xgyí0lg21j2ß0hi01i2ä0g431oiò1gA6g8iþ1gA.g9p)1À>Fg6oA2ÀAFizoy2ÀzCiCn02ÀyAgAo12Àyyg4910Á20g4Ð",
"waterFlow49": "0g0gaDAÚCó%EEeEGRE?%CåRGŒeK;RlËÚIc%1gh2013R1ghgwxiSxglÀwxgOK0lg0xgOß0lg2xgyí0lg21j2ß0hi01i2ä0g431oiò1gA6g8iþ1gA.g9p)1À>Fg6oA2ÀAFizoy2ÀzCiCn02ÀyAgAo12Àyyg4910Á20g4Ð",
"waterFlow50": "0g0gbDAÚCó%EEeEGRE?%CåRGŒeK;RlËÚIc%GlÚ1gh2013R1ghgwxiSxglÀwxgOK0lg0xgOß0lg2xgyí0lg21j2ß0hi01i2ä0g431oiò1gA6g8iþ1gA.g9p)1À>Fg6oz2À>FgAoy2ÁO!gCo02ÀNAgAp12Àyyg4610Áy0g4Ð",
"waterFlow51": "0g0gaDAÚCó%EEeEGRE?%CåRGŒeK;RlËÚIc%1gh2013R1ghgwxiSxglÀwxgOK0lg0xgOß0lg2xgyí0lg21j2ß0hi01i2ä0g431oiò1gA6g8iþ1gA.g9p)1À>Fg6oz2À>FgAoy2ÀOCgCo02ÀNAgAp12Àyyg4610Áy0g4Ð",
"waterFlow52": "0g0gaDAÚCó%CåREEeE?%GŒeEGRK;RlËÚIc%10xO0g4Ä1gh3016>1ghg(MjSMgiw(MgÓÀ0ig0MgÓà0ig3MgOî0ig31m3à0hj01j3ä0g461ojòhg)5g8jý1g)Ög9pÑ1w@.g5o)3w).j+oO3w+*j*n03wO)g)o13wOOg49",
"waterFlow53": "0g0gaDAÚCó%CåREEeE?%GŒeEGRK;RlËÚIc%10xO0g4Ä1gh3016>1ghg(MjSMgiw(MgÓÀ0ig0MgÓà0ig3MgOî0ig31m3à0hj01j3ä0g461ojò1g)5g8jý1g)Ög9pÑ1w@.g5o)3w).j+oO3w+*j*n03wO)g)o13wOOg49",
"waterFlow54": "0g0gaDAÚCó%CåREEeE?%GŒeEGRK;RlËÚIc%10x30g4Ä1gh3016>1ghg(MjSMgiw(MgÓÀ0ig0MgÓà0ig3MgOî0ig31m3à0hj01j3ä0g461ojò1g)5g8jý1g)Ög9pÑ1w@.g5o+3w@.g)oO3wÓ*g*o03wÐ)g)p13wOOg45",
"waterFlow55": "0g0gaDAÚCó%CåREEeE?%GŒeEGRK;RlËÚIc%10x30g4Ä1gh3016>1ghg(MjSMgiw(MgÓÀ0ig0MgÓà0ig3MgOî0ig31m3à0hj01j3ä0g461ojò1g)5g8jý1g)Ög9pÑ1w@.g5o+3w@.g)oO3wÓ*g*o03wÐ)g)p13wOOg45",
"waterFlow56": "0g0gaDAÚCó%EEeCåREGRIc%GŒeE?%K;RlËÚ12(A2g?412My0hCÏ1gM0017ß1ij00w4Ýx2jg0wiáÀ2jg0xgQí2jg21gyJ0jg01kyÂ0hg0142þ0g2209iþ0g27g8iÿhgDDg9káh(GDgBkA2(áBgGpy2(QCgåp02(RDg?5",
"waterFlow57": "0g0gaDAÚCó%EEeCåREGRIc%GŒeE?%K;RlËÚ12(A2g?412My0hCÏ1gM0017ß1ij00w4Ýx2jg0wiáÀ2jg0xgQí2jg21gyJ0jg01kyÂ0hg0142þ0g2209iþ0g27g8iÿhgDDg9káh(GDgBkA2(áBgGpy2(QCgåp02(RDg?5",
"waterFlow58": "0g0gaDAÚCó%EEeCåRIc%GŒeEGRE?%K;RlËÚ12(y2gA512My0gBÄ1gM0017ß1ij00w6Ýx2jg0wiãS2jg0xgÓí2jg21gyJ0jg01myR0hg0162ý0g2209iý0g27g8iÿhgDDg9nãh(GDgAmy2(GDgám22(ÔDgåm12(ÓCgÑ6",
"waterFlow59": "0g0gaDAÚCó%EEeCåRIc%GŒeEGRE?%K;RlËÚ12(y2gA512My0gBÄ1gM0017ß1ij00w6Ýx2jg0wiãS2jg0xgÓí2jg21gyJ0jg01myR0hg0162ý0g2209iý0g27g8iÿhgDDg9mãh(GDgAmy2(GDgám22(ÔDgåm12(ÓCgÑ6",
"waterFlow60": "0g0gaDAÚCó%EEeCåREGRIc%GŒeE?%K;RlËÚ12(QAg?412(A2g?412My0hCÏ1gM0017ß1ij00w4Ýx2jg0wiáÀ2jg0xgQí2jg21gyJ0jg01kyÂ0hg0142þ0g2209iþ0g27g8iÿhgDDg9káh(GDgBkA2(áBgGpy2(QCgåp",
"waterFlow61": "0g0gaDAÚCó%EEeCåREGRE?%Ic%GŒeK;RlËÚ12(?Ag@412(A2g@412My0hDß1gM0015Â1ij00w4Àx2jg0wiUK2jg1xgQí2jg21gyJ0jg01kyÏ0hg0142ÿ0g2209iÿ0g25g8iýhgBBg9kUh(VBgCkA2(UCgVpy2(QDgÇp",
"waterFlow62": "0g0gaDAÚEEeCåREGRE?%Có%Ic%GŒeK;RlËÚ01wMkÀ+651wh1Àm751Bh0Ànà5ÀB0054T5ÁÂ00g3Sl1ÂÀ0gÁ>K1ÂÀ0lÀOì1ÂÀ15Àhú0ÂÀ05ÃhÎ0VÀ0531ÿ0À1109Áÿ0À14À8ÁüVÀkkÀ9Ã>VwQkÀmÃh1wQkÀ@Ã11w)kÀPÃ",
"waterFlow63": "0g0gaDAÚEEeCåREGRE?%Có%Ic%GŒeK;RlËÚ01wMkÀ+651wh1Àm751Bh0Ànà5ÀB0054T5ÁÂ00g3Sl1ÂÀ0gÁ>K1ÂÀ0lÀOì1ÂÀ15Àhú0ÂÀ05ÃhÎ0VÀ0531ÿ0À110ÇÁÿ0À14À8ÁüVÀkkÀ9Ã>VwQkÀmÃh1wQkÀ@Ã11w)kÀPÃ",
"waterFlow64": "0g0gbDAÚCó%EEeCåRE?%Ic%lËÚGŒeEGRTReK;R0i(AygÄi1i(Ayhã21i(E0h?21gMy01ïß1gM001Dß1ij0004Sx8jg00i[À8jg00gXÏ2jg20gAJ2jg20nAÏ2hg0048Æ0h0ig6oÏ0g2og!iÏ0g78g!iR1(ñygCiyg(QAgÒo",
"waterFlow65": "0g0gbDAÚCó%EEeCåRE?%Ic%lËÚGŒeEGRTReK;R0i(AygÄi1i(Ayhã21i(E0h?21gMy01ïß1gM001Dß1ij0004Sx8jg00i[À8jg00gXÏ2jg20gAJ2jg20nAÏ2hg0048Æ0h0ig6oÏ0g2og!iÏ0g78g!iR1(ñygCiyg(QAgÒo",
"waterFlow66": "0g0gbDAÚEEeCó%CåREGRE?%Ic%lËÚGŒeTReK;R1x(?kwÔA2x(?kwñ42x(khwÄ42wNh02@ì2wN002oì2xz0005Ài4zw00xÆK4zw00w?Þ1zw10wlú1zw10ElÞ1yw0054Ñ0y0xw7AÞ0w1AwqxÞ0w84wqxÁ2(]hwnxhw(ohwGx",
"waterFlow67": "0g0gbDAÚEEeCó%CåREGRE?%Ic%lËÚGŒeTReK;R1x(?kwÔA2x(?kwñ42x(khwÄ42wNh02@ì2wN002oì2xz0005Ài4zw00xÆK4zw00w?Þ1zw10wlú1zw10ElÞ1yw0054Ñ0y0xw7AÞ0w1AwqxÞ0w84wqxÁ2(]hwnxhw(ohwGx",
"waterFlow68": "0g0gbEEeCó%DAÚCåRGŒelËÚE?%Ic%EGRTReK;R0iN40iVgygN60iâgxgN60h?wxgN8yhÔwxiM0yxñSxiMyyx4SxgjyyyCÏ1EjiyygÑßEjiyyiðÀwjiwyi6ùwjiwyk6ÀwhiyyCEäyhygiBoÀiiwoiagÀyiAEiagKxNX0i5g",
"waterFlow69": "0g0gbEEeCó%DAÚCåRGŒelËÚE?%Ic%EGRTReK;R0iN40iVgygN60iâgxgN60h?wxgN8yhÔwxiM0yxñSxiMyyx4SxgjyyyCÏ1EjiyygÑßEjiyyiðÀwjiwyi6ùwjiwyk6ÀwhiyyCEäyhygiBoÀyiwoiagÀyiAEiagKxNX0i5g",
"waterFlow70": "0g0gbEEeCó%DAÚCåRE?%lËÚIc%EGRGŒeTReK;R0iNQ4iÄnwgNá7iÒnxgNá7iïDxgN70i@DxiM0yxãëxiMyyx8ëxgjyyyAR1Djiyyg]ÏDjiyyiáÀwjiwyi4ùwjiwyo4ÀwhiyyADÔyhygiBnÀyiwniagÀyiEDiagSxNä0i5g",
"waterFlow71": "0g0gbEEeCó%DAÚCåRE?%lËÚIc%EGRGŒeTReK;R0iNQ4iÄnwgNá7iÒnxgNá7iïDxgN70i@DxiM0yxãëxiMyyx8ëxgjyyyAR1Djiyyg]ÏDjiyyiáÀwjiwyi4ùwjiwyo4ÀwhiyyADÔyhygiBnÀyiwniagÀyiEDiagSxNä0i5g",
"waterFlow72": "0g0gcE?%DAÚCåRCó%EEeEGRlËÚK;RIc%GŒeZZRTRe1hzSQMÄ)TMzSkMÓ)hMz?kMã)hMzShOÕkhMz?hOIQjOzQhjA4jMzhhjÇ4j*yhhhSÁ>.NMhh)ÆÑ.NMkhMÇì(NMkhMPcgNOkh-pelOM)MppìkOh)M@.ÎhOh)M[(ÎhzgkM[*",
"waterFlow73": "0g0gcE?%DAÚCåRCó%EEeEGRlËÚK;RIc%GŒeZZRTRe1hzSQMÄ)TMzSkMÓ)hMz?kMã)hMzShOÕkhMz?hOIQjMzQhjA4jMzhhjÇ4j*yhhhSÁ>.NMhh)ÆÑ.NMkhMÇì(NMkhMPcgNOkh-pelOM)MppìkOh)M@.ÎhOh)M[(ÎhzgkM[*",
"waterFlow74": "0g0gcE?%DAÚCåRCó%EEeEGRlËÚGŒeK;RIc%ZZRTRe1hzSQMÄ)QMx[QMÓ)hMxSQMð)hMxSQOÖkhMx?hOåQjMzQhjå4jMzhhjÅ4j*yhhhSÁ>,NMhh)ÇÑ,NMkhMÅú(NMkhM[cgNOkh.nelOM)MnnúkOh)M@,ÎhOh)M](ÎhzgkM]*",
"waterFlow75": "0g0gcE?%DAÚCåRCó%EEeEGRlËÚGŒeK;RIc%ZZRTRe1hzSQMÄ)QMx[QMÓ)hMxSQMð)hMxSQOÖkhMx?hOåQjMzQhjå4jMzhhjÅ4j*yhhhSÁ>,NMhh)ÇÑ,NMkhMÅú(NMkhM[cgNOkh.nelOM)MnnúkOh)M@,ÎhOh)M](ÎhzgkM]*",
"waterFlow76": "0g0gclËÚDAÚCåRCó%E?%EEeK;REGRIc%GŒeZZRTRe1hzklMÄ,ThzUVMÝ*ÁMzUlM0*hMzÅlMK*hMzUhO8lhMzÅhOIVjMzVhjA?jMzhhjå?j,yhhhUÞÃ.NMhh*ä5.NMlhMåì)NMlhMÇckNOlh-penOM*MppìlOh*MÀ.1hOh*MÄ)",
"waterFlow77": "0g0gclËÚDAÚCåRCó%E?%EEeK;REGRIc%GŒeZZRTRe1hzklMÄ,ThzUVMÝ*ÁMzUlM0*hMzÅlMK*hMzUhO8lhMzÅhOIVjMzVhjA?jMzhhjå?j,yhhhUÞÃ.NMhh*ä5.NMlhMåì)NMlhMÇckNOlh-penOM*MppìlOh*MÀ.1hOh*MÄ)",
"waterFlow78": "0g0gclËÚDAÚCåRCó%E?%EEeK;REGRGŒeIc%ZZRTRe1hzklMÄ,ThzUVMÝ*VMxÆVM0*hMxUVMK*hMxUVO9lhMxÅhOòVjMzVhjò?jMzhhjä?j,yhhhUÞÃ-NMhh*å5-NMlhMäú)NMlhMÆckNOlh.oenOM*MooúlOh*MÀ-1hOh*MÄ)",
"waterFlow79": "0g0gclËÚDAÚCåRCó%E?%EEeK;REGRGŒeIc%ZZRTRe1hzklMÄ,ThzUVMÝ*VMxÆVM0*hMxUVMK*hMxUVO9lhMxÅhOòVjMzVhjò?jMzhhjä?j,yhhhUÞÃ-NMhh*å5-NMlhMäú)NMlhMÆckNOlh.oenOM*MooúlOh*MÀ-1hOh*MÄ)",
"waterFlow80": "0g0gclËÚDAÚEEeCåRCó%EGRIc%GŒeE?%K;RZZRTRe1i)h?TC[1hQiRTw?ìhQiiTÇRxQQliT9RkTQBiTùRTTQyiQ7yhTQyhQÕyhT)yhQäyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCcn>QihpmenQTRhwn1iQhRhw[",
"waterFlow81": "0g0gdlËÚDAÚEEeCåRCó%EGRIc%GŒeE?%K;RZZRTReIsÚ1i)h?TC[1hQiRTw?ìhQiiTÇRxQQliT9RkTQBiTùRTTQyiQ7yhTQyhQÕyhT)yhQäyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCcn>QihpmenQTRhwn1iQhRh$[",
"waterFlow82": "0g0gdlËÚDAÚEEeCåRCó%EGRIc%GŒeHTRE?%K;RZZRTRe1i)h?TC[1hQiRTE?úhQiiTÈRxQ)FiT0RhT)BiTDRhT)FhQ7yhT)BhQÖyhT)yhQåyhMOhhQVykP>hiTyxAS>TiTiC2S>TihTD2@>TihTCen>QihqmInQTRhwn1iQhRhw[",
"waterFlow83": "0g0gclËÚDAÚEEeCåRCó%EGRIc%GŒeE?%K;RZZRTRe1i)h?TC[1hQiRTw?ìhQiiTÇRxQ)EiT0RhT)BiTþRhT)EhQ7yhT)BhQÕyhT)yhQäyhMOhhQVyk]>hiTyxAS>TiTiC2S>TihTD2@>TihTCcn>QihpmenQTRhwn1iQhRhw[",
"waterFlow84": "0g0gclËÚDAÚEEeCó%GŒeCåREGRIc%E?%K;RZZRTRe1iOhNhw)1iÃh+MD)1hOiNMw+ìhOiiMÖNxOOmiM9NjMOCiMùNMMOyiO4yhMOyhOäyhMÃyhO]yhÁVhhOÓyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDck*OihpnekOMNhwk",
"waterFlow85": "0g0gclËÚDAÚEEeCó%GŒeCåREGRIc%E?%K;RZZRTRe1iOhNhw)1iÃh+MD)1hOiNMw+ìhOiiMÖNxOOmiM9NjMOCiMùNMMOyiO4yhMOyhOäyhMÃyhO]yhÁVhhOÓyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDck*OihpnekOMNhwk",
"waterFlow86": "0g0gclËÚDAÚEEeCó%GŒeCåREGRIc%E?%K;RZZRTRe1iOhNhw)1iÃh+MD)1hOiNMw+ìhOiiMÖNxOÃEiM0NhMÃCiMÿNhMÃEhO4yhMÃChOäyhMÃyhO]yhÁVhhOÓyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDck*OihpnekOMNhwk",
"waterFlow87": "0g0gclËÚDAÚEEeCó%GŒeCåREGRIc%E?%K;RZZRTRe1iOhNhw)1iÃh+MD)1hOiNMw+ìhOiiMÖNxOÃEiM0NhMÃCiMÿNhMÃEhO4yhMÃChOäyhMÃyhO]yhÁVhhOÓyj-*hiMyxz(*MiMiD2(*MihMA2,*MihMDck*OihpnekOMNhwk",
"waterFlow88": "0g0galËÚDAÚE?%CåRCó%EEeEGRIc%K;RGŒe1i)h?TÀi1l)h?TÀR1h)h@TÅ@ÞhQhmTÀ*ÎkQlmTÆ*hkQlmT0?hkQVlTå?TQQVlTýVTQQlhQBVTQOlhQÒÁhTOhhQÁÁh@)TlQhVUS)TlQTÅ5S)MmQTÇ1[)QlQTÇ1p)QlTop",
"waterFlow89": "0g0galËÚDAÚE?%CåRCó%EEeEGRIc%K;RGŒe1i)h?TÀi1l)h?TÀR1h)h@TÅ@ÞhQhmTÀ*ÎkQlmTÆ*hkQlmT0?hkQVlTå?TQQVlTýVTQQlhQBVTQOlhQÒÁhTOThQÁÁh@)TlQhVUS)TlQTÅ5S)MmQTÇ1[)QlQTÇ1p)QlTop",
"waterFlow90": "0g0galËÚDAÚE?%CåRCó%EEeEGRIc%K;RGŒe1i)h?TÀi1l)h?TÀR1h)h@TÅ@ÞhQhmTÀ*ÎkQlmTÆ*ÁQQllT8?kQQVlTGTTQQVlQãÁTQQlhQýÁTQOlhQBÁhTOhhQÁÁh@)TlQhVUS)TlQTÅ5S)MmQTÇ1[)QlQTÇ1p)QlTop",
"waterFlow91": "0g0galËÚDAÚE?%CåRCó%EEeEGRIc%K;RGŒe1i)h?TÀi1l)h?TÀR1h)h@TÅ@ÞhQhmTÀ*ÎkQlmTÆ*ÁQQllT8?kQQVlTGTTQQVlQãÁTQQlhQýÁTQOlhQBÁhTOhhQÁÁh@)TlQhVUS)TlQTÅ5S)MmQTÇ1[)QlQTÇ1p)QlTop",
"waterFlow92": "0g0galËÚDAÚGŒeCåRCó%EEeK;RE?%EGRIc%1i)QlTmi1n)h?TÀn1l)h?TÀ[1h)h]TÇ]úhQhoTÀ*ìkQloTÄ*hkQloT0?hkQVlTJ?TQQVlTBVTQQlhQâVTQOlhQïÁhTOhhQÁÁh])TlQhVUS)TlQTÇ5S)MoQTÂ1P)QlQTÂ",
"waterFlow93": "0g0galËÚDAÚGŒeCåRCó%EEeK;RE?%EGRIc%1i)QlTmi1n)h?TÀn1l)h?TÀ[1h)h]TÇ]úhQhoTÀ*ìkQloTÄ*hkQloT0?hkQVlTJ?TQQVlTBVTQQlhQâVTQOlhQïÁhTOhhQÁÁh])TlQhVUS)TlQTÇ5S)MoQTÂ1P)QlQTÂ",
"waterFlow94": "0g0galËÚDAÚGŒeCåRCó%EEeK;RE?%EGRIc%1i)QlTmi1n)h?TÀn1l)h?TÀ[1h)h]TÇ]úhQhoTÀ*ìkQloTÄ*ÁQQllT6?kQQVlTaTTQQVlQAÁTQQlhQBÁTQOlhQâÁhTOhhQÁÁh])TlQhVUS)TlQTÇ5S)MoQTÂ1P)QlQTÂ",
"waterFlow95": "0g0galËÚDAÚGŒeCåRCó%EEeK;RE?%EGRIc%1i)QlTmi1n)h?TÀn1l)h?TÀ[1h)h]TÇ]úhQhoTÀ*ìkQloTÄ*ÁQQllT6?kQQVlTaTTQQVlQAÁTQQlhQBÁTQOlhQâÁhTOhhQÁÁh])TlQhVUS)TlQTÇ5S)MoQTÂ1P)QlQTÂ",
"waterFlow96": "0g0gaIc%DAÚGŒeCó%E?%EGRK;RlËÚCåREEe1iOMkOMl1kOMkOmlÞlîh*MnlÖpîh*Mÿ.åhîh)Mÿ.FhOhkMþ.ÁhOhkMÿïhjOhkMS*hjOhýMQ*MjOhýMÇaMOOhpOÇaMOOphMúahMOphMúúhòO.pMhaú(O.pMMü1NOìkMMü",
"waterFlow97": "0g0gaIc%DAÚGŒeCó%E?%EGRK;RlËÚCåREEe1iOMkOMl1kOMkOmlÞlîh*MnlÖpîh*Mÿ.åhîh)Mÿ.FhOhkMþ.ÁhOhkMÿïhjOhkMS*hjOhýMQ*MjOhýMÇaMOOhpOÇaMOOphMúahMOphMúúhòO.pMhaú(O.pMMü1NOìkMMü",
"waterFlow98": "0g0gaIc%DAÚGŒeCó%E?%EGRK;RlËÚCåREEe1iOMkOMl1kOMkOmlÞlîh*MnlÖpîh*Mÿ.åhîh)Mÿ.FhOhkMþ.ÁhOhkMÿïhjOplM[.hjOhaMR.MOOhaMPaMOOphOÇúMOOphMúúhMOphMúúhòO.pMhaú(O.pMMü1NOìkMMü",
"waterFlow99": "0g0gaIc%DAÚGŒeCó%E?%EGRK;RlËÚCåREEe1iOMkOMl1kOMkOmlÞlîh*MnlÖpîh*Mÿ.åhîh)Mÿ.FhOhkMþ.ÁhOhkMÿïhjOplM[.hjOhaMR.MOOhaMPaMOOphOÇúMOOphMúúhMOphMúúhòO.pMhaú(O.pMMü1NOìkMMü",
"waterFlow100": "0g0gaIc%DAÚCó%GŒeCåRE?%EEeEGRK;RlËÚ1zyTlxxÒ1jyxlyxn1lyxlyonúnRhDxpnðmRhDxÖCþhRhBxÖC+hyhlxÕCÞhyhlxÖ[hiyhlxÀDhiyhÔxVDxiyhÔxãÓxyyhmyãÓxyyChxÎÓhxymhxÎÎh@yCmxhÓÎwyCmxxÒ",
"waterFlow101": "0g0gaIc%DAÚCó%GŒeCåRE?%EEeEGRK;RlËÚ1zyTlxxÒ1jyxlyxn1lyxlyonúnRhDxpnðmRhDxÖCþhRhBxÖC+hyhlxÕCÞhyhlxÐ[hiyhlxÀDhiyhÔxVDxiyhÔxãÓxyyhmyãÓxyymhxÎÓhxymhxÎÎh@yCmxhÓÎwyCmxxÒ",
"waterFlow102": "0g0gaIc%DAÚCó%GŒeCåRE?%EEeEGRK;RlËÚ1zyTlxxÒ1jyxlyxn1lyxlyonúnRhDxpnðmRhDxÖCþhRhBxÖC+hyhlxÕCÞhyhlxÖ[hiymnxÇChiyhÓxÃCxyyhÓxÄÓxyymhyãÎxyymhxÎÎhxymhxÎÎh@yCmxhÓÎwyCmxxÒ",
"waterFlow103": "0g0gaIc%DAÚCó%GŒeCåRE?%EEeEGRK;RlËÚ1zyTlxxÒ1jyxlyxn1lyxlyonúnRhDxpnðmRhDxÖCþhRhBxÖC+hyhlxÕCÞhyhlxÖ[hiymnxÇChiyhÓxÃCxyyhÓxÄÓxyymhyãÎxyymhxÎÎhxymhxÎÎh@yCmxhÓÎwyCmxxÒ",
"waterFlow104": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚCåRIc%K;R1zywghxgMzywjhxgTlywjixgÎgyxjimgÎ0ßwliogï1ywBx9wShygBx6x(hygkxoB02ygkxoägiyh4x3AhiyhÃx0Ahiyg5x1jxiyg0xhliyyg1xhgiyyl1xhh2xyBghhh",
"waterFlow105": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚCåRIc%K;R1zywghxgMzywjhxgTlywjixgÎgyxjimgÎ0ßwliogï1ywBx9wShygBx6x(hygkxoB02ygkxoägiyh4x3AhiyhÃx0Ahiyg5x1jxiyg0xhliyyg1xhgiyyl1xhh2xyBghhh",
"waterFlow106": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚCåRIc%K;R1zywghxgMzywjhxgTlywjixgÎgyxjimgÎ0ßwlyogï1ywBx9wShygBx6x(hygkxoB02ygkxoähiyh3x8BhiyhVx5Bxiyg5x0gxiyg0yhgiyyg1xhgiyyl1xhh2xyBghhh",
"waterFlow107": "0g0gaEEeDAÚCó%E?%GŒeEGRlËÚCåRIc%K;R1zywghxgMzywjhxgTlywjixgÎgyxjimgÎ0ßwliogï1ywBx9wShygBx6x(hygkxoB02ygkxoähiyh3x8BhiyhVx5Bxiyg5x0gxiyg0yhgiyyg1xhgiyyl1xhh2xyBghhh",
"waterFlow108": "0g0gaEEeCó%DAÚEGRE?%GŒelËÚCåRIc%K;R1ihjwyyy2khgwyiwRkhgAyiwÂzhgAxiwÏwhiAxCwÏ0ÞgzxEwî2hgji9gÀyhwji6iSyhwBiEj01hwBiEäwxhy5i4lyxhy)i0lyxhw3i2Aixhw0iyzxhhw2iywxhhz2iyy",
"waterFlow109": "0g0gaEEeCó%DAÚEGRE?%GŒelËÚCåRIc%K;R1ihjwyyy2khgwyiwRkhgAyiwÂzhgAxiwÏwhiAxCwÏ0ÞgzxEwî2hgji9gÀyhwji6iSyhwBiEj01hwBiEäwxhy5i4lyxhy)i0lyxhw3i2Aixhw0iyzxhhw2iywxhhz2iyy",
"waterFlow110": "0g0gaEEeCó%DAÚEGRE?%GŒelËÚCåRIc%K;R1ihjwyyy2khgwyiwRkhgAyiwÂzhgAxiwÏwhiAxCwÏ0ÞgzxEwî2hgji9gÀyhwji6iSyhwBiEj01hwBiEäyxhy4i8jyxhyOi3jixhw3i0wixhw0hywxhhw2iywxhhz2iyy",
"waterFlow111": "0g0gaEEeCó%DAÚEGRE?%GŒelËÚCåRIc%K;R1ihjwyyy2khgwyiwRkhgAyiwÂzhgAxiwÏwhiAxCwÏ0ÞgzxEwî2hgji9gÀyhwji6iSyhwBiEj01hwBiEäyxhy4i8jyxhyOi3jixhw3i0wixhw0hywxhhw2iywxhhz2iyy",
"waterFlow112": "0g0gaEGRCó%GŒeDAÚEEeE?%CåRK;RlËÚIc%1hhi3jOOTjhiQOOOTkhiQOMO>khl(OM)3khg(MO)ÃOhk)MNOU>Îj)M*jÂ>hkkONj2>hkgONj?>hkNO*iSMMkNj(Ô)MMkRj(o)MMkBj)pOMMkwjONMMhkUjO*Thhl3jO)",
"waterFlow113": "0g0gaEGRCó%GŒeDAÚEEeE?%CåRK;RlËÚIc%1hhi3jOOTjhiQOOOTkhiQOMO>khl(OM)3khg(MO)ÃOhk)MNOU>Îj)M*jÂ>hkkONj2>hkgONj?>hkNO*iSMMkNj(Ô)MMkRj(o)MMkBj)pOMMkwjONMMhkUjO*Thhl3jO)",
"waterFlow114": "0g0g8EGRCó%GŒeDAÚEEeE?%CåRK;R4J^cGlXE^úGlXi^úGÉõi|ÎGÊci]ÎþNeE{ÞþaE;_Þÿ_EN{MGôaN{xGôþN{Ög^ìþ{ÕG,ÞJÊIg^ÚJÊUgaÚJ{SGnÒJ{EG?XJ|cGN",
"waterFlow115": "0g0g8EGRCó%GŒeDAÚEEeE?%CåRK;R4J^cGlXE^úGlXi^úGÉõi|ÎGÊci]ÎþNeE{ÞþaE;_Þÿ_EN{MGôaN{xGôþN{Ög^ìþ{ÕG,ÞJÊIg^ÚJÊUgaÚJ{SGJÒJ{EG?XJ|cGN",
"waterFlow116": "0g0gaEEeCó%E?%EGRDAÚGŒeCåRK;RlËÚIc%1hhi)kQSMhhl)kQQ1khl0QQQ1ghl0QTQ4ghi>QTS)ghj>TQSAQhgST?Qw4ÎkSTRkB4hggQ?k*4hgjQ?k24hg?QRl3TTg?k>ÔSTTg5k>oSTTgÂkSpQTTgÃkQ?TThgwkQR",
"waterFlow117": "0g0gaEEeCó%E?%EGRDAÚGŒeCåRK;RlËÚIc%1hhi)kQSMhhl)kQQ1khl0QQQ1ghl0QTQ4ghi>QTS)ghj>TQSAQhgST?Qw4ÎkSTRkB4hggQ?k*4hgjQ?k24hg?QRl3TTg?k>ÔSTTg5k>oSTTgÂkSpQTTgÃkQ?TThgwkQR",
"waterFlow118": "0g0g8EEeCó%E?%EGRDAÚGŒeCåRK;R4J^ÝIwÑJ|ÝIA4i|2PA4í|2]Ñgí^÷]KÝí_÷pwÂR]ípÑS{{íoõUR]yP{áR]&P{8R]þ]öeo]üiSíiKkiöJiKÐidJi]EIyði]SIz",
"waterFlow119": "0g0g8EEeCó%E?%EGRDAÚGŒeCåRK;R4J^ÝIwÑJ|ÝIA4i|2PA4í|2]Ñgí^÷]KÝí_÷pwÂR]ípÑS{{íoõUR]yP{áR]&P{8R]þ]öeo]üiSíiKkiöJiKÐidJi]EIyði]SIz",
"waterFlow120": "0g0gaDAÚCó%E?%Ic%EEeGŒeCåREGRlËÚK;R1h1i)g1iThhiÀgh4Áhhjwg10Á1hjS010Á0hÒS011wghÏ4000Aghi4100ß0hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04Õ21giRg0Õ41giJg0p0hgiñg0o",
"waterFlow121": "0g0gaDAÚCó%E?%Ic%EEeGŒeCåREGRlËÚK;R1h1i)ghiThhiÀgh4Áhhjwg10Á1hjS010Á0hÒS011wghÏ4000Aghi4100ß0hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04Õ21giRg0Õ41giJg0p0hgiñg0o",
"waterFlow122": "0g0gaDAÚCó%E?%Ic%EEeGŒeCåREGRlËÚK;R1hgi)h1lThhiÀgh4Áhhjwg10Á1hjS010Á0hÒS011wghÏ4000Aghi4100ß0hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04Õ411i?g7Õ411iJg4j011iñg0l",
"waterFlow123": "0g0gaDAÚCó%E?%Ic%EEeGŒeCåREGRlËÚK;R1hgi)h1lThhiÀgh4Áhhjwg10Á1hjS010Á0hÒS011wghÏ4000Aghi4100ß0hk0170?SKk01Qg]Sgk41Qg]Tgkn0Qk31gg?0Qo51gk?04Õ411i?g7Õ411iJg4j011iñg0l",
"waterFlow124": "0g0gaDAÚCó%E?%lËÚEGRGŒeIc%EEeCåRK;R011i)g0l1h1iÔg1iÞhhiÀgh7Áhhmwg10Á1hmÝ010Á0hïÝ011wghí7000Dghi7100R0hn0140âÝën01GgàÝgn71GgàÞgnk0Gn61ggâ0Gj51gnâ07î21gißg0î71giJg0p",
"waterFlow125": "0g0gaDAÚCó%E?%lËÚEGRGŒeIc%EEeCåRK;R011i)g0l1h1iÔg1iÞhhiÀgh7Áhhmwg10Á1hmÝ010Á0hïÝ011wghí7000Dghi7100R0hn0140âÝën01GgàÝgn71GgàÞgnk0Gn61ggâ0Gj51gnâ07î21gißg0î71giJg0p",
"waterFlow126": "0g0gaDAÚCó%E?%lËÚEGRIc%EEeGŒeCåRK;R0hgi)g0j1hgiÄh1nÎhhiÝgh6Þhhlwg10Þ1hlK010Þ0hñK011wghí6000Cghi6100R0hm0140ÔKëm01ÓgÐKgm61ÓgÐÎgmk0Óm51ggÔ0Ój71gmÔ06î611iÔg4î611iJg6l",
"waterFlow127": "0g0gaDAÚCó%E?%lËÚEGRIc%EEeGŒeCåRK;R0hgi)g0j1hgiÄh1nÎhhiÝgh6Þhhlwg10Þ1hlK010Þ0hñK011wghí6000Cghi6100R0hm0140ÔKëm01ÓgÐKgm61ÓgÐÎgmk0Óm51ggÔ0Ój71gmÔ06î611iÔg4î611iJg6l",
lavaFlow:"0g0g100W",
"lavaFlow0": "0g0gxI(ZIgYI0YIwY?ÞWleZ?>WlcYJSZ?ÐYo?ZL2YirY?ìH?rHN>WleYoiYoîZ?úH?LW?ÃHJÁWJÀZ?ÎWNiYNOWoGHNyZoüWrOWoCHSBZ0gîcw4kÎi0Jô(1|cNe;Ñ3410c?Â{(k;Ý28({d*VÀ(0wgõd(cwTQ0BûÆgíËC1hKR4MkcwìË(>0gíc@74wîÆ0ícwíÊOA0gpÖ5î8(TÎ(04g5Úzþ8oÅÎMS8wþ;Ãëd[nwÅÇwgîww0À0SÇîòQE3ckKB)hwgÃåR34hiklücwît+08w?cÆqcgShXLcgÆ45n80n*ðn|Ýk",
"lavaFlow1": "0g0gxI(ZIgYI0YIwY?ÞWleZ?>WlcYJSZ?ÐYo?ZL2YirY?ìH?rHN>WleYoiYoîZ?úH?LW?ÃHJÁWJÀZ?ÎWNiYNOWoGHNyZoüWrOWoCHSBZ0gîcw4kÎi0Jô(1|cNe;Ñ3410c?Â{(k;Ý28({d*VÀ(0wgõd(cwTQ0BûÆgíËC1hKR4MkcwìË(>0gíc@74wîÆ0ícwíÊOA0gpÖ5î8(TÎ(04g5Úzþ8oÅÎMS8wþ;Ãëd[nwÅÇwgîww0À0SÇîòQE3ckKB)hwgÃåR34hiklücwît+08w?cÆqcgShXLcgÆ45n80n*ðn|Ýk",
"lavaFlow2": "0g0gxI(ZIgYI0YIwY?ÞWleZ?>WlcYJSZ?ÐYo?ZL2YirY?ìH?rHN>WleYoiYoîZ?úH?LW?ÃHJÁWJÀZ?ÎWNiYNOWoGHNyZoüWrOWoCHSBZ0gîcw4kÎi0Jô(1|cNe;Ñ3410c?Â{(k;Ý28({d*VÀ(0wgõd(cwTQ0BûÆgíËC1hKR4MkcwìË(>0gíc@74wîÆ0ícwíÊOA0gpÖ5î8(TÎ(04g5Úzþ8oÅÎMS8wþ;Ãëd[nwÅÇwgîww0À0SÇîòQE3ckKB)hwgÃåR34hiklücwît+08w?cÆqcgShXLcgÆ45n80n*ðn|Ýk",
"lavaFlow3": "0g0gxI(ZIgYI0YIwY?ÞWleZ?>WlcYJSZ?ÐYo?ZL2YirY?ìH?rHN>WleYoiYoîZ?úH?LW?ÃHJÁWJÀZ?ÎWNiYNOWoGHNyZoüWrOWoCHSBZ0gîcw4kÎi0Jô(1|cNe;Ñ3410c?Â{(k;Ý28({d*VÀ(0wgõd(cwTQ0BûÆgíËC1hKR4MkcwìË(>0gíc@74wîÆ0ícwíÊOA0gpÖ5î8(TÎ(04g5Úzþ8oÅÎMS8wþ;Ãëd[nwÅÇwgîww0À0SÇîòQE3ckKB)hwgÃåR34hiklücwît+08w?cÆqcgShXLcgÆ45n80n*ðn|Ýk",
"lavaFlow4": "0g0gtIwYJÀZ?LWJÁWI0Y?ÞWleZI(ZIgY?ÎWNyZlcY?ìHN>WoCH??WL2YleYoîZ?ÐYJSZ?úH?ÃH?rHoàZNiYoüWoGHo?Z0QN4ÎEiOko/8àaBNþigKx?ÀsEÂCOAÔ0cNííÂjX14ckÐëOC8SmIPÏÃC*^8^ÇìEhÝ0C18ók1/8ëByC80A018^8â%fäUKw01EO0eHÆTwENlÔw0;AO4ÛJôfooàAD(hRlRLR02gØoÞìcãiÝ0eO+Kh0e6á061gù07]?qÀ3",
"lavaFlow5": "0g0gtIwYJÀZ?LWJÁWI0Y?ÞWleZI(ZIgY?ÎWNyZlcY?ìHN>WoCH??WL2YleYoîZ?ÐYJSZ?úH?ÃH?rHoàZNiYoüWoGHo?Z0QN4ÎEiOko/8àaBNþigKx?ÀsEÂCOAÔ0cNííÂjX14ckÐëOC8SmIPÏÃC*^8^ÇìEhÝ0C18ók1/8ëByC80A018^8â%fäUKw01EO0eHÆTwENlÔw0;AO4ÛJôfooàAD(hRlRLR02gØoÞìcãiÝ0eO+Kh0e6á061gù07]?qÀ3",
"lavaFlow6": "0g0gtIwYJÀZ?LWJÁWI0Y?ÞWleZI(ZIgY?ÎWNyZlcY?ìHN>WoCH??WL2YleYoîZ?ÐYJSZ?úH?ÃH?rHoàZNiYoüWoGHo?Z0QN4ÎEiOko/8àaBNþigKx?ÀsEÂCOAÔ0cNííÂjX14ckÐëOC8SmIPÏÃC*^8^ÇìEhÝ0C18ók1/8ëByC80A018^8â%fäUKw01EO0eHÆTwENlÔw0;AO4ÛJôfooàAD(hRlRLR02gØoÞìcãiÝ0eO+Kh0e6á061gù07]?qÀ3",
"lavaFlow7": "0g0gtIwYJÀZ?LWJÁWI0Y?ÞWleZI(ZIgY?ÎWNyZlcY?ìHN>WoCH??WL2YleYoîZ?ÐYJSZ?úH?ÃH?rHoàZNiYoüWoGHo?Z0QN4ÎEiOko/8àaBNþigKx?ÀsEÂCOAÔ0cNííÂjX14ckÐëOC8SmIPÏÃC*^8^ÇìEhÝ0C18ók1/8ëByC80A018^8â%fäUKw01EO0eHÆTwENlÔw0;AO4ÛJôfooàAD(hRlRLR02gØoÞìcãiÝ0eO+Kh0e6á061gù07]?qÀ3",
"lavaFlow8": "0g0gpI(ZlcYoCH?rHIwY?ÎWJÀZ?ÞWJSZJÁW?LWIgY?ìHleYL2YleZNiY?ÐYI0Y?úHN>WNyZ?ÃH??WNOW0QNgëF÷ía9yUVüO/{V(d2L0BõØíriLùqÂqÝrî)ëhzÖRú!oÀRhßFi.E0Tnyt0ÎiÝh7.BAU$ÎëÀgo4CElc2?RoE/AQ16Aÿw4JÖhS(hÇ0>sëy1/VÐûUûGÑÆ0ÎHKALåGK-ÓëANamKh}õaRhÿìj3ìÔ÷i2gså?N%ÑÎk20d",
"lavaFlow9": "0g0gpI(ZlcYoCH?rHIwY?ÎWJÀZ?ÞWJSZJÁW?LWIgY?ìHleYL2YleZNiY?ÐYI0Y?úHN>WNyZ?ÃH??WNOW0QNgëF÷ía9yUVüO/{V(d2L0BõØíriLùqÂqÝrî)ëhzÖRú!oÀRhßFi.E0Tnyt0ÎiÝh7.BAU$ÎëÀgo4CElc2?RoE/AQ16Aÿw4JÖhS(hÇ0>sëy1/VÐûUûGÑÆ0ÎHKALåGK-ÓëANamKh}õaRhÿìj3ìÔ÷i2gså?N%ÑÎk20d",
"lavaFlow10": "0g0gpI(ZlcYoCH?rHIwY?ÎWJÀZ?ÞWJSZJÁW?LWIgY?ìHleYL2YleZNiY?ÐYI0Y?úHN>WNyZ?ÃH??WNOW0QNgëF÷ía9yUVüO/{V(d2L0BõØíriLùqÂqÝrî)ëhzÖRú!oÀRhßFi.E0Tnyt0ÎiÝh7.BAU$ÎëÀgo4CElc2?RoE/AQ16Aÿw4JÖhS(hÇ0>sëy1/VÐûUûGÑÆ0ÎHKALåGK-ÓëANamKh}õaRhÿìj3ìÔ÷i2gså?N%ÑÎk20d",
"lavaFlow11": "0g0gpI(ZlcYoCH?rHIwY?ÎWJÀZ?ÞWJSZJÁW?LWIgY?ìHleYL2YleZNiY?ÐYI0Y?úHN>WNyZ?ÃH??WNOW0QNgëF÷ía9yUVüO/{V(d2L0BõØíriLùqÂqÝrî)ëhzÖRú!oÀRhßFi.E0Tnyt0ÎiÝh7.BAU$ÎëÀgo4CElc2?RoE/AQ16Aÿw4JÖhS(hÇ0>sëy1/VÐûUûGÑÆ0ÎHKALåGK-ÓëANamKh}õaRhÿìj3ìÔ÷i2gså?N%ÑÎk20d",
"lavaFlow12": "0g0gn?LW?ÞWNyZIwYIgYJÁWI(ZJÀZJSZleY?úHoàZ?ìHleZ?ÎW?rHlcY??WNiYI0YNOWL2YN>W0QhùX9{Ot9Nþ1õÓ!aÓ)dOëhe?9knhiM8Ð!aXKr@^ANÞýy4K0õIqCzöJ4gÎùXÃAkùiTñMý8]U?cI8o><eÁ?4dhMC>seQoMcLîIOpIsiTENèd4Xow?)-Óp{iI@AANgîp?ãgowÂióiÐhàM>8oÄICgAMA%çóÓwÛjjÐc*",
"lavaFlow13": "0g0gn?LW?ÞWNyZIwYIgYJÁWI(ZJÀZJSZleY?úHoàZ?ìHleZ?ÎW?rHlcY??WNiYI0YNOWL2YN>W0QhùX9{Ot9Nþ1õÓ!aÓ)dOëhe?9knhiM8Ð!aXKr@^ANÞýy4K0õIqCzöJ4gÎùXÃAkùiTñMý8]U?cI8o><eÁ?4dhMC>seQoMcLîIOpIsiTENèd4Xow?)-Óp{iI@AANgîp?ãgowÂióiÐhàM>8oÄICgAMA%çóÓwÛjjÐc*",
"lavaFlow14": "0g0gn?LW?ÞWNyZIwYIgYJÁWI(ZJÀZJSZleY?úHoàZ?ìHleZ?ÎW?rHlcY??WNiYI0YNOWL2YN>W0QhùX9{Ot9Nþ1õÓ!aÓ)dOëhe?9knhiM8Ð!aXKr@^ANÞýy4K0õIqCzöJ4gÎùXÃAkùiTñMý8]U?cI8o><eÁ?4dhMC>seQoMcLîIOpIsiTENèd4Xow?)-Óp{iI@AANgîp?ãgowÂióiÐhàM>8oÄICgAMA%çóÓwÛjjÐc*",
"lavaFlow15": "0g0gn?LW?ÞWNyZIwYIgYJÁWI(ZJÀZJSZleY?úHoàZ?ìHleZ?ÎW?rHlcY??WNiYI0YNOWL2YN>W0QhùX9{Ot9Nþ1õÓ!aÓ)dOëhe?9knhiM8Ð!aXKr@^ANÞýy4K0õIqCzöJ4gÎùXÃAkùiTñMý8]U?cI8o><eÁ?4dhMC>seQoMcLîIOpIsiTENèd4Xow?)-Óp{iI@AANgîp?ãgowÂióiÐhàM>8oÄICgAMA%çóÓwÛjjÐc*",
"lavaFlow16": "0g0gpleZJÀZI(Z?úHJÁWIwY?LW?ÎW??W?ÞWIgYlcYJSZNOW?rHNiYN>WNyZI0YL2YleY?ìH?ÐY?ÃH?>W0RxùC(4x8oNÀßÐE-QÁAôKL2üR8ABgxÏ{JöÔ-QÿëPiüI0?Çÿ8ëIúÄiC?0nMü?!Snlw0iyd?c6(i{8óCXDMoßIQPÑc0jr8ÏkðiCcM&ÑCx9+*Ucac$üCú÷ÖïÈúõÁÆC5RiQù1BJÄæaB!RIìIÁ!OÌFuyßLï/Cá{ká@x9z",
"lavaFlow17": "0g0gpleZJÀZI(Z?úHJÁWIwY?LW?ÎW??W?ÞWIgYlcYJSZNOW?rHNiYN>WNyZI0YL2YleY?ìH?ÐY?ÃH?>W0RxùC(4x8oNÀßÐE-QÁAôKL2üR8ABgxÏ{JöÔ-QÿëPiüI0?Çÿ8ëIúÄiC?0nMü?!Snlw0iyd?c6(i{8óCXDMoßIQPÑc0jr8ÏkðiCcM&ÑCx9+*Ucac$üCú÷ÖïÈúõÁÆC5RiQù1BJÄæaB!RIìIÁ!OÌFuyßLï/Cá{ká@x9z",
"lavaFlow18": "0g0gpleZJÀZI(Z?úHJÁWIwY?LW?ÎW??W?ÞWIgYlcYJSZNOW?rHNiYN>WNyZI0YL2YleY?ìH?ÐY?ÃH?>W0RxùC(4x8oNÀßÐE-QÁAôKL2üR8ABgxÏ{JöÔ-QÿëPiüI0?Çÿ8ëIúÄiC?0nMü?!Snlw0iyd?c6(i{8óCXDMoßIQPÑc0jr8ÏkðiCcM&ÑCx9+*Ucac$üCú÷ÖïÈúõÁÆC5RiQù1BJÄæaB!RIìIÁ!OÌFuyßLï/Cá{ká@x9z",
"lavaFlow19": "0g0gpleZJÀZI(Z?úHJÁWIwY?LW?ÎW??W?ÞWIgYlcYJSZNOW?rHNiYN>WNyZI0YL2YleY?ìH?ÐY?ÃH?>W0RxùC(4x8oNÀßÐE-QÁAôKL2üR8ABgxÏ{JöÔ-QÿëPiüI0?Çÿ8ëIúÄiC?0nMü?!Snlw0iyd?c6(i{8óCXDMoßIQPÑc0jr8ÏkðiCcM&ÑCx9+*Ucac$üCú÷ÖïÈúõÁÆC5RiQù1BJÄæaB!RIìIÁ!OÌFuyßLï/Cá{ká@x9z",
"lavaFlow20": "0g0grJSZI0Y?ÎWNiYNOWlcY?ÞWleZNyZleYI(Z?úHIwY?ìH??WIgYJÁWJÀZ?rH?LWoîZ?ÃHN>WoüWL2Y?ÐYoàZ0RxùD/icERÈüCaëØUCE[Þþ6MøíAiGI3ÑgM^3kIcKôÓLA?ëkL|RÃ?l/PÈ_^eEbLdGQF_ÐeõUÉ+FÖ!nl4$A4B5ëIoi!%ùö6FúØ2s&ÄÆcONO3isFÕIÌ5EliNSFDKÆSÐ8jkE00ÏCcE!Âl5G$cÄÒjcÏi3u{æCÊ×Á|rÓ}Ù",
"lavaFlow21": "0g0grJSZI0Y?ÎWNiYNOWlcY?ÞWleZNyZleYI(Z?úHIwY?ìH??WIgYJÁWJÀZ?rH?LWoîZ?ÃHN>WoüWL2Y?ÐYoàZ0RxùD/icERÈüCaëØUCE[Þþ6MøíAiGI3ÑgM^3kIcKôÓLA?ëkL|RÃ?l/PÈ_^eEbLdGQF_ÐeõUÉ+FÖ!nl4$A4B5ëIoi!%ùö6FúØ2s&ÄÆcONO3isFÕIÌ5EliNSFDKÆSÐ8jkE00ÏCcE!Âl5G$cÄÒjcÏi3u{æCÊ×Á|rÓ}Ù",
"lavaFlow22": "0g0grJSZI0Y?ÎWNiYNOWlcY?ÞWleZNyZleYI(Z?úHIwY?ìH??WIgYJÁWJÀZ?rH?LWoîZ?ÃHN>WoüWL2Y?ÐYoàZ0RxùD/icERÈüCaëØUCE[Þþ6MøíAiGI3ÑgM^3kIcKôÓLA?ëkL|RÃ?l/PÈ_^eEbLdGQF_ÐeõUÉ+FÖ!nl4$A4B5ëIoi!%ùö6FúØ2s&ÄÆcONO3isFÕIÌ5EliNSFDKÆSÐ8jkE00ÏCcE!Âl5G$cÄÒjcÏi3u{æCÊ×Á|rÓ}Ù",
"lavaFlow23": "0g0grJSZI0Y?ÎWNiYNOWlcY?ÞWleZNyZleYI(Z?úHIwY?ìH??WIgYJÁWJÀZ?rH?LWoîZ?ÃHN>WoüWL2Y?ÐYoàZ0RxùD/icERÈüCaëØUCE[Þþ6MøíAiGI3ÑgM^3kIcKôÓLA?ëkL|RÃ?l/PÈ_^eEbLdGQF_ÐeõUÉ+FÖ!nl4$A4B5ëIoi!%ùö6FúØ2s&ÄÆcONO3isFÕIÌ5EliNSFDKÆSÐ8jkE00ÏCcE!Âl5G$cÄÒjcÏi3u{æCÊ×Á|rÓ}Ù",
"lavaFlow24": "0g0gvI0YIwYI(ZleZNOWoCH??WoLZoGH?ìH?rH?ÞW?ÐY?úHJÀZNyZJSZJÁW?ÎWIgYlcYleY?LW?>WNiYoüWN>WoàZoîZ?ÃHoiY0QNkIpkùdT80EME_ixRyÆíxEyjî7a|N?gXwëÓo?Úßoe8RëRrNùôÙ?c?õ2lÐ}kioÎ?ØÕõERALpgš^Ée6ÎgÎPòg_Ðx01ÀXFë(àXgó%iÒgIyÕT(etCÿâïLXI(ðaIDh5êko0óL83({Å&Xx8}8Cx82l4O-O0þGdllmDÇT",
"lavaFlow25": "0g0gvI0YIwYI(ZleZNOWoCH??WoLZoGH?ìH?rH?ÞW?ÐY?úHJÀZNyZJSZJÁW?ÎWIgYlcYleY?LW?>WNiYoüWN>WoàZoîZ?ÃHoiY0QNkIpkùdT80EME_ixRyÆíxEyjî7a|N?gXwëÓo?Úßoe8RëRrNùôÙ?c?õ2lÐ}kioÎ?ØÕõERALpgš^Ée6ÎgÎPòg_Ðx01ÀXFë(àXgó%iÒgIyÕT(etCÿâïLXI(ðaIDh5êko0óL83({Å&Xx8}8Cx82l4O-O0þGdllmDÇT",
"lavaFlow26": "0g0gvI0YIwYI(ZleZNOWoCH??WoLZoGH?ìH?rH?ÞW?ÐY?úHJÀZNyZJSZJÁW?ÎWIgYlcYleY?LW?>WNiYoüWN>WoàZoîZ?ÃHoiY0QNkIpkùdT80EME_ixRyÆíxEyjî7a|N?gXwëÓo?Úßoe8RëRrNùôÙ?c?õ2lÐ}kioÎ?ØÕõERALpgš^Ée6ÎgÎPòg_Ðx01ÀXFë(àXgó%iÒgIyÕT(etCÿâïLXI(ðaIDh5êko0óL83({Å&Xx8}8Cx82l4O-O0þGdllmDÇT",
"lavaFlow27": "0g0gvI0YIwYI(ZleZNOWoCH??WoLZoGH?ìH?rH?ÞW?ÐY?úHJÀZNyZJSZJÁW?ÎWIgYlcYleY?LW?>WNiYoüWN>WoàZoîZ?ÃHoiY0QNkIpkùdT80EME_ixRyÆíxEyjî7a|N?gXwëÓo?Úßoe8RëRrNùôÙ?c?õ2lÐ}kioÎ?ØÕõERALpgš^Ée6ÎgÎPòg_Ðx01ÀXFë(àXgó%iÒgIyÕT(etCÿâïLXI(ðaIDh5êko0óL83({Å&Xx8}8Cx82l4O-O0þGdllmDÇT",
"lavaFlow28": "0g0gxI0YIgYJÁW?ÞW?úH?rHI(ZleZ?ìH?LWIwY?ÃHoiYSBZrOWNyZNiYoîZJÀZNOWJSZ?ÎWoüWlcY?ÐYN>W?>WoCHL2YleYirYoGHo?Z0gîgÁìoß6oú^00[$IhAlX4s1003%iaPN@pAì]C@ARó0Cü9?VkNëECëog1UÞ49ÀioÒ6og1lÎiVßQoú>]ÏXÎ1ðoiíÁþ[w*jMS14215ãAVÁrÝg1o080ÔÅU?>o06SCSä2ü]xóECñ{AJFS@gC1F@ÍáÎhgc9]g141?80VogNKùSEÎ?E2ìånAììó0cíEKLEdðÀÞðEC0",
"lavaFlow29": "0g0gxI0YIgYJÁW?ÞW?úH?rHI(ZleZ?ìH?LWIwY?ÃHoiYSBZrOWNyZNiYoîZJÀZNOWJSZ?ÎWoüWlcY?ÐYN>W?>WoCHL2YleYirYoGHo?Z0gîgÁìoß6oú^00[$IhAlX4s1003%iaPN@pAì]C@ARó0Cü9?VkNëECëog1UÞ49ÀioÒ6og1lÎiVßQoú>]ÏXÎ1ðoiíÁþ[w*jMS14215ãAVÁrÝg1o080ÔÅU?>o06SCSä2ü]xóECñ{AJFS@gC1F@ÍáÎhgc9]g141?80VogNKùSEÎ?E2ìånAììó0cíEKLEdðÀÞðEC0",
"lavaFlow30": "0g0gxI0YIgYJÁW?ÞW?úH?rHI(ZleZ?ìH?LWIwY?ÃHoiYSBZrOWNyZNiYoîZJÀZNOWJSZ?ÎWoüWlcY?ÐYN>W?>WoCHL2YleYirYoGHo?Z0gîgÁìoß6oú^00[$IhAlX4s1003%iaPN@pAì]C@ARó0Cü9?VkNëECëog1UÞ49ÀioÒ6og1lÎiVßQoú>]ÏXÎ1ðoiíÁþ[w*jMS14215ãAVÁrÝg1o080ÔÅU?>o06SCSä2ü]xóECñ{AJFS@gC1F@ÍáÎhgc9]g141?80VogNKùSEÎ?E2ìånAììó0cíEKLEdðÀÞðEC0",
"lavaFlow31": "0g0gxI0YIgYJÁW?ÞW?úH?rHI(ZleZ?ìH?LWIwY?ÃHoiYSBZrOWNyZNiYoîZJÀZNOWJSZ?ÎWoüWlcY?ÐYN>W?>WoCHL2YleYirYoGHo?Z0gîgÁìoß6oú^00[$IhAlX4s1003%iaPN@pAì]C@ARó0Cü9?VkNëECëog1UÞ49ÀioÒ6og1lÎiVßQoú>]ÏXÎ1ðoiíÁþ[w*jMS14215ãAVÁrÝg1o080ÔÅU?>o06SCSä2ü]xóECñ{AJFS@gC1F@ÍáÎhgc9]g141?80VogNKùSEÎ?E2ìånAììó0cíEKLEdðÀÞðEC0",
"lavaFlow32": "0g0gsIwYI(Z?ÎWJSZI0YlcYIgY?ÞW?úH?rHleYJÀZ?LWleZN>WoCHrOWoiYL2Y?ÐYNOWJÁW?ìH??W?ÃHNyZoîZ?>W0Q(ëìpRMX6weáAÓa÷lewxíl<ëÑyëPC18G|3<og÷c-0m?18h*õÄPi004oc×þiÇiÝXÎocb?cEoëEOÐSõA#9ìÁO%?ônIwMù3y÷.?CAð82í4E/4wùë]R2g3Èi02cJ×E41S8Kb/EÚô1ÙÇIKoeddÀëRl{S5ÿ10Ïg-÷ig0#",
"lavaFlow33": "0g0gsIwYI(Z?ÎWJSZI0YlcYIgY?ÞW?úH?rHleYJÀZ?LWleZN>WoCHrOWoiYL2Y?ÐYNOWJÁW?ìH??W?ÃHNyZoîZ?>W0Q(ëìpRMX6weáAÓa÷lewxíl<ëÑyëPC18G|3<og÷c-0m?18h*õÄPi004oc×þiÇiÝXÎocb?cEoëEOÐSõA#9ìÁO%?ônIwMù3y÷.?CAð82í4E/4wùë]R2g3Èi02cJ×E41S8Kb/EÚô1ÙÇIKoeddÀëRl{S5ÿ10Ïg-÷ig0#",
"lavaFlow34": "0g0gsIwYI(Z?ÎWJSZI0YlcYIgY?ÞW?úH?rHleYJÀZ?LWleZN>WoCHrOWoiYL2Y?ÐYNOWJÁW?ìH??W?ÃHNyZoîZ?>W0Q(ëìpRMX6weáAÓa÷lewxíl<ëÑyëPC18G|3<og÷c-0m?18h*õÄPi004oc×þiÇiÝXÎocb?cEoëEOÐSõA#9ìÁO%?ônIwMù3y÷.?CAð82í4E/4wùë]R2g3Èi02cJ×E41S8Kb/EÚô1ÙÇIKoeddÀëRl{S5ÿ10Ïg-÷ig0#",
"lavaFlow35": "0g0gsIwYI(Z?ÎWJSZI0YlcYIgY?ÞW?úH?rHleYJÀZ?LWleZN>WoCHrOWoiYL2Y?ÐYNOWJÁW?ìH??W?ÃHNyZoîZ?>W0Q(ëìpRMX6weáAÓa÷lewxíl<ëÑyëPC18G|3<og÷c-0m?18h*õÄPi004oc×þiÇiÝXÎocb?cEoëEOÐSõA#9ìÁO%?ônIwMù3y÷.?CAð82í4E/4wùë]R2g3Èi02cJ×E41S8Kb/EÚô1ÙÇIKoeddÀëRl{S5ÿ10Ïg-÷ig0#",
"lavaFlow36": "0g0gtIwYI0YIgYI(ZJSZNOWoîZNyZJÀZJÁW?úH?ÞW?ìH??W?ÎW?LW?rHleYNiYleZoGH?>WlcYN>WL2YoüW?ÐY?ÃHoCH0SwõïMiícI0LMõzqðýEK9og*wqA?H0g?pq4acE*NoReL?eoMúiÀi-E4ÈiNdL×?(02Sh4FãRNcëÐw09nQRCIJrP6?GÖoëìIhVeaMi8üMN?Âýgë0on(dÁÂJúXwåië44T60daîþùc4À2w#remâìfwíw1?SQììè<Xweà",
"lavaFlow37": "0g0gtIwYI0YIgYI(ZJSZNOWoîZNyZJÀZJÁW?úH?ÞW?ìH??W?ÎW?LW?rHleYNiYleZoGH?>WlcYN>WL2YoüW?ÐY?ÃHoCH0SwõïMiícI0LMõzqðýEK9og*wqA?H0g?pq4acE*NoReL?eoMúiÀi-E4ÈiNdL×?(02Sh4FãRNcëÐw09nQRCIJrP6?GÖoëìIhVeaMi8üMN?Âýgë0on(dÁÂJúXwåië44T60daîþùc4À2w#remâìfwíw1?SQììè<Xweà",
"lavaFlow38": "0g0gtIwYI0YIgYI(ZJSZNOWoîZNyZJÀZJÁW?úH?ÞW?ìH??W?ÎW?LW?rHleYNiYleZoGH?>WlcYN>WL2YoüW?ÐY?ÃHoCH0SwõïMiícI0LMõzqðýEK9og*wqA?H0g?pq4acE*NoReL?eoMúiÀi-E4ÈiNdL×?(02Sh4FãRNcëÐw09nQRCIJrP6?GÖoëìIhVeaMi8üMN?Âýgë0on(dÁÂJúXwåië44T60daîþùc4À2w#remâìfwíw1?SQììè<Xweà",
"lavaFlow39": "0g0gtIwYI0YIgYI(ZJSZNOWoîZNyZJÀZJÁW?úH?ÞW?ìH??W?ÎW?LW?rHleYNiYleZoGH?>WlcYN>WL2YoüW?ÐY?ÃHoCH0SwõïMiícI0LMõzqðýEK9og*wqA?H0g?pq4acE*NoReL?eoMúiÀi-E4ÈiNdL×?(02Sh4FãRNcëÐw09nQRCIJrP6?GÖoëìIhVeaMi8üMN?Âýgë0on(dÁÂJúXwåië44T60daîþùc4À2w#remâìfwíw1?SQììè<Xweà",
"lavaFlow40": "0g0gpJÀZI0YJSZI(Z?ÞWoàZ?rH?úHIgYlcYIwYL2Y?>W?ÎWleYJÁW?ìH?LWleZ?ÐYNiYN>WNyZNOW??W0RxõïMkìõOÀÀX0_ÎðR0RRëMò3p6ltob}]?EÁuziiSIà}ö{o?^^22lÇIöJMõXÝXOgSß@MdeòA5x]ÕüchdkEýEÐ0i,$íhz5C|ÕñbQÑqgxiF;û:g%a÷)jmàûÔF^ÃlìEiÞhBw!ùwT5R0üï84ô]ScÜííìGL-AÓdRq2ïcô",
"lavaFlow41": "0g0gpJÀZI0YJSZI(Z?ÞWoàZ?rH?úHIgYlcYIwYL2Y?>W?ÎWleYJÁW?ìH?LWleZ?ÐYNiYN>WNyZNOW??W0RxõïMkìõOÀÀX0_ÎðR0RRëMò3p6ltob}]?EÁuziiSIà}ö{o?^^22lÇIöJMõXÝXOgSß@MdeòA5x]ÕüchdkEýEÐ0i,$íhz5C|ÕñbQÑqgxiF;û:g%a÷)jmàûÔF^ÃlìEiÞhBw!ùwT5R0üï84ô]ScÜííìGL-AÓdRq2ïcô",
"lavaFlow42": "0g0gpJÀZI0YJSZI(Z?ÞWoàZ?rH?úHIgYlcYIwYL2Y?>W?ÎWleYJÁW?ìH?LWleZ?ÐYNiYN>WNyZNOW??W0RxõïMkìõOÀÀX0_ÎðR0RRëMò3p6ltob}]?EÁuziiSIà}ö{o?^^22lÇIöJMõXÝXOgSß@MdeòA5x]ÕüchdkEýEÐ0i,$íhz5C|ÕñbQÑqgxiF;û:g%a÷)jmàûÔF^ÃlìEiÞhBw!ùwT5R0üï84ô]ScÜííìGL-AÓdRq2ïcô",
"lavaFlow43": "0g0gpJÀZI0YJSZI(Z?ÞWoàZ?rH?úHIgYlcYIwYL2Y?>W?ÎWleYJÁW?ìH?LWleZ?ÐYNiYN>WNyZNOW??W0RxõïMkìõOÀÀX0_ÎðR0RRëMò3p6ltob}]?EÁuziiSIà}ö{o?^^22lÇIöJMõXÝXOgSß@MdeòA5x]ÕüchdkEýEÐ0i,$íhz5C|ÕñbQÑqgxiF;û:g%a÷)jmàûÔF^ÃlìEiÞhBw!ùwT5R0üï84ô]ScÜííìGL-AÓdRq2ïcô",
"lavaFlow44": "0g0gm?úHJÀZleZIwYJÁW?LWI(ZIgYI0YJSZ?ÎW?ÞW?>W?ìH??WNiYleY?rHN>WNyZlcYL2Y0RwõïMkàB?^gÐpÙijOpÚqeÞE&äõ0EC-LÑùoNõEòÓRNDòÐqJoaC/ë2iÚ4?TíîÆkRiREhÐpáF2K4ÑòÂÐpÞ!?eAÔÆ{OE)(oxõi9íKlTNieëaÀ{GhJMjûÀScÖ/ýJSoúÐÃFÖgcIq?UöÏ%2ÎAO1xRsI9ðÞXAiLcciÆkàkE",
"lavaFlow45": "0g0gm?úHJÀZleZIwYJÁW?LWI(ZIgYI0YJSZ?ÎW?ÞW?>W?ìH??WNiYleY?rHN>WNyZlcYL2Y0RwõïMkàB?^gÐpÙijOpÚqeÞE&äõ0EC-LÑùoNõEòÓRNDòÐqJoaC/ë2iÚ4?TíîÆkRiREhÐpáF2K4ÑòÂÐpÞ!?eAÔÆ{OE)(oxõi9íKlTNieëaÀ{GhJMjûÀScÖ/ýJSoúÐÃFÖgcIq?UöÏ%2ÎAO1xRsI9ðÞXAiLcciÆkàkE",
"lavaFlow46": "0g0gm?úHJÀZleZIwYJÁW?LWI(ZIgYI0YJSZ?ÎW?ÞW?>W?ìH??WNiYleY?rHN>WNyZlcYL2Y0RwõïMkàB?^gÐpÙijOpÚqeÞE&äõ0EC-LÑùoNõEòÓRNDòÐqJoaC/ë2iÚ4?TíîÆkRiREhÐpáF2K4ÑòÂÐpÞ!?eAÔÆ{OE)(oxõi9íKlTNieëaÀ{GhJMjûÀScÖ/ýJSoúÐÃFÖgcIq?UöÏ%2ÎAO1xRsI9ðÞXAiLcciÆkàkE",
"lavaFlow47": "0g0gm?úHJÀZleZIwYJÁW?LWI(ZIgYI0YJSZ?ÎW?ÞW?>W?ìH??WNiYleY?rHN>WNyZlcYL2Y0RwõïMkàB?^gÐpÙijOpÚqeÞE&äõ0EC-LÑùoNõEòÓRNDòÐqJoaC/ë2iÚ4?TíîÆkRiREhÐpáF2K4ÑòÂÐpÞ!?eAÔÆ{OE)(oxõi9íKlTNieëaÀ{GhJMjûÀScÖ/ýJSoúÐÃFÖgcIq?UöÏ%2ÎAO1xRsI9ðÞXAiLcciÆkàkE",
"lavaFlow48": "0g0golcY?ÞW?úHI(ZIwYI0YL2YleZleY?ìHJÀZJSZ?ÎW?LWIgYJÁWNyZNiY?rH?>W??WNOWN>WoîZ0QhùÎ9aÁAo^þBúöp^nhSÇ^RFùji?öœxÊÁò[Õðîï>Þ6?(îyðAi>E÷haAßiDC>Ý}kRKb}cïzPacgGE2RgDûo(eIEUMù(ÕÙJ.jbmMdÕo&Lgîæ?(ì~rqn5LbLq8ÏrAMXRQì@i0Fgr;gCëÝöÐwc7úñCmRhI]ÈkGÐÆNÂMÐ",
"lavaFlow49": "0g0golcY?ÞW?úHI(ZIwYI0YL2YleZleY?ìHJÀZJSZ?ÎW?LWIgYJÁWNyZNiY?rH?>W??WNOWN>WoîZ0QhùÎ9aÁAo^þBúöp^nhSÇ^RFùji?öœxÊÁò[Õðîï>Þ6?(îyðAi>E÷haAßiDC>Ý}kRKb}cïzPacgGE2RgDûo(eIEUMù(ÕÙJ.jbmMdÕo&Lgîæ?(ì~rqn5LbLq8ÏrAMXRQì@i0Fgr;gCëÝöÐwc7úñCmRhI]ÈkGÐÆNÂMÐ",
"lavaFlow50": "0g0golcY?ÞW?úHI(ZIwYI0YL2YleZleY?ìHJÀZJSZ?ÎW?LWIgYJÁWNyZNiY?rH?>W??WNOWN>WoîZ0QhùÎ9aÁAo^þBúöp^nhSÇ^RFùji?öœxÊÁò[Õðîï>Þ6?(îyðAi>E÷haAßiDC>Ý}kRKb}cïzPacgGE2RgDûo(eIEUMù(ÕÙJ.jbmMdÕo&Lgîæ?(ì~rqn5LbLq8ÏrAMXRQì@i0Fgr;gCëÝöÐwc7úñCmRhI]ÈkGÐÆNÂMÐ",
"lavaFlow51": "0g0golcY?ÞW?úHI(ZIwYI0YL2YleZleY?ìHJÀZJSZ?ÎW?LWIgYJÁWNyZNiY?rH?>W??WNOWN>WoîZ0QhùÎ9aÁAo^þBúöp^nhSÇ^RFùji?öœxÊÁò[Õðîï>Þ6?(îyðAi>E÷haAßiDC>Ý}kRKb}cïzPacgGE2RgDûo(eIEUMù(ÕÙJ.jbmMdÕo&Lgîæ?(ì~rqn5LbLq8ÏrAMXRQì@i0Fgr;gCëÝöÐwc7úñCmRhI]ÈkGÐÆNÂMÐ",
"lavaFlow52": "0g0gr?ÎW?ÞW?rH?úHIgYI(ZJSZIwYI0Y?ìHlcYNOWJÀZJÁW?LWleY??W?>WNyZleZ?ÐYNiYoàZN>WoîZoiYL2Y0QxùcMiîXI]UiAI9kî$Î_aLA&/g>4cFgàG21ÀãkD/8íhóÀaoBïxjãXO.^-iÓQNkHÔx}I{?-Nkó÷8iÂE5ÁiIhlcSàayùRÀkìgLÃA,AÝcùñ]ÆÃüe#rzAO32ÓXe:Ê20%bÆ7AeF8ÂGFéURiûTÌ3a*lÌþlï;?gt÷LóßsI",
"lavaFlow53": "0g0gr?ÎW?ÞW?rH?úHIgYI(ZJSZIwYI0Y?ìHlcYNOWJÀZJÁW?LWleY??W?>WNyZleZ?ÐYNiYoàZN>WoîZoiYL2Y0QxùcMiîXI]UiAI9kî$Î_aLA&/g>4cFgàG21ÀãkD/8íhóÀaoBïxjãXO.^-iÓQNkHÔx}I{?-Nkó÷8iÂE5ÁiIhlcSàayùRÀkìgLÃA,AÝcùñ]ÆÃüe#rzAO32ÓXe:Ê20%bÆ7AeF8ÂGFéURiûTÌ3a*lÌþlï;?gt÷LóßsI",
"lavaFlow54": "0g0gr?ÎW?ÞW?rH?úHIgYI(ZJSZIwYI0Y?ìHlcYNOWJÀZJÁW?LWleY??W?>WNyZleZ?ÐYNiYoàZN>WoîZoiYL2Y0QxùcMiîXI]UiAI9kî$Î_aLA&/g>4cFgàG21ÀãkD/8íhóÀaoBïxjãXO.^-iÓQNkHÔx}I{?-Nkó÷8iÂE5ÁiIhlcSàayùRÀkìgLÃA,AÝcùñ]ÆÃüe#rzAO32ÓXe:Ê20%bÆ7AeF8ÂGFéURiûTÌ3a*lÌþlï;?gt÷LóßsI",
"lavaFlow55": "0g0gr?ÎW?ÞW?rH?úHIgYI(ZJSZIwYI0Y?ìHlcYNOWJÀZJÁW?LWleY??W?>WNyZleZ?ÐYNiYoàZN>WoîZoiYL2Y0QxùcMiîXI]UiAI9kî$Î_aLA&/g>4cFgàG21ÀãkD/8íhóÀaoBïxjãXO.^-iÓQNkHÔx}I{?-Nkó÷8iÂE5ÁiIhlcSàayùRÀkìgLÃA,AÝcùñ]ÆÃüe#rzAO32ÓXe:Ê20%bÆ7AeF8ÂGFéURiûTÌ3a*lÌþlï;?gt÷LóßsI",
"lavaFlow56": "0g0gvIwY?LWoîZ?ÐY?ÞWJSZNyZlcYI(ZIgYI0Y?úHleY?ìH?ÎWleZJÀZ?ÃHJÁW?rHL2YN>WoüWNiY?>WoGHoàZrOWoCH??WirY0QN0cMküì!!?Ó18EkC*9ÞuQCbßUCIcAëë0ì2üJù5RUC.ISk8w02üCð|ßh/&SÀ09*80gÞc(ÀÔy$oÀ1z=Õ3FD4ÃüùXy8äiÂ&âgN01GIÈò1#jA00îçßrFSÉÑXëf3SÝA8áa2üe1>BRgzcC.fRUëyQå÷[ÅaruSxLMaAxi",
"lavaFlow57": "0g0gvIwY?LWoîZ?ÐY?ÞWJSZNyZlcYI(ZIgYI0Y?úHleY?ìH?ÎWleZJÀZ?ÃHJÁW?rHL2YN>WoüWNiY?>WoGHoàZrOWoCH??WirY0QN0cMküì!!?Ó18EkC*9ÞuQCbßUCIcAëë0ì2üJù5RUC.ISk8w02üCð|ßh/&SÀ09*80gÞc(ÀÔy$oÀ1z=Õ3FD4ÃüùXy8äiÂ&âgN01GIÈò1#jA00îçßrFSÉÑXëf3SÝA8áa2üe1>BRgzcC.fRUëyQå÷[ÅaruSxLMaAxi",
"lavaFlow58": "0g0gvIwY?LWoîZ?ÐY?ÞWJSZNyZlcYI(ZIgYI0Y?úHleY?ìH?ÎWleZJÀZ?ÃHJÁW?rHL2YN>WoüWNiY?>WoGHoàZrOWoCH??WirY0QN0cMküì!!?Ó18EkC*9ÞuQCbßUCIcAëë0ì2üJù5RUC.ISk8w02üCð|ßh/&SÀ09*80gÞc(ÀÔy$oÀ1z=Õ3FD4ÃüùXy8äiÂ&âgN01GIÈò1#jA00îçßrFSÉÑXëf3SÝA8áa2üe1>BRgzcC.fRUëyQå÷[ÅaruSxLMaAxi",
"lavaFlow59": "0g0gvIwY?LWoîZ?ÐY?ÞWJSZNyZlcYI(ZIgYI0Y?úHleY?ìH?ÎWleZJÀZ?ÃHJÁW?rHL2YN>WoüWNiY?>WoGHoàZrOWoCH??WirY0QN0cMküì!!?Ó18EkC*9ÞuQCbßUCIcAëë0ì2üJù5RUC.ISk8w02üCð|ßh/&SÀ09*80gÞc(ÀÔy$oÀ1z=Õ3FD4ÃüùXy8äiÂ&âgN01GIÈò1#jA00îçßrFSÉÑXëf3SÝA8áa2üe1>BRgzcC.fRUëyQå÷[ÅaruSxLMaAxi",
"lavaFlow60": "0g0gxirYI(ZleZ?ìHIwYJSZ?rHN>W?>WleYIgY?ÞWoGHoîZ?úH?LWlcYI0Y?ÃHJÁWJÀZ?ÎWNiYNOWoCHNyZoüW?ÐYoiYL2Yo?ZRBYoLZ0gîgT@síQEiIgÐd-S~t0ÁQRëg?J;STkCSgNSkEô5kj{CÁÀlQ%NúERKhk^À?X4CÁggÀFkQ{kÁhkÁÀÑl4CÄÊüiQRóUNTECRK?ûQÒüUNì?kÃsxìgsUkCþkQQlgT;iì|ÁaÞkQgcñÙ?ìkC÷åíiECJ8,øhkQSOT?iígDlgCì%ÃûgRýEjLQgUdVU.S~4CQhg_8Xk5Gt",
"lavaFlow61": "0g0gxirYI(ZleZ?ìHIwYJSZ?rHN>W?>WleYIgY?ÞWoGHoîZ?úH?LWlcYI0Y?ÃHJÁWJÀZ?ÎWNiYNOWoCHNyZoüW?ÐYoiYL2Yo?ZRBYoLZ0gîgT@síQEiIgÐd-S~t0ÁQRëg?J;STkCSgNSkEô5kj{CÁÀlQ%NúERKhk^À?X4CÁggÀFkQ{kÁhkÁÀÑl4CÄÊüiQRóUNTECRK?ûQÒüUNì?kÃsxìgsUkCþkQQlgT;iì|ÁaÞkQgcñÙ?ìkC÷åíiECJ8,øhkQSOT?iígDlgCì%ÃûgRýEjLQgUdVU.S~4CQhg_8Xk5Gt",
"lavaFlow62": "0g0gxirYI(ZleZ?ìHIwYJSZ?rHN>W?>WleYIgY?ÞWoGHoîZ?úH?LWlcYI0Y?ÃHJÁWJÀZ?ÎWNiYNOWoCHNyZoüW?ÐYoiYL2Yo?ZRBYoLZ0gîgT@síQEiIgÐd-S~t0ÁQRëg?J;STkCSgNSkEô5kj{CÁÀlQ%NúERKhk^À?X4CÁggÀFkQ{kÁhkÁÀÑl4CÄÊüiQRóUNTECRK?ûQÒüUNì?kÃsxìgsUkCþkQQlgT;iì|ÁaÞkQgcñÙ?ìkC÷åíiECJ8,øhkQSOT?iígDlgCì%ÃûgRýEjLQgUdVU.S~4CQhg_8Xk5Gt",
"lavaFlow63": "0g0gxirYI(ZleZ?ìHIwYJSZ?rHN>W?>WleYIgY?ÞWoGHoîZ?úH?LWlcYI0Y?ÃHJÁWJÀZ?ÎWNiYNOWoCHNyZoüW?ÐYoiYL2Yo?ZRBYoLZ0gîgT@síQEiIgÐd-S~t0ÁQRëg?J;STkCSgNSkEô5kj{CÁÀlQ%NúERKhk^À?X4CÁggÀFkQ{kÁhkÁÀÑl4CÄÊüiQRóUNTECRK?ûQÒüUNì?kÃsxìgsUkCþkQQlgT;iì|ÁaÞkQgcñÙ?ìkC÷åíiECJ8,øhkQSOT?iígDlgCì%ÃûgRýEjLQgUdVU.S~4CQhg_8Xk5Gt",
barrelTopOpen: "0g0g8ìàHòûZaiWÒNYÖ>WQIW-ùZ$ÝY5AÂ?AÀ}]iúILÂ[ÚGgxN:GšlyÁnZZo?ÂnZZTÈ}RZZTTyZZZZÏÂZZZZÏÂRZZTÈ}nZZTTxnZZo?Â:GšlyÂ[ÚGgy&@iÎgp5AÂ?AÀ",
barrelBottom: "0g0g6ìàHòûZUnZÖ>WÒNYåÐH02P0ùPFgtggÁ$J]00o!PiúQú&ë4Aùpkó$CiÕki{AìÕaFAJPheë0AJÖ)J?CÁÆ)01AJÕFBkJPgcJ{0SÖcaQCûÇalÈÛlÀ4ù04ù0",
barrelSide: "0g0gaaiWòûZÒNYUnZìàHQSY(EYEìZåÐHÖ>W10101010i1i1i1i1j1>1R1>4ÄVVVÓÒÒÄGGÓGGGGG>]î]î]í]ih>h2h3Tp1i19k9Ti4p1P4jhj8p1>4jhj]>hj8ihÓÒVÄÄÓÒÓGGÓGGGGG>]î]î]î]Rki1Rki1>QRQ>Q>Q",
barrelTop: "0g0g7ìàHòûZaiWÒNYÖ>WåOYÇÒY5AÂ?AÀ}]iúILÂS9A9xN29AxyÀyP]CyÀCh]yA{Ch]CìwJÁ]CCÀNi]ACÀLi]AÈ|0ÂACTwkÂACyÂ4iAxyÂS9A9y&@iÎgp5AÂ?AÀ",
barrelSW: "0g0gaìàHEìZ(EYòûZQSYaiWUnZÒNYÖ>WåÐH01zOO1>*ÔÎCÔñÎCà31wVÃ1?V0úPùOú>*3JSO(JS*GÏ@IãÏ@à51>VÃ1?V3úzOOú>*0ú>0Vúw*ÔÎCÕñÎDà31BVO1BV0úF03ú>*3úzOVúw*ÔÎ[ÓðÞ@à51zO01?V3úzOOúw*",
chainSW: "0g0g4000AeZ<lWP@Hr5EÙi4w]C9KAeÕmIx8gXÏÆBò0000000000000000000000000000000000000000",
endStoneBricks: "0g0g8ioYŒlWRNYRoZEñHnAHK.HlÇH4CJÚCQcJÉCJÛÓJ?Ae},l|eGÛGGÚ)eÕHûÜslÕvZZgZiî0AùcA|CIëGJAE|kJPAA?cJ?)GÚiLJEnRLCÚsš~mTHgZsîZZëÙ4J1A",
beeNestTop: "0g0g5éRYccHS)HikHTGH0ë]0i09AL|Aùa]CóPha2S4úhalAJyA!pAJTg%p1yTha9cðTha9c@yA!91yzg%pAJzh!lAúzha2PAùAaPkúPg9ALPCù0i0A21",
beeNestSide: "0g0gbTGHS)HLýWikHccHéRYOnHiÿWHÓZC6HÚ>Y0h0001h01hg01hhgyyxhyNyz?VUQVQQVhg01hhhhyhhhyyhiONyyzNxzVUQ?VVVVyÓyyÓÓÓyyyzONCÏyOOOOOOOOVVVVVVVVOOOOO,GOñà-IGGGGIaIIòIIIEEEEEEEE",
beeNestFrontHoney: "0g0ghS)HTGHikHLýWÚ>YÎzWÞNZòüHoMHoúHC6HšrYTßYiÿWZœZéRYHÓZ00gXx8Rh8x000Xx02wXToiMë0oiMõÏxaÂgXx8ÃoO82g000{XCno0000oLýe>gXxõRgüG(Rx]RùXxei%CoiMë006l)>oXxõ0005ëÐgXx8RgXx8RFaÐ;Cx8RgXÖùXARjQ?8R×JGFeØÈLgeíþI9^ÂüÐT^xLi)Xx8RgX",
beeNestFront: "0g0gdS)HTGHikHLýWÚ>YÎzWÞNZòüHÀIYC6HiÿWéRYHÓZ01hhhhyh00hh0ihxOO(0OzONQVQQQ?Óâgh001ÕIÞ(000OýVûyyOyyýQy?QUQQæyCOO(00/EzNyO0000OyyyyyyyyUÄØUQQQQDIñy!!yydVÇEEEEEIURaaa?a[C!QQQQQ",
beeNestBottom: "0g0g5Ú>YåÃHHÓZC6HiÿW0ë]0i09AL|Aùa]CóPha2S4úhalAJyA!pAJTg%p1yTha9cðTha9c@yA!91yzg%pAJzh!lAúzha2PAùAaPkúPg9ALPCù0i0A21",
beehiveSide: "0g0g8GVZiãWòcYE*HÒRZéîHasHóEY4JPAJ]TG00+iS+h1E2JI%J?AòAJPAüòAJPAüeGLÚGngÚGlÚgCClÚõ5AÓh0A;CK0AA4eÚGlÚýCJ}AJ?A0N00teëqdGnJ?ÑJ?Ñ",
beehiveFrontHoney: "0g0gdGVZiãWýLWE*HÒRZéîHICYo(YšcZCkZóEYZ*ZZÿZ1hhhhhhgwO(003O2w3O00O02QUQVQVQQ@ÔIGñÔñÑRyyyyyDAÀ2OOO(ù5È9O00hùcÀ900hhù5RaaaaaaAÀhiGôxh4ÇaaaHaaýÁhhpôhhl^03.703CÃ(0N3OO*QUVQQV?Q",
beehiveFront: "0g0g8GVZiãWýLWE*HÒRZéîHCkZóEY4JPAJ]TG00+iS+h1E2JI%J?AòAJPAüòAJPAüCClÚõ5HÓh0A<CK0AA5ôÚGlÚüCJCúiQgÚGlÚgCJ}AJ|A0N00teëqdGnJ?ÑJ?Ñ",
beehiveEnd: "0g0g5GVZiãWE*HCkZýLW4JPAJ]FwaS0úF4L001w4ë10úFw00A1N,zÚIpwù9AJTECë00hE0000ú%A0PA?N+?úi?wJ]0JTE0jÖ0h%C0]0pF)004a4JPAJ]",
honeycomb:"0g0g6000O?HTßYoMHšrYlCY00900000Âw0002aQù00iAÄ!00iLÞgS6ÄòdIS6+eÚDS5CËeG02gËEIS0Ç$},S2ilÛ,S2ilúi00UAÛÀ00bÙãë0005C00000000",
honeycombBlock: "0g0g6?NWo(YZ*ZšcZICYZÿZ5+Ñ5GKEiI$iIÓ]ÂÓ]Âß]!ßS×ÓSØÑ2Œ$û]$ÿ{ïÈQïÈÑìCAìdA5GQ5NÑ$Rò$iI@SÂQ]ÂÏ0!Ï]!Ñ0ØÓSØ$û]cÿ{5ÈAíLÑ1DAì,A",
honeyBlockTop: "0g0g6sKeZ3ÜZ*RSÔLšcRTIe0Jò]JL4CòùEõ5AÑ!LKXcAXawQJúJ]4?AK00yFS00]Â!]0JRÁ^S4JiòÂ1xAü^À0PFAÎù2^ÚCQëRaej4íQRPa12QL|px2mL{ic",
honeyBlockSide: "0g0g6šcRZ3ÜTIeSÔLZ*RsKe0kAXôP4GN÷g0y,zXìÖiNcXôÕ4h0CL%4ìÚG]?C056]]kpxgôTw3xykP4ÉÕ0þûXJ%C)aßi]1gzÛ@?JRÐÚilðiÑöûAw0{ùîx0ÉÕ",
honeyBlockBottom: "0g0g5šeNZ3wsKCORwnkK02T9C94CA|GIAClÞ)ù%A?Ö+L9G?öGûFIAJ+ídIA×Cíd@?÷+3|GAJ)3di?öGRPIAöëRÚi?Ö0Ã|+?Õ2j8Cù0JawXJS4LAw3ÖCk",
glowLichen: "0g0g6000ß]HßnZÚSYÎLZEGZ5(0Ï4he(0cCCùÂë9hŒ1gh0(gÙxo0C000UKk000ëdëk2Shë0jc0së04lë0KC0120Q-h1ùA9Æë0w41G0KÆ0c030Szë4>1ì4K0A",
inkSac: "0g0ga000)lWúcZH-WP4Y-?HÎñWåÿWoÐWVÄH00000000000000000000000000000hg000001zx000000iT000001?Á0000hmáÆ000hÔGüë001ÓGåQë001ÇþÑ]0000oÇAë00000Ië000000000000000000000000000",
glowInkSac: "0g0gc000l?WúcZH-WoIWlIH&ÇY/lWîtWhGZNóW_çY00000000000000000000000000000hg000001zx000000ik000001Ák0000hmâk000hðGýS001dGåeS004Äägk0000QráS00000QS000000000000000000000000000",
glowItemFrameIcon: "0g0gl000AJHOÇYl8HGðWúsWìyYIlZcíZåiYCBWâûWoýY?bYZZZZ]WZoYCnY)eYilHýNY0000000000000000000000001800000ðx8>gðxõë0iÂücF^ÂùC0óÐt8^eÐFK0óîañ:ÊágC0iãMrØCIdK0óã=|áÆIúK0iã=}ôuIùC0iãNÂûNIdK4iîIñ:oàFK4?Qt9Rf^hK1kREóÁ8RFK1ÄVüeÈigeK0000000000",
glowItemFrameWood: "0g0g7l8HilYlEZEGHGdHDÄHCCW4AJ9Aî0ÿ80ùAw2cJi3ãgãgËEaAüP2KwoÐXë1ùí_0jALlãLLr92ÂPAX40cùIzSaAAa4LgãllGÀA4PQiA9cëgPNgÐ0IALRÉGËG",
glowItemFrame: "0g0gfEJW(EY)iZAíWÞ2YåiYìyYýNYIlZcíZoýYZ]WZoYZTH)EY1iyyxhhjkQQQ?U?TmVVÑ[ãÔÎBÓIaÇIÓÁAAóÐóÐòÎBAEggEòTCóeH?GÐÏCógJNgÐÂCógJNgÐÏkóeH?GÐRlAEggEòÂlAóÐóÐðÂlåIýaIGÏlÔâU[ÒVTkQ@ÑÓ?ÓÁ1uhhyyyg",
coarseDirt: "0g0g)GlZýGYýCYåÃYÀ?YË2Z(ìHSeZÒzWÀ?HÚOHïXWÒþHÆrYclW{LHQeZU?YaGYÞ>YúCYúCHU?H]iWÚGZ;cYQEW-cYâ>HVVHâ>YòüHG5YÒjWòXWÞOHUrYéÐZìáWÞ>HÎiZQiWdOWGlYeSHÎðWìàZÇjH)úY{LWâÃYðoH0gîc11kMîs20ci^cedc13-j|0rk8ÁIwÞ>Ak34hh4?Âd(Icë>ÀrlÆh>5ßAdÄ>dCTcmJ*hIkNI0(IâNh0,NEglX(8}EI6P>c(Ta?ÃeÝkCÀÕcO[cq>u>>c(oE1lsghES1cr1{>3ü(I4o?GpÀ)ÀJdÝ>CNDA->eóLd*nH(Tnbnc4l4;SkKJwN?sÝT4NìiÊIggI|MJ",
"oxidizedCutCopper": "0g0g8ÜpZÈIW<oHÂAY}ÆH*ýWÂñYÌÐW42a0ùRdgBe]OdRBdJšfHtf,nrèL:,g/ÓLhhy&@ON.yÄlÚVÉV0íR02aq{?i|qeè?qÚLdsn%Rn.œn%HrpOahRBMINNÖBd#VP#Â",
"oxidizedCopper": "0g0g8ÜpZÈIW}dWÂñY=6Y}ÆH.gY.ýH0g802A4üRADr4ÂEEeÛ6iÇFgv9GÁ|ÄndDPBDc5CPB)R5kò|cÍ4üú%in5ióAcÌ9CúB/CdGI{Lj$Ä?VMÅ+IÇâan9Å×Güþ:ÚSZRs",
"weatheredCutCopper": "0g0g8æ?YÓdHÖiHã*H÷nWÛVZÓñHPiH02a40R%IGi.De_gh?!qJgfÅ,rÈo:Ôg:Ôqr|E,ÖD+irÍSZËHl0íR40^O.y+ÚEdh!NÖßlRcN?Smœn+Go:ËvnÅv/gyOÖDOLlPLL",
"weatheredCopper": "0g0g8æ?YÓdHÓñHÛVZ÷nWã*HÖiHPiH0g]02A9+PÀþr8Â^ùeÛe?RïlemJa|lÍ9iÂÚ#L8JJÖ.L4üaPgÍ0C?|An5DzQíC9DlÑAÌ9Lû?AjcÈcÂxÅm?^úrcmLÂúüN/RSZRs",
"exposedCutCopper": "0g0g8j-WG7HéIHA+YýLWdLWÞïWæÓY42^42iMam!OCs?CgACel&mI&m?È6ÇÌ&]æ+iæLitMÂo_BGÇÚþ0íR0g^mÆ^hamM^ÏL?ÄaÃmu?CNACe?ÏáaÓM!Ûœl!FÅiI%þ?%J",
"exposedCopper": "0g0g8j-WG7HýLWdLWA+YéIHåýHæÓY0g]02^dinÛpÛg=^Ñhrh?ÂOIÌeãaJAodi_ÚUÒdNÉ×cd9OrViÌ9AlEäNciAÂRJeQlÑgljil%GBk/?ÙhollxÑIEaOcMBÚ+lEGle",
"cutCopper": "0g0g6?6ZlOYcÑWeXHIlHa>Y42a4ëR&1tFIng8ýc@AgQci)Oe*2Mc5%D2dÐ2%-B%SyÄlÚVÉV0íR4ë^Mg2(8Ld-yw@J9Ily)a&0aMGi(6OdD5w,y%-Bd#VP#Â",
wetSponge: "0g0g4K)YEsZ÷OHþCH6ûhN>TEÑiICScÊsûn:lLléÉÁdSYü7RËgneLITeÿQ[GæpÚÞ?L#,SXlsûÉ?ÅùÈ3ùËÅ",
sponge: "0g0g5K)YCOYisZGGZ?ïW0iî8CQÀA2$4SÎliCQJx0ù^@3F82ë41ì440CC0C0ÕChÁCk0RiK+ÂRS2RNJw0i9CX0Gó?0ChCg?Ð08D2]4Áwwpi4û!0òiNC]Cû",
quartzBricks: "0g0g6SHZŒöYREHRaZ?éWnÙY0000019GIACüdJP%AaQJÉP+n?GI%J{dJPÙJ{dGJAþnE_ÙþlÑ0S0TÀë%SJPk?PÀaAhJPkPBÀJÙLÉPÀJBkJPklÚUûÚiÇEÇAG?%",
campfire: "0g0gh000ErWIEWNìYR*HTEY{rHZZYiãWGVZ)cYCkZËyYýLWâÐHúiWa?Y00000000000000080000000018S00000002gS00000043gí0000004>oí000000IÑwig00001cXF6w0000KIÒ.4j000cXC[-ùüE01õïCDEÀGdS1Aüg÷àLþeS1AIpKçAÐ.S1c7.rÐoO<S2ücF^ÂücFS0000000000",
campfireLogLit:"0g0g100W",
campfireLog: "0g0gfúiWâÐHa?YËyY{rHGVZiãW000ýLWCkZ$LWsíYoÎZ.BZVñY0gy1gywgjQOg11)T2x11OM10Qhw0hhQQÄÒGGGGGGÕþGGGGGGÖòGGGGGGýaGGGGGGe?Lo?EHELhehGRelelReeEnENeLheeŒLLleohheeeHGeiolHLhehGRelelReeEnE",
campfireFire:"0g0g100W",
campfireLogSW: "0g0gf$LW.BZCkZiãWGVZ{rHúiWâÐHVñYsíYýLWa?YËyYoÎZ00011ggz)Äãggì9RcÉipú1a!zçÅú?ppy)GÄëùo1rrG?h11grrÔ?98ùArrÓãúùpgrrÔÔ9?0arrèÔg1ú9rrèã8ò0ërrèØ11ggrrGçggì9rrÄ?púúarrÅÄ1ùggrrÄÅ9?0arrÄã",
campfireLogLitSW:"0g0g100W",
campfireFire0: "0g0g8000IEWNìYErWR*HoSYTEYZZY00^w0000LQ0000CX0000LI0006I]E006ÂV0002DVg004ÛLÄ00r|LRh0#EJih1?Cli01aÓ?(01g+LG00.+AC01dgrÂS0nWZ^S",
campfireFire1: "0g0g8000ErWNìYIEWoSYR*HTEYZZY008w0000ÁK0000ÉQ0000^xë000iB(000cPC000oeCS02rELS0mlEÂ00gCgN00aÚLE00megÏ00*ÛLo01eãLDS1?GGLSeÉYZÆh",
campfireFire2: "0g0g8000ErWoSYR*HIEWNìYTEYZZY00À000001K00004wë000bC0000Bðg001!EJ009ÌVi003ÃÖh00oaÛk00j#JÐ003!Ú?00jÃÚ?00]aÚÐ00CNJR02+sJE01<YŠGS",
campfireFire3: "0g0g8000IEWErWNìYTEYoSYR*HZZY00100000010000gT0000h8C000AÒC004rGg00#GLC00zGak002ÛgN000ögÈS04ÛLiS0zElÑ00tGgÂ00nAli02n)Aù02OWšU0",
campfireFire4: "0g0g8000ErWIEWNìYoSYR*HTEYZZY0000000000ë00019w000aPC000AÚg00kRGë00pÚlC005BGA000CE-ë01BJüS02DGC004EGi00lelC00nâL)00dGš?01PYZÈS",
campfireFire5: "0g0g8000ErWIEWNìYR*HoSYTEYZZY0000000018ë0002%w000b|C002AÚ000k?Õë00kNCi002RÐL00aeGü004÷eù000Ëúg002r?g002rúC004oJE00lGšL00eWZLS",
campfireFire6: "0g0g8000IEWNìYErWR*HoSYTEYZZY0000000004ë00098ë006iBë006U|E006U$C00+CBþ00)U?E000|]ë000jòE006ÄGE002Ùýg00/ÓJù00lãrD00r,tL00.HšÄ0",
campfireFire7: "0g0g8000IEWNìYErWR*HTEYoSYZZY0004ë000aAë000^S0000Lw0006{{g000iQ(006ABë002UòE000tò+00+t?m00-ãaC00lGam01acû(00OcR(00<LSg01aHsÏ0",
campfireLogLit0: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHýNZIEWNìYR*H$lZwJZ-úHgÁH$LW.BZVñYTEY0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB@ÇLiùX0qoAOÂJlÐwa^ÑBePõlAc2üLwR>ÊiahxõÐB[:ÂsýOìóÔ@PÂüîm5õcXd×^OkqCXÁpB_AJCGgõAýdàÈÄa@(õyXi^^LCC6X{oc#ÂÁk-IõdoQ?)BoqCXÏÖ@6XÎ8ig",
campfireLogLit1: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHIEWNìYR*H$lZwJZýNZgÁH$LW-úH.BZVñYTEY0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB@PLGùX0oLsOÂJIEwa^ÑBõPõIAc2üICœ>qGaCxõÐB[:i?ýIåô6i]^kLýOôNLd!Rck+CèÁpxÃÂÀýyfõAïB!Aid?eôNL@^RUX+6è|8c]^jmhIôJni?OOnACèÏÖ?oèÌsIR",
campfireLogLit2: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHIEWR*H$lZwJZNìYýNZgÁH$LW-úH.BZVñYTEY0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jxCTLCùX0mïAOÏgGEwa^ÑBØPõeAc3ig(ŒRkDt0xõÐB7/L?ýIåóÕ@P>iðýOôJ6c$^BkRCèÐpMjaii*RõCðMFAÆò@fô?L@{RÀü*oè{Ægd>hmhIôJni?OOnACèÏÖ?oèÌsIR",
campfireLogLit3: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHIEWNìYýNZR*H$lZwJZgÁH$LW-úH.BZVñYTEY0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB6ÁLIùX0qþAOÂiLEwa^ÑceÇõl$c2kL$R_Àia0xõÐB[:ÄOýiåóÕ@]RkÐlOôJ5xÖÈBlqCèÐpBjÈLXTRõCC%OAmò@Lô?Õ@_RÀüxoè{ÆI]ÈlooIôJni?OOnACèÏÖ?oèÌsIR",
campfireLogLitSW0: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYNìYIEWa?YËyY-úHýNZoÎZwJZR*H$lZAeHTEYgÁH0SgëwgiMcî822X6MkMB>9õlEJML?AQ(Äi5ðOõEg>E2ñýb)o?*P8ÀjCn>hk*P1ùÅaO;Ëjõî(Ìå;oôajgÑ1÷ñI7ôgGAÑ8gstOàõäiî1ÆñCdR?X(Ö0Rás$Asogò8oícðRcsdP9þhEJÙÀÞg>0{0ëwALTcQ1AK0JSiMcî",
campfireLogLitSW1: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYR*HNìYa?YËyY-úHýNZIEWoÎZwJZ$lZAeHTEYgÁH0SgëwgiMcî822X6MkMB>9õG*ÛMNrAQ(ÄiïôO?ig>E2lýc)qS.P8Èk)n>Ák.P1÷Ut5;Íjõî(ÈàiRônjgÑ1ù?tÐôÀáoÑ8qðCRç?äiî1Àá)d>cX)Ö0RlC$Ausgò8oLaERcádP9þhg÷áÀÞg>0{G$wasTcQ1AK0jSiMcî",
campfireLogLitSW2: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYNìYR*Ha?YËyYoÎZwJZýNZIEW-úH$lZAeHTEYgÁH0SgëwgiMcî822X6MkMB>9õg4?NmiAQ(Äl5oOc?g>E2?ýe)sI%P8ÈjaIT?n%P1AU.5áÇkcî(Àá]oôpjgÑ1AOPeôùGoÑ8eXtIÐcoiî1Ê?CÐ>õ?-Ö0Rñs&Aoigò8q?gJT?LdP9CkgŒÊÀÞg>0{7ëwaþTcQ1þK0?SiMcî",
campfireLogLitSW3: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYIEWNìYa?YËyYoÎZýNZwJZ-úH$lZR*HAeHTEYgÁH0SgëwgiMcî822X6MkMB>9õg4?OmLAQ(ÄÓ5iO{íg>E2?ý÷Okl%P8ÊownQfk%P1AUu5ÑÉjõî(~9P7ôÉjgÑ1CåR7ówioÑ8eîhrØ{äiî1Æäwdì?IsÖ0RîA$aLlùò8sßa÷ícädP9õÝG?ÊKIg>0{0ëwaLTcQ1þK0?-iMcî",
soulCampfire: "0g0gi000iAYa.WDsZÉ÷YHKHlZZ{rHZZZiãWGVZ)cYCkZËyYýLWâÐHúiWa?Y00000000000000080000000018ë00000003oS00000084oi0000004Ñwi0000014ïF2w00000ùcM]g0000ÞcðT@zë00eýAÕSLCE01jþEE(ÂI%K1Lc.eèkd*K1NlarîLàhK1?nHfØÈSIK2LgeØÈLgeK0000000000",
soulCampfireLogLit:"0g0g100W",
soulCampfireLog:"0g0gfúiWâÐHa?YËyY{rHGVZiãW000ýLWCkZ$LWsíYoÎZ.BZVñY0gy1gywgjQOg11)T2x11OM10Qhw0hhQQÄÒGGGGGGÕþGGGGGGÖòGGGGGGýaGGGGGGe?Lo?EHELhehGRelelReeEnENeLheeŒLLleohheeeHGeiolHLhehGRelelReeEnE",
soulCampfireFire:"0g0g100W",
soulCampfireLogSW: "0g0gf$LW.BZCkZiãWGVZ{rHúiWâÐHVñYsíYýLWa?YËyYoÎZ00011ggz)Äãggì9RcÉipú1a!zçÅú?ppy)GÄëùo1rrG?h11grrÔ?98ùArrÓãúùpgrrÔÔ9?0arrèÔg1ú9rrèã8ò0ërrèØ11ggrrGçggì9rrÄ?púúarrÅÄ1ùggrrÄÅ9?0arrÄã",
soulCampfireLogLitSW:"0g0g100W",
soulCampfireLogLit0: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHmPHCAZÉ÷YHKH$lZwJZdDYgÁH$LW.BZVñYlZZ0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB@ÇLiùX0qoAOÂJlÐwa^ÑBePõlAc2üLwR>ÊiahxõÐB[:ÂsýOìóÔ@PÂüîm5õcXd×^OkqCXÁpB_AJCGgõAýdàÈÄa@(õyXi^^LCC6X{oc#ÂÁk-IõdoQ?)BoqCXÏÖ@6XÎ8ig",
soulCampfireLogLit1: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHCAZÉ÷YHKH$lZwJZmPHgÁH$LWdDY.BZVñYlZZ0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB@PLGùX0oLsOÂJIEwa^ÑBõPõIAc2üICœ>qGaCxõÐB[:i?ýIåô6i]^kLýOôNLd!Rck+CèÁpxÃÂÀýyfõAïB!Aid?eôNL@^RUX+6è|8c]^jmhIôJni?OOnACèÏÖ?oèÌsIR",
soulCampfireLogLit2: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHCAZHKH$lZwJZÉ÷YmPHgÁH$LWdDY.BZVñYlZZ0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jxCTLCùX0mïAOÏgGEwa^ÑBØPõeAc3ig(ŒRkDt0xõÐB7/L?ýIåóÕ@P>iðýOôJ6c$^BkRCèÐpMjaii*RõCðMFAÆò@fô?L@{RÀü*oè{Ægd>hmhIôJni?OOnACèÏÖ?oèÌsIR",
soulCampfireLogLit3: "0g0gkúiWâÐHa?YËyY{rHoÎZsíYAeHCAZÉ÷YmPHHKH$lZwJZgÁH$LWdDY.BZVñYlZZ0218184x0w8iTõw0Shùì0Xiü1Mkg40x2jB6ÁLIùX0qþAOÂiLEwa^ÑceÇõl$c2kL$R_Àia0xõÐB[:ÄOýiåóÕ@]RkÐlOôJ5xÖÈBlqCèÐpBjÈLXTRõCC%OAmò@Lô?Õ@_RÀüxoè{ÆI]ÈlooIôJni?OOnACèÏÖ?oèÌsIR",
soulCampfireFire0: "0g0g8000igWzcHa.WHKHÉ÷YlZZZZZ00^w0000LQ0000CX0000LI0006I]E006ÂV0002DVg004ÛLÄ00r|LRh0#EJih1?Cli01aÓ?(01g+LG00.+AC01dgrÂS0nWZ^S",
soulCampfireFire1: "0g0g8000a.WzcHigWÉ÷YHKHlZZZZZ008w0000ÁK0000ÉQ0000^xë000iB(000cPC000oeCS02rELS0mlEÂ00gCgN00aÚLE00megÏ00*ÛLo01eãLDS1?GGLSeÉYZÆh",
soulCampfireFire2: "0g0g8000a.WÉ÷YHKHigWzcHlZZZZZ00À000001K00004wë000bC0000Bðg001!EJ009ÌVi003ÃÖh00oaÛk00j#JÐ003!Ú?00jÃÚ?00]aÚÐ00CNJR02+sJE01<YŠGS",
soulCampfireFire3: "0g0g8000igWa.WzcHlZZÉ÷YHKHZZZ00100000010000gT0000h8C000AÒC004rGg00#GLC00zGak002ÛgN000ögÈS04ÛLiS0zElÑ00tGgÂ00nAli02n)Aù02OWšU0",
soulCampfireFire4: "0g0g8000a.WigWzcHÉ÷YHKHlZZZZZ0000000000ë00019w000aPC000AÚg00kRGë00pÚlC005BGA000CE-ë01BJüS02DGC004EGi00lelC00nâL)00dGš?01PYZÈS",
soulCampfireFire5: "0g0g8000a.WigWzcHHKHÉ÷YlZZZZZ0000000018ë0002%w000b|C002AÚ000k?Õë00kNCi002RÐL00aeGü004÷eù000Ëúg002r?g002rúC004oJE00lGšL00eWZLS",
soulCampfireFire6: "0g0g8000igWzcHa.WHKHÉ÷YlZZZZZ0000000004ë00098ë006iBë006U|E006U$C00+CBþ00)U?E000|]ë000jòE006ÄGE002Ùýg00/ÓJù00lãrD00r,tL00.HšÄ0",
soulCampfireFire7: "0g0g8000igWzcHa.WHKHlZZÉ÷YZZZ0004ë000aAë000^S0000Lw0006{{g000iQ(006ABë002UòE000tò+00+t?m00-ãaC00lGam01acû(00OcR(00<LSg01aHsÏ0",
soulCampfireLogLitSW0: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYÉ÷YCAZa?YËyYdDYmPHoÎZwJZHKH$lZAeHlZZgÁH0SgëwgiMcî822X6MkMB>9õlEJML?AQ(Äi5ðOõEg>E2ñýb)o?*P8ÀjCn>hk*P1ùÅaO;Ëjõî(Ìå;oôajgÑ1÷ñI7ôgGAÑ8gstOàõäiî1ÆñCdR?X(Ö0Rás$Asogò8oícðRcsdP9þhEJÙÀÞg>0{0ëwALTcQ1AK0JSiMcî",
soulCampfireLogLitSW1: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYHKHÉ÷Ya?YËyYdDYmPHCAZoÎZwJZ$lZAeHlZZgÁH0SgëwgiMcî822X6MkMB>9õG*ÛMNrAQ(ÄiïôO?ig>E2lýc)qS.P8Èk)n>Ák.P1÷Ut5;Íjõî(ÈàiRônjgÑ1ù?tÐôÀáoÑ8qðCRç?äiî1Àá)d>cX)Ö0RlC$Ausgò8oLaERcádP9þhg÷áÀÞg>0{G$wasTcQ1AK0jSiMcî",
soulCampfireLogLitSW2: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYÉ÷YHKHa?YËyYoÎZwJZmPHCAZdDY$lZAeHlZZgÁH0SgëwgiMcî822X6MkMB>9õg4?NmiAQ(Äl5oOc?g>E2?ýe)sI%P8ÈjaIT?n%P1AU.5áÇkcî(Àá]oôpjgÑ1AOPeôùGoÑ8eXtIÐcoiî1Ê?CÐ>õ?-Ö0Rñs&Aoigò8q?gJT?LdP9CkgŒÊÀÞg>0{7ëwaþTcQ1þK0?SiMcî",
soulCampfireLogLitSW3: "0g0gk$LW.BZ{rHúiWâÐHVñYsíYCAZÉ÷Ya?YËyYoÎZmPHwJZdDY$lZHKHAeHlZZgÁH0SgëwgiMcî822X6MkMB>9õg4?OmLAQ(ÄÓ5iO{íg>E2?ý÷Okl%P8ÊownQfk%P1AUu5ÑÉjõî(~9P7ôÉjgÑ1CåR7ówioÑ8eîhrØ{äiî1Æäwdì?IsÖ0RîA$aLlùò8sßa÷ícädP9õÝG?ÊKIg>0{0ëwaLTcQ1þK0?-iMcî",
bambooSmallLeaves: "0g0g7000ÓíHÂxY%hHERH??H*ÎH0000C006N5qS0Mr5gë01îiw00qÆ?À00CÀÎë012IK0004g2@00/hcMë1gë0K038?!ë00cpQC00c2?g00058À0000k00000000",
bambooLargeLeaves: "0g0g6000*ÎH%hHÂxYÓíH??H0gÁÛN02GRM@Õm[#%iÐhIh6L?cNhd?30üR@pK6@ÂPþoE.Á!D0÷pÁEa0Îþìm+Klð2i-œ0këgI#5lqSI9eIpF(Ik,1Eü00Ài8gë",
bambooSingleleaf: "0g0g5000×RWþ?ZÁ?HÄ1W0000005g00001C00000O000006?000000000000000000000000000000000000000000000000000000000000000000000",
bambooStage0: "0g0gf000.CZ}ÀZ×ûH.cWþ*HURZQcWA?HÒÞZ)ëZ)ìWélYþ?HV1Z000000000000000000010000000200000003S0000005w000000mÞ000000DÁ000000]A000000aØ000000DÙ000009Å?000009ý×À0000bOJK0000aÛÄC0000aÒoE00",
bambooStalk: "0g0g8ÈSWÂ0Y?EZÏÎHø4Zÿ?HæCW<ìH4CòTì$0ùBXhâ00n?ú$409Âh0Að1#RAþ604c)Zù00úA?_1wg00cITù00kÒïë040WQg0A6aNh0Að9Wr0þg14C0ÍùS0g0E?9xù0",
bamboo: "0g0gb000Ä1WÁ?HÌyH?ìHóGWÿmW<ÎZæîW×RWþ?Z00000000000000hw000001NS00000jA000005NS00000jÑ000001yßò0000zA0/0002NS09000ÃA000002+S00000yA000002NÝ000007D0000007Ý00000000000000",
chestGrayThing: "0g0g7000K;ZDAHâlHJPWðoHIcW5k0000Û,0000Ú+ë000gÉë000]CS000000000000000000000000000000000000000000000000000000000000000000000",
chestFront: "0g0gA(EHQSWS?Z000EúZd?ZceZciHòíHïÞZöcZcCWòÎYURHúJYúíWéßWÎ1HåÏHýEZsÞH)iH$úZâÐWâÂYQ?YÎyHÞÂZìÏHöíHâTZÞMZQrZïíZwÞHAìZ0gT4gì4gí8gIgÁñkÂ9sCókgIgÏ?$I|(Îð$gIg?øSL|P)gSgIÀ0lVÒþÇVV0wIÀ0lVÒþÇVV0wIhâlÎþÇÖâlÊgIhIËâ?ÁélË=0IhM[sÞ?EÎ?kgIh1@ECñsÂóEwIgnIsCóEÁ[sgIhLioÎð$Ei&0IhMiECókc?kgIikjT)k|)g{gII]igT4ÆTmgSIc(Ic(Ic(Ic(I",
chestSide: "0g0gssÞH(EH)iH)EHS?Z000EúZúJYúíWéßWýEZQSWceZcCWd?ZciHöcZwÞHAìZ$úZïíZöíHQrZìÏHâÐWâÂYÖRYÞÂZ0Rx8TgXxùcMjXcPÂJüEcOqLeõÐoiEcOAS.Kèx8$caLgEôÈiR$còCÐoiaöOoc*kádPÂJüEcNc8RgásO$c*ÈiMõØÈiÆcMNSigîASEcNÊiRfçc8gcNAShjîsO$c*ŒÈc8eØÈ?c+MõŒÈiMH$c0Rx8TgXxùcF^ÂücF^Âüc",
chestTop: "0g0ghEúZ)EH-EH(EH000)iHïíZéßWýEZúJYd?ZöcZciHöíHceZcCWúíW0QgIx8R(õXF÷áwoTLîkX!kcdØÈLikXbÊShjàAsXX!Æc%ØÉoiõXpLgMôÈNcõX!kd%^ÐoCcXcuShjàNs4X!ocFØÉüCkXp?iFÙÐoeõXFLgF×ÈNiüXbÊO.jàNs4XFCüAO.LàcX0iNücF^ÂëXx8RgXx8RgXx8RgXx8RgX",
boneMeal: "0g0g7000ÇÅZŒEYZZZGœY?mHéOZ0000000200000k]0g00mnwE00DG@/00JDÜ*S0ÓrØ|S0DEJÖE0gAl+Ð5{LaeE0JDiÖS5ÄEaPS2ôDLOS01ÑüVS00%Ca0000000",
clay: "0g0g6þ×HAôWEgZERHCaWCóZ5*yð]Có9dNd$JIPÂÅÏGCAúaÑðQÑGPdJxPÂR9yýkeúAÀiÑí?hï?Î+Aœþl1ÀI{ÐC]óÃlEiLGiCklyNUAðiúÁEÁþyÚ÷Èc×lAùI$",
clayBall: "0g0g9000TlYâŠWCaWþ×H)?HERHEgZËGZ000000000000000000000000000hh000001zyg0000k)NB0001+,ÐíÀ001O@OíÀ00j[ÓREB00kO)OEB00iOÔ-yï001îOyEÀ000VyíV00000VV0000000000000000000",
brick:"0g0g8000]ìYöjWgÑWèrZIXH$ÁWKEW0000000000000000ù0001B-002^Úg04ülÚGN*GlÚgU!GlãlCFÄREPCF#UJP=MDAJ~E6DAcÙ00I=?000jE000000000000000",
charcoal: "0g0ga000sÎHEúZS?Z(CWgSZégY|jHÎUWwÞY000000000001h000001zRÀ0000UÔñB0005>äàNÀ005M]Ðîý005xk-).À0ÂphyPhÀ0ÂûhhhJÀ0ÇyFhJNÀ0ÁJßúpFÀ0ÁFyJhúÀ05iaxhl000ÁhlVÀ0005VÀ00000000000",
christmasChestYellowThing: "0g0g5000?OZZiYRÑWTdY4D0000%þh000%Jh000AJë000Ñÿ0000000000000000000000000000000000000000000000000000000000000000000000",
christmasChestSide: "0g0gCEEYGiYZiY000EÎWCÁWÐÎWlzZEÎWEÞHj?YTdYCÁWAÁWÐÁWiLZAJWAÀZCÀZCÞHiLYÆgWÙÁWÝwWáwHäwHè(HùìYëwHèwHõÞYKgWÝwHáÁWÝÁWÑgW]0W{0W0gT4gí4gT4gI0T@gTigT8AgI0Á?kÂôkÁ?wgI0Ic)LñkÃ|-rITh?kióPx?|SITh?kÂóPx?|SIVVVVVVVVVVÀIÇâlËðoËâ?ÖEIÇðVÞitÎýÊÞNIÇÿléLoÒSÍâNIÇVVVÆtVVVVNIÇïÍV?tÎÅlãgIòÆ?öÆtÄ+zÄgIòðoìÿKÎðwÓgIJÇBþÇÒþÇÒþÀIc(Ic(Ic(Ic(I",
christmasChestTop: "0g0gp??Zk?ZEiYZiYRÑW000CÀZAÁWCÁWTdYljZCÁWEÎWljZÐÎWlzZGiYEEYiIHnzZOQWl3YO>Zl3YHeH0Rh8ÑgXgXc9÷áx!TLî4caoIeeÈL?4chùXwøRgî4cíNi$öÉAOXcòLG-öÈkIicJd,ùáçn*Ac|URgãx8EicísiM%ÈoiScòNOMeàAeicìLGMCÈkOhc9ùXx?RgïXc9þgCS.Là4c0>oT-Xx0ëcF^ÂücF^ÂücF^ÂücF^Âüc",
christmasChestBottom: "0g0g7èSZÝSZëSZ000áwHëwHäwH4JPAJaNÇ)þ]ÉNP)J]ÉN?AJÆÉNPAE]ÉN|ÑJ]ÉNÇÑJ]ÉNÇAA]ÉNPAJ]ÉNPÑþ]É+P%J^ÉN?AL^ÉNPAJiÉ4JPAJrÚGlÚGlÚGlÚGl",
appleCore: "0g0gg000áCWèkZUùYATHLeYGTZNÂHTãYZTZŒAZI9Z÷DYåLHlÉZUwZ00000000000010000000z0000000g000004TMg00005Ð[000000VÆ000000aa0000009C000000bh000000dE000000Er000000rE000004Ñ@S0000fhvr0000000000",
tintedGlass: "0g0g5)cEEîNEÏrAJÉPka029FgSdgzÚG?dgrÚG?dilÚG?e@lÚGLN+lÚG?hGlÚGL%GlÚG?%GlÚG?|GlÚG?%GlÚGN%GlÚgx|GlÚgo%GlÚi?dGlÛ@?0CúAëS",
light_15: "0g0g8000rsHÁQZZaYZZZ?ÙHGlWA]Y52^000B2ëß@052^J]h50aJPoAC^JPw00AJPw00sJPo004÷.0000Û+0000hh0000dE0000mN0000rr0000nK00003ë0000000",
tomatoPlantStage0: "0g0g5000OáHqCZ9RHuhZ000000000000000000000000000000000000000000000000000400000400020w0000R%ë006Q00000k00000kc00002ë00",
tomatoPlantStage1: "0g0g6000OáHFCY!SYqCZuhZ000000000000000000000000000400008ww0003100004Cg000ëJë000ëü00020C0000QC0005500000B00000B000004C00",
tomatoPlantStage2: "0g0g8000OáHYrWTrWy?WqCZuhZFCY0000000004000w0w001)0w000wSg0000EGÝ0005Iëë005iük3ìhgÝù4?hGÝ03ó0h00s1?h000fÛ00000&0000fr000005h00",
tomatoPlantStage3: "0g0g8000ilHCEZFCYqCZuhZcrWTrW00000050oöë0CEsC005Æ4C(02n0ýë0rèAüNÀnÕ4cíÀo1AC^ÐÛ0iJeÆ2^oü(o1òAü00c0?E0006B1ë000B00006O00000AC00",
tomatoPlantStage4: "0g0g6000ilHCEZFCYqCZuhZ00000050oöë0CEsC005Æ4C(02c0ýë00ýÑüNÀEÈ4cíÀCìAC^Ðm0iJeÆ2^oü(o1òAü00c0?E0006B1ë000B00006O00000AC00",
tomato: "0g0ga000q(Wq0WGJHNEZCÞZHCYLEZRVHoEZ00100000000i00000001hw00001hxh0000iMAig000Äá]XR003GaaAù00OåaaAa00,åaaaò00,åaaaa00,Gaaaa00OGaaaa003Gaaaù003,åaaù0003Gaù0000000000",
tomatoSeeds: "0g0g3000lÏYEIZ00000g0000o00000oSg40S00040000gS40g0040000001ë000010010400000000",
newCactusFruit: "0g0g6000HVHÂ?WRìHBrWPáY00000000000000000000000000000000000000000000000000000000000000aK0000ÂÝ0000ÃE0000ØÛ0000ÂÝ0000aÝ00",
greenCactusFruit: "0g0g6000HVHÂ?WRìHBrWPáY00000000000000000000000000000000aÝ0000Âã0002ÃÛS003ÃÚh00iûÚi00iûÚ?00iûÚh002ûES003ÃÛ0000ÂÝ0000aÝ00",
redCactusFruit: "0g0g6000T)ZœÞZiÁHCÝWPáY00000000000000000000000000000000^ß0002ÂãS002ÃÛ]003ÃÚi00iûÚi00iûÚ?00iûÚi00iûES003ÃÛS002Âß0000ÂJ00",
purpleCactusFruit: "0g0g6000THZEFYü7ZNAYÎAY000000000000000000001|ë000{|E002Ù|E002ÑVG00iÏPG00jÏPG00jyPG00jyPL00jyPG00jydE003ÏPE002Ñ|ë000ÑÚë0",
cherry: "0g0g9000u(HqùW?(ZG(ZÐJHAÎYOGZõÞZ000000000000g0000002000000020000000wh00000200g0000)SVÓ0003àQïÄK00,O)]VÓ00OO)]VÓ00OO)]VÓ003OQïÄK000)SVÓ00000000000000000000000000",
cherryLogTop: "0g0ga-iZ-EWQIZ{LWciYGCWeSHòÂZccYýàW001hhg1gizNzzNOwj?VÒÑVÑw2[òäAòá(2ÇÄVÑVð(2ÆÆòIâýMj]ÇÒÄüâxjÖ[]ýðïxiÆÕÇãýïMjÇÇÄ?ðþMjÕÔåIýüM2]@ÄV@ïw3[AIAòâw2ÒVÒÄ?ÄM2OyzNzNx1g1hhg00",
cherryLog: "0g0g3-EW-iZVjZ1S1V0À5×Tc@ýýÄúS×TCÀl0ÁC00UÀk1d0ÖÄüklcÀÖ1Ö1ümU5SÖ5qUkq?Ö1?0U6ù00",
cherryLogSW: "0g0g3-EW-iZVjZ111ù6@@S@@@Súý6ÁùÇ1ÒQÖ0ÑpÒ0ÀpmTù46þù15þS6Túk6ÀQÒlÑpÒpppppp4p440p",
cherryLeaves: "0g0g4000eNWaëWÃ)Hoo0wÕ66oí6+8dK+0ÐÆo6ë?ë+w3Æ???8KÐKK8w0L+8K*ð8?dIK+w0?+o++6zÄ603Æ",
pinkCherryLeaves: "0g0g6TSZtŒYšÖY000tgHZCH5+>ÚGXF6iÙDÀ{SiáDlÛíaáClFLÃÒ8a|GÀ|e^ÖGi5/Ãc/ÀÚNaFíaFGlÕSlCd^Ú2aáüiÚ/ÃÛùlFg^ÖIrc,^ÒM^áDiÖL^áDwÚLÀ",
cherrySapling: "0g0g5000IcWT~WÕEWõrW000000009Pg00kJPAS5AJPAù5AJPAI0JJPyS0m?Õë000A00000A00000Aë0000Aë0000?ù000.Aúë02PAöE0004JP0000000",
"redstoneDustL": "0g0g4000ŒEYZZZlÚY00S0000000ë001h001(008E00:Õ005ÄS0%An0&:003I000w00000000000000000",
"redstoneDustT": "0g0g4000ŒEYZZZlÚY00S0000000ë001h001(00a(00øÕ0î.ÞS!yon0öÜ00!K000ë00000000000000000",
"redstoneDust+": "0g0g4000ŒEYZZZlÚY00S0000000ë001h001(008E00gÕ0î.VS!&An0&L003I008w003ë000ë000ë00200",
"redstoneDustLine": "0g0g4000ŒEYZZZlÚY00S0000000ë001h001(000(000K0010000ë0020003ë0080003ë000ë000ë00200",
"redstoneDustDot": "0g0g4000ZZZlÚYŒEY0000000000000000000004K00CL00f<00rá00pA002Q000g00000000000000000",
gun: "0g0g4000VVH(IWT4W0000000000000VVë5VÄClÍtClHZëlt00lr00lr00lr00lr00nr00Wh00f0000000",
redDye: "0g0gÈ000KûîÕCîUÂîÆû>ÑI2Ñà6ëcæáßGÑí5ál@XegXcéècèõeèI4WAcYáßGÕÎiäßgÕÏ7{Â>XeGOýZAcZnïZRcZõûYXJtI3ZëígKÂðUC3XeåI4WEGWCeZÐGWAGWRcZJkWäßgèIPIeèOïYJ4WCCWCLWODWOýZèíh{Á>XeänýZlAWJ3ZOþWEiHäßgKJ>ÆR>XeêlAH?sWùCW?kWÐCWäßhXcåEGHCCHùûZücZüûZáßgÕÂîáíðèßgõûZI3ZisWÕíðKÂ6CGWèßht00Ùß@ÝÞiKÂ>ÕÁ>000000000000000000000000000000000014000000000(ì>7gA0(00000Àeî[fwQúNë000UeÞocAuÙnlIh00ìaAÐLf^AiâaTë01ÂG?mE{Òç6$aë0dcÄ%aAÝÖ>n&aë0RŒnKlSÐ4ësÀnë0íwseciÈN{Õrcë02Ñ?LDkMT$åUS0005B)Ic÷GCdë0002Ða!×/ðDgÝ00000000œÆeÑ0000000000000000000",
//pretty: "0g0g40001blc009d4hc009efw01ulak1c3300022112200033333022111122033303332112211233300033312222133300022333222233322022113330033311222112233333322112112220333302221111222033330222112112233333322112221133300333112202233322223332200033312222133300033321122112333033302211112203333300222112200033",
//pigFace: "0g0gr000006w14172ew1hejb3s1heul881luzbw81lvx4oo1o2w1dk1qb44541qbfcoo1sj0ws81sjc3qw1sjc5bs1sjndvc1sjnfg81sjynzs1sjypko1sk9y481skl9tk1ur8we01urk6ig1urvf201urvgmw1urvi7s1us6p6g1us6qrc1ustb081x2x0xkaa669999ddddbbddaa669999ddddbbdd7766ccii99kknnnn7766ccii99kknnnn88cceeeeddddeenn88cceeeeddddeenn00qqbbbbjjjjqq0000qqbbbbjjjjqq0099ddhhppppppggdd99ddhhppppppggddcccc11ddff11llllcccc11ddff11llll999922335544oomm999922335544oommbbbbddeellffffnnbbbbddeellffffnn",
/*
steveFace: "0g0gw08wkrnc0b4hipk0b4sr940dcpjw80fkxji00hs7rw80hsj0fs0hsuak80m9axh40sxbw8o0sxbxtk0xdgohk0zloo3c0zlopo811ta86w11twpa0141thx416a1hiw16acrnc16ao3co18i9h4o1aqhlh41aqsvlk1ar45q01cypmns1cz0ws81cz0yd41czc5bs1f78we01f78xyw1hfh0qg1x2x0xk221111110000111122111111000011111111113377441111111111337744111111rrttuuttttll3311rrttuuttttll33mmppmmnnjjttiiiimmppmmnnjjttiiiippvv88oott88vvmmppvv88oott88vvmmhhooqqaaaasskkcchhooqqaaaasskkccgggg66eeee66ffddgggg66eeee66ffdd999966556666ddbb999966556666ddbb",
steveHeadTop: "0g0g406ocs1k08w9j3s08wkrnc0b4hipk3333223333222200333322333322221133223333332222223322333333222222333333223322222233333322332222222233332233333333223333223333333333333322223333333333332222333333333322223333333333332222333333333322333333113333332233332200333333333322222233333333222222223333",
lexiFace: "0g0g6009pbso06oo3qw1urv2ew1utfnco1wxln201x2x0xk3333333333333333333333333333333333332222222233333333222222223333331111222211113333111122221111333355002222005533335500222200553333550022220055333355002222005533332222222222223333222222222222333322224444222233332222444422223333332222222233333333222222223333",
lexiTop: "0g0g11utfnco0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
sarahFace: "0g0g6009ehh406o1hx406oo3qw1wugttk1x1114o1x2x0xk1111111111111111111111111111111111114411111111111111441111111111111122441111111111112244111111111155004444111111115500444411111111550044444411111155004444441111114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
sarahTop: "0g0g106o1hx40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
sallyFace: "0g0g6000006w006lb0806oo3qw1sgim7s1wzrth41x2x0xk0000000000000000000000000000000000004444444400000000444444440000000022444422000000002244442200000000114444110000000011444411000000551144441155000055114444115500004444444444440000444444444444000044443333444400004444333344440000444444444444000044444444444400",
sallyTop: "0g0g1000006w0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
face: "0g0g60077lrs0fkme480ohifp41unspvc1x1114o1x2x0xk1111111111111111111111111111111111114444444411111111444444441111112222444422221111222244442222111155004444005511115500444400551111550044440055111155004444005511114444444444441111444444444444111144443333444411114444333344441111444444444444111144444444444411",
faceTop: "0g0g10fkme480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
//*/
cowSide:"0g0g4000KC;SK=KC=00000000000000005VVSVVcVšteRšHeešYeešYZeZteeZZZZ;00r;00r;00r;00r",
cow: "0g0g2å0=SK=00gs-C-fof1ñxhOhjA7oñ0h6?4j(øo7s",
error:function(n){
for (let x = 0; x < 16; ++x) {
for (let y = 0; y < 16; ++y) {
let p = false
if(x>=8){
if(y>=8){
p=true
}
}else{
if(y<8){
p=true
}
}
if(p){
setPixel(n, x, y, 0, 0, 0);
}else{
setPixel(n, x, y, 255, 0, 255);
}
}
}
}//"0g0g2000006w1ulbvg81111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000000000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111",
}
window.textures = textures
const animated = {
Water:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("water"+i); return a})(),
tint:[/*68,175,245*/10,30,255]
},
portal:{
time:1,
arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("netherPortal"+i); return a})()
},
Lava:{
time:2,
arr: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1].map(v => "lava"+v),
},
prismarine:{
time:300,
arr:[0,1,0,2,0,3,0,1,2,1,3,1,0,2,1,2,3,2,0,3,1,3].map(v => "prismarine"+v),
interpolate:true
},
seaLantern:{
time:5,
arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("seaLantern"+i); return a})(),
},
stonecutterSaw:{
time:1,
arr:["stonecutterSaw0","stonecutterSaw1","stonecutterSaw2"]
},
fire:{
time:1,
arr:(function(){var a=[]; for(var i=0; i<32; i++)a.push("fire"+i); return a})(),
},
lantern:{
time:8,
arr:["lantern0","lantern1","lantern2"]
},
soulLantern:{
time:8,
arr:["soulLantern0","soulLantern1","soulLantern2"]
},
magma:{
time:8,
arr:["magma0","magma1","magma2"],
interpolate:true
},
warpedStemSide:{
time:10,
arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("warpedStem"+i); return a})(),
interpolate:true
},
warpedStemSW:{
time:10,
arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("warpedStemSW"+i); return a})(),
interpolate:true
},
crimsonStemSide:{
time:10,
arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("crimsonStem"+i); return a})(),
interpolate:true
},
crimsonStemSW:{
time:10,
arr:(function(){var a=[]; for(var i=0; i<5; i++)a.push("crimsonStemSW"+i); return a})(),
interpolate:true
},
kelp:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<20; i++)a.push("kelp"+i); return a})()
},
kelpPlant:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<20; i++)a.push("kelpPlant"+i); return a})()
},
seagrass:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<18; i++)a.push("seagrass"+i); return a})()
},
tallSeagrassTop:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<19; i++)a.push("tallSeagrassTop"+i); return a})()
},
tallSeagrassBottom:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<19; i++)a.push("tallSeagrassBottom"+i); return a})()
},
waterFlow:{
time:1,
arr:(function(){var a=[]; for(var i=0; i<128; i++)a.push("waterFlow"+i); return a})(),
tint:[10,30,255]
},
lavaFlow:{
time:3,
arr:(function(){var a=[]; for(var i=0; i<64; i++)a.push("lavaFlow"+i); return a})()
},
campfireFire:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<8; i++)a.push("campfireFire"+i); return a})()
},
campfireLogLit:{
time:20,
arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("campfireLogLit"+i); return a})(),
interpolate:true
},
campfireLogLitSW:{
time:20,
arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("campfireLogLitSW"+i); return a})(),
interpolate:true
},
soulCampfireFire:{
time:2,
arr:(function(){var a=[]; for(var i=0; i<8; i++)a.push("soulCampfireFire"+i); return a})()
},
soulCampfireLogLit:{
time:20,
arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("soulCampfireLogLit"+i); return a})(),
interpolate:true
},
soulCampfireLogLitSW:{
time:20,
arr:(function(){var a=[]; for(var i=0; i<4; i++)a.push("soulCampfireLogLitSW"+i); return a})(),
interpolate:true
},
}
for(var a in animated){
animated[a].time *= tickTime
}
window.animated = animated
const blockData = [
{
name: "air",
id: 0,
textures: new Array(6).fill("none"),
transparent: true,
shadow: false,
},
{
name: "grass",
Name: "Grass Block",
textures: [ "dirt", "grassTop", "grassSide" ],
breakTime: 0.9,
drop:"dirt",
type:"ground",
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"],menu:1
},
{ name: "dirt", Name:"Dirt", breakTime:0.75, type:"ground",
digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"],menu:1
},
{ name: "stone", Name:"Stone", drop:"cobblestone", type:"rock1", breakTime:7.5, stoneSound:true,menu:1},
{ name: "bedrock", Name:"Bedrock", breakTime:89000000, stoneSound:true,menu:1},
{ name: "sand", Name:"Sand", breakTime:0.75,
onupdate: function(x,y,z,b){
fall(x,y,z,b)
},
digSound: ["block.sand.dig1", "block.sand.dig2", "block.sand.dig3", "block.sand.dig4"],
stepSound: ["block.sand.step1", "block.sand.step2","block.sand.step3","block.sand.step4","block.sand.step5"],menu:1
},
{ name: "gravel", Name:"Gravel", breakTime:0.9, type:"ground",
onupdate: function(x,y,z){
fall(x,y,z,blockIds.gravel)
},
drop: function(){
if(round(random(10)) === 1) return "flint"
else return "gravel"
},
digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"],menu:1
},
{
name: "leaves",
Name: "Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"],menu:1
},
{
name: "glass",
Name:"Glass",
transparent: true,
shadow: false,
breakTime: 0.45,
type: "glass",
glassSound: true,menu:1
},
{ name: "cobblestone", Name:"Cobblestone", breakTime:10, type:"rock1", stoneSound:true,menu:1},
{ name: "mossyCobble", Name:"Mossy Cobblestone", breakTime:10, type:"rock1", stoneSound:true,menu:1},
{ name: "stoneBricks", Name:"Stone Bricks", breakTime:7.5, type:"rock1", stoneSound:true,menu:1},
{ name: "mossyStoneBricks", Name:"Mossy Stone Bricks", breakTime:7.5, type:"rock1", stoneSound:true,menu:1},
{ name: "bricks", Name:"Bricks", breakTime:10, type:"rock1", stoneSound:true,menu:1},
{ name: "coalOre", Name:"Coal Ore", breakTime:15, type:"rock1", drop:"coal", stoneSound:true, experience:0.1},
{ name: "ironOre", Name:"Iron Ore", breakTime:15, type:"rock2", drop:"rawIron", stoneSound:true},
{ name: "goldOre", Name:"Gold Ore", breakTime:15, type:"rock3", drop:"rawGold", stoneSound:true},
{ name: "diamondOre", Name:"Diamond Ore", breakTime:15, type:"rock3", drop:"diamond", stoneSound:true, experience:1},
{ name: "redstoneOre", Name:"Redstone Ore", breakTime:15, type:"rock3", stoneSound:true, drop:"redstoneDust", dropAmount:[4,5], experience:0.3},
{ name: "lapisOre", Name:"Lapis Lazuli Ore", breakTime:15, type:"rock2", drop:"lapisLazuli", stoneSound:true, experience:0.5},
{ name: "emeraldOre", Name:"Emerald Ore", breakTime:15, type:"rock3", drop:"emerald", stoneSound:true, experience:1.5},
{ name: "coalBlock", Name:"Block of Coal", breakTime:25, type:"rock1", stoneSound:true},
{ name: "ironBlock", Name:"Block of Iron", breakTime:25, type:"metal2", stoneSound:true},
{ name: "goldBlock", Name:"Block of Gold", breakTime:15, type:"metal3", stoneSound:true},
{ name: "diamondBlock", Name:"Block of Diamond", breakTime:25, type:"metal3", stoneSound:true},
{ name: "netheriteBlock", Name:"Block of Netherite", breakTime:35, type:"metal3", stoneSound:true},
{ name: "redstoneBlock", Name:"Block of Redstone", breakTime:25, type:"metal1", stoneSound:true},
{ name: "lapisBlock", Name:"Block of Lapis Lazuli", breakTime:15, type:"metal2", stoneSound:true},
{ name: "emeraldBlock", Name:"Block of Emerald", breakTime:25, type:"metal3", stoneSound:true},
{
name:"copperBlock",
Name:"Block of Copper",
breakTime: 15,type:"metal1"
},
{ name: "oakPlanks", Name:"Oak Planks", type:"wood", breakTime:3, woodSound:true},
{
name: "oakLog",
Name:"Oak Log",
textures: [ "logTop", "logSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "acaciaPlanks", Name:"Acacia Planks", type:"wood", breakTime:3, woodSound:true},
{
name: "acaciaLog",
Name:"Acacia Log",
textures: [ "acaciaLogTop", "acaciaLogSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "birchPlanks", Name:"Birch Planks", type:"wood", breakTime:3, woodSound:true},
{
name: "birchLog",
Name:"Birch Log",
textures: [ "birchLogTop", "birchLogSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "darkOakPlanks", Name:"Dark Oak Planks", type:"wood", breakTime:3, woodSound:true},
{
name: "darkOakLog",
Name:"Dark Oak Log",
textures: [ "darkOakLogTop", "darkOakLogSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "junglePlanks", Name:"Jungle Planks", type:"wood", breakTime:3,woodSound:true},
{
name: "jungleLog",
Name:"Jungle Log",
textures: [ "jungleLogTop", "jungleLogSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "sprucePlanks", Name:"Spruce Planks", type:"wood", breakTime:3, woodSound:true},
{
name: "spruceLog",
Name:"Spruce Log",
textures: [ "spruceLogTop", "spruceLogSide" ],
breakTime:3,
woodSound:true,
type:"wood",
},
{ name: "whiteWool", Name:"White Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "orangeWool", Name:"Orange Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "magentaWool", Name:"Magenta Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "lightBlueWool", Name:"Light Blue Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "yellowWool", Name:"Yellow Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "limeWool", Name:"Lime Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "pinkWool", Name:"Pink Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "grayWool", Name:"Gray Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "lightGrayWool", Name:"Light Gray Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "cyanWool", Name:"Cyan Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "purpleWool", Name:"Purple Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "blueWool", Name:"Blue Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "brownWool", Name:"Brown Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "greenWool", Name:"Green Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "redWool", Name:"Red Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "blackWool", Name:"Black Wool",breakTime:1.2, clothSound:true, shearBreakTime:0.2},
{ name: "whiteConcrete", Name:"White Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "orangeConcrete", Name:"Orange Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "magentaConcrete", Name:"Magenta Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "lightBlueConcrete", Name:"Light Blue Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "yellowConcrete", Name:"Red Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "limeConcrete", Name:"Lime Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "pinkConcrete", Name:"Pink Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "grayConcrete", Name:"Gray Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "lightGrayConcrete", Name:"Light Gray Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "cyanConcrete", Name:"Cyan Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "purpleConcrete", Name:"Purple Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "blueConcrete", Name:"Blue Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "brownConcrete", Name:"Brown Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "greenConcrete", Name:"Green Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "redConcrete", Name:"Red Concrete",breakTime:9, type:"rock1", stoneSound:true},
{ name: "blackConcrete", Name:"Black Concrete",breakTime:9, type:"rock1", stoneSound:true},
{
name: "bookshelf",
Name:"Bookshelf",
textures: [ "oakPlanks", "bookshelf" ],
stoneSound: true,
breakTime: 3,
type:"wood", 
},
{ name: "netherrack",
Name:"Netherrack",breakTime:3,type:"rock1",
digSound: ["block.netherrack.dig1", "block.netherrack.dig2", "block.netherrack.dig3", "block.netherrack.dig4", "block.netherrack.dig5", "block.netherrack.dig6"],
stepSound: ["block.netherrack.step1", "block.netherrack.step2","block.netherrack.step3","block.netherrack.step4","block.netherrack.step5","block.netherrack.step6"]},
{ name: "soulSand",
Name:"Soul Sand",
speedFactor: 0.5,
breakTime:1,
digSound: ["block.soul_sand.dig1", "block.soul_sand.dig2", "block.soul_sand.dig3", "block.soul_sand.dig4", "block.soul_sand.dig5", "block.soul_sand.dig6","block.soul_sand.step7","block.soul_sand.step8","block.soul_sand.step9"],
stepSound: ["block.soul_sand.step1", "block.soul_sand.step2","block.soul_sand.step3","block.soul_sand.step4","block.soul_sand.step5","block.soul_sand.step6"]},
{
name: "glowstone",
Name:"Glowstone",
lightLevel: 15,breakTime:3,type:"rock1",
glassSound: true,
shadow:false,
drop: "glowstoneDust",
dropAmount: [1,3]
},
{ name: "netherBricks",
Name:"Nether Bricks",breakTime:12,type:"rock1",
digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
{ name: "redNetherBricks",
Name:"Red Nether Bricks",breakTime:12,type:"rock1",
digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
{ name: "netherQuartzOre", 
Name:"Nether Quartz Ore",breakTime:12,type:"rock1",
digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"],
drop: "quartz",
dropAmount: [1,2]
},
{
name: "quartzBlock",
Name:"Block of Quartz",
textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"],
stoneSound: true, breakTime:10, type:"rock1"
},
{
name: "quartzPillar",
Name:"Quartz Pillar",
textures: ["quartzPillarTop", "quartzPillar"],
stoneSound: true, breakTime:10, type:"rock1"
},
{
name: "chiseledQuartzBlock",
Name:"Chiseled Quartz Block",
textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"],
stoneSound: true, breakTime:10, type:"rock1"
},
{ name: "chiseledStoneBricks", Name:"Chiseled Stone Bricks", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "smoothStone", Name:"Smooth Stone (it doesn't really look like stone)", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "andesite", Name:"Andesite", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "polishedAndesite", Name:"Polished Andesite", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "diorite", Name:"Diorite", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "polishedDiorite", Name:"Polished Diorite", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "granite", Name:"Granite", stoneSound:true, breakTime:10, type:"rock1"},
{ name: "polishedGranite", Name:"Polished Granite", stoneSound:true, breakTime:10, type:"rock1"},
{ // I swear, if y'all don't stop asking about TNT every 5 minutes!
name: "tnt",
Name:"Trinitrotoluene",
textures: ["tntBottom", "tntTop", "tntSides"],
//onupdate: function(x,y,z){
//  explode(x,y,z,5)
//}, flint and steel explodes it
explode: function(x,y,z, how){
world.setBlock(x,y,z,0)
var e = new PrimedTNT(x,y,z)
world.addEntity(e)
playSound("entity.tnt.fuse", 0, posSound(x,y,z))
switch(how){
case "explosion":
e.timeLimit = rand(10,30)
}
},
onupdate:function(x,y,z){
var neigbors = [
world.getBlock(x+1,y,z),
world.getBlock(x-1,y,z),
world.getBlock(x,y,z+1),
world.getBlock(x,y,z-1),
world.getBlock(x,y+1,z),
world.getBlock(x,y-1,z)
];
if(neigbors.includes(blockIds.redstoneBlock)){
this.explode(x,y,z)
}
},
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "portal",
Name: "Nether Portal",
solid:false,
shadow: false,
portal: true,
breakTime: 5,
type: "rock1",
transparent:true,
lightLevel: 11,
ontouch: function(){
touchingPortal = true
portalEffect += 2
if(portalEffect >= 100){
portalEffect = 0
if(world.type === "nether"){
world = dimensions.overworld
if(!world.hasLoaded){
releasePointer()
changeScene("loading")
}
}else{
world = dimensions.nether
if(!world.hasLoaded){
releasePointer()
changeScene("netherLoading")
}
}
playSound("block.portal.travel")
if(multiplayer) send({type:"playSound", data:"block.portal.travel", x:p.x,y:p.y,z:p.z})
}
},
glassSound: true,
ambientSound:"block.portal.portal"
},
{ name: "obsidian", Name:"Obsidian", stoneSound:true,breakTime:60, type:"rock4"},
//the old redstone dust added before this version of minekhan was public (early 2021)
/*{
name:"redstoneDust",
onupdate: function(x,y,z){
var neigbors = [
world.getBlock(x+1,y,z),
world.getBlock(x-1,y,z),
world.getBlock(x,y,z+1),
world.getBlock(x,y,z-1),
world.getBlock(x,y+1,z),
world.getBlock(x,y-1,z)
];
if(neigbors.includes(blockIds.redstoneBlock) || neigbors.includes(blockIds.redstoneDustOn)){
world.setBlock(x,y,z, blockIds.redstoneDustOn, false, true)
}
}
},
{
name:"redstoneDustOn",
hidden: true,
onupdate: function(x,y,z){
var checked = []
function touchingSource(x,y,z, t){
t = t || 0;
t ++;
var neighbors = [
[x+1,y,z],
[x-1,y,z],
[x,y,z+1],
[x,y,z-1],
[x,y+1,z],
[x,y-1,z]
];
for(var i=0; i<neighbors.length; i++){
var value = neighbors[i];
var block = world.getBlock(value[0], value[1], value[2])
if(block === blockIds.redstoneBlock){
return true;
}
if(t<10){
if( !(checked.includes[value]) && (block === blockIds.redstoneDust || block === blockIds.buffer) && touchingSource(value[0], value[1], value[2], t)){
checked.push(value);
return true
};
}
}
return false;
}
if(!touchingSource(x,y,z)){
world.setBlock(x,y,z, blockIds.redstoneDust);
}
//world.setBlock(x,y,z, blockIds.redstoneDust);
}
},*/
{
name:"redstone",
Name:"Redstone Dust",
item:true,
useAs:"redstoneDust"
},
{
name:"redstoneDust",
textures:"redstoneDustDot",
shadow:false,
transparent:true,
solid:false,
hidden:true,
drop: "redstone",
onupdate: function(x,y,z){
var tags = world.getTags(x,y,z)
tags.west = this.connectable(x+1,y,z,"west")
tags.east = this.connectable(x-1,y,z,"east")
tags.south = this.connectable(x,y,z-1,"south")
tags.north = this.connectable(x,y,z+1,"north")
if(tags.north + tags.south + tags.east + tags.west === 1){
//make it a line. it can't be half of a line
if(tags.north) tags.south = true
if(tags.south) tags.north = true
if(tags.east) tags.west = true
if(tags.west) tags.east = true
}
world.setTags(x,y,z,tags)
//set texture and stuff
var sum = tags.north + tags.south + tags.east + tags.west
var block = this.id //dot
if(sum === 2){
if(tags.north && tags.west) block = this.id | STAIR | EAST
else if(tags.west && tags.south) block = this.id | STAIR | SOUTH
else if(tags.south && tags.east) block = this.id | STAIR | WEST
else if(tags.east && tags.north) block = this.id | STAIR | NORTH
else{
if(tags.north || tags.south) block = this.id | SLAB | NORTH
if(tags.east || tags.west) block = this.id | SLAB | EAST
}
}
if(sum === 3){
if(tags.east && tags.west){
if(tags.north) block = this.id | DOOR | NORTH
else block = this.id | DOOR | SOUTH
}else if(tags.north && tags.south){
if(tags.east) block = this.id | DOOR | WEST
else block = this.id | DOOR | EAST
}
}
if(sum === 4) block = this.id | PANE
if(world.getBlock(x,y,z) !== block) world.setBlock(x,y,z,block)
},
onplace:function(x,y,z){
var tags = {
power:0,
north:0,
south:0,
east:0,
west:0
}
world.setTags(x,y,z,tags)
},
ondelete:function(x,y,z,prevTags){},
connectables: ["redstoneDust", "redstoneBlock", "redstoneLamp"],
connectable: function(x,y,z, d) {
var id = world.getBlock(x,y,z)
if(this.connectables.includes(blockData[id].name)) return true
if(id === blockIds.redstoneRepeater){//for later
var tags = world.getTags(x,y,z)
var canIt = false
switch(tags.facing){
case "north":
case "south":
canIt = d === "north" || d === "south"
break
case "east":
case "west":
canIt = d === "east" || d === "west"
}
return canIt
}
return false
}
},
{
name: "buffer",
textures: ["bufferTop", "bufferMiddle"],
onupdate: function(x,y,z){
setTimeout(() => {
var isOn = world.getBlock(x,y+1,z);
isOn = isOn === blockIds.redstoneDustOn || isOn === blockIds.redstoneBlock;
if(isOn && world.getBlock(x,y-1,z) === blockIds.redstoneDust ){
setTimeout(function(){world.setBlock(x,y-1,z, blockIds.redstoneDustOn)}, 500);
}
}, 10)
}
},
{ name: "soup"},
{ name: "soup2"},
{
name: "soup3",
transparent:true
},
{ name: "soup4"},
{ name: "randomSoup"},
{
name: "redStain",Name:"Red Stain",
transparent: true
},
{
name:"poision potion",
transparent:true,
crossShape:true,
},
{
name: "light",
Name: "Light",
textures: "none",
transparent:true,
lightLevel: 15,
solid: false,
iconTexture: "light_15",
flatIcon: true,
shadow: false,
noHitbox:true
},
{
name: "autumnLeaves",
Name: "Autumn Leaves",
transparent: true,
},
{
name: "darkLeaves",
Name: "Dark Leaves",
transparent: true,
},
{
name: "redBerryLeaves",
Name: "Red Berry Leaves",
transparent: true,
},
{
name: "blueBerryLeaves",
Name: "Blue Berry Leaves",
transparent: true,
},
{
name: "pinkLeaves",
Name: "Pink Leaves",
transparent: true,
},
{ name: "flowerOftheValley",
Name:"Lily of The Valley",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "poppy",
Name:"Poppy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "dandelion",
Name:"Dandelion",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "blueOrchid",
Name:"Blue Orchid",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
},
{ name: "pinkTulip",
Name:"Pink Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "orangeTulip",
Name:"Orange Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "redTulip",
Name:"Red Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "whiteTulip",
Name:"White Tulip",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "azureBluet",
Name:"Azure Bluet",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "cornFlower",
Name:"Cornflower",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "purpleFlower",
Name:"Purple Flower (i don't think this exsists in minecraft) (does it???)",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "allium",
Name:"Allium",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "oxeyeDaisy",
Name:"Oxeye Daisy",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
},
{ name: "lilac",
Name:"Lilac",
solid: false,
transparent: true,
shadow: false,
textures: "lilacTop",
tallcrossShape: true,
},
{ name: "roseBush",
Name:"Rose Bush",
solid: false,
transparent: true,
shadow: false,
textures: "roseBushTop",
tallcrossShape: true,
},
{ name: "peony",
Name:"Peony",
solid: false,
transparent: true,
shadow: false,
textures: "peonyTop",
tallcrossShape: true,
},
{ name: "witherRose",
Name:"Wither Rose (good for pvp)",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
ontouch: () => {witherEffect = 120; witherDamage = 1; witherTime = 2000}
},
{ name: "TallGrass",
Name:"Tall Grass",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
drop: "wheatSeeds",
dropAmount:[0,1],
dropSelfWhenSheared:true,
shearDropAmount:1
},
{ 
name: "oakDoor",
Name:"Oak Door",
transparent: true,
shadow: false,
textures: "oakDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "spruceDoor",
Name:"Spruce Door",
transparent: true,
shadow: false,
textures:"spruceDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "ironDoor",
Name:"Iron Door",
transparent: true,
shadow: false,
textures:"ironDoorBottom",
door:true,
woodSound:true,
breakTime: 15,
type:"rock1"
},
{
name: "darkOakDoor",
Name:"Dark Oak Door",
transparent: true,
shadow: false,
textures:"darkOakDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "birchDoor",
Name:"Birch Door",
transparent: true,
shadow: false,
textures:"birchDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "jungleDoor",
Name:"Jungle Door",
transparent: true,
shadow: false,
textures:"jungleDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "acaciaDoor",
Name:"Acacia Door",
transparent: true,
shadow: false,
textures:"acaciaDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "warpedDoor",
Name:"Warped Door",
transparent: true,
shadow: false,
textures:"warpedDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "crimsonDoor",
Name:"Crimson Door",
transparent: true,
shadow: false,
textures:"crimsonDoorBottom",
door:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "torch",
Name:"Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 13,
woodSound:true,
solid:false
},
{
name: "soulTorch",
Name:"Soul Torch",
transparent: true,
shadow: false,
torch: true,
lightLevel: 10,
woodSound:true,
solid:false
},
{
name: "lantern",
Name:"Lantern",
transparent: true,
shadow: false,
lightLevel: 13,
breakTime: 3,
type: "rock1",
iconTexture: "lanternIcon",
lantern: true,
digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
placeSound: ["block.lantern.place1", "block.lantern.place2","block.lantern.place3","block.lantern.place4","block.lantern.place5","block.lantern.place6"]
},
{
name: "soulLantern",
Name:"Soul Lantern",
transparent: true,
shadow: false,
lightLevel: 10,
breakTime: 3,
type: "rock1",
iconTexture:"soulLanternIcon",
lantern: true,
digSound: ["block.lantern.dig1", "block.lantern.dig2", "block.lantern.dig3", "block.lantern.dig4", "block.lantern.dig5", "block.lantern.dig6"],
placeSound: ["block.lantern.place1", "block.lantern.place2","block.lantern.place3","block.lantern.place4","block.lantern.place5","block.lantern.place6"]
},
{
name: "beacon",
Name:"Beacon",
transparent: true,
shadow: false,
beacon: true,
lightLevel: 15,
glassSound: true,breakTime:10,
},
{
name: "cactus",
Name:"Cactus",
textures: ["cactusBottom", "cactusTop", "cactusSide"],
transparent: true,
cactus: true,
damage: 1,
potCross: true,
onupdate:function(x,y,z,b){
needsSupportingBlocks(x,y,z,b)
}
},
{
name: "glassPane",
Name:"Glass Pane",
transparent: true,
shadow: false,
breakTime: 60,
pane:true,
textures: ["glassPaneTop","glassPaneTop","glass","glass","glassPaneSide","glassPaneSide"],
glassSound: true
},
{ name: "ladder",
Name:"Ladder",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,breaktime:1,type:"wood"
},
{ name: "vine",
Name:"Vine",
transparent: true,
shadow: false,
wallFlat: true,ladder:true,
noDrop:true,
dropSelfWhenSheared:true,
shearBreakTime:0.35
},
{
name: "Water",
textures:["Water","waterFlow"],
transparent: true,
liquid: true,
wet:true,
solid:false,
shadow: false, //to hide faces
semiTrans: true
},
{
name: "Lava",
textures:["Lava","lavaFlow"],
transparent: true,
liquid: true,
solid:false,
lightLevel:15,
damage:4,
burnPlayer:true,
dieMessage: () => username+" tried to swim in lava.",
shadow: false,
onupdate:function(x,y,z,b){
if (world.getBlock(x,y+1,z) === blockIds.Water) {
world.setBlock(x,y,z,blockIds.obsidian)
}
}
},
{
name: "craftingTable",
Name:"Crafting Table",
textures: ["oakPlanks","craftingTableTop","craftingTableFront","craftingTableSide"],
onclick: () => {changeScene("crafting"); releasePointer()},
woodSound: true,breakTime:3,type:"wood"
},
{
name: "crimsonNylium",Name:"Crimson Nylium",
textures: ["netherrack", "crimsonNyliumTop", "crimsonNyliumSide"],
nyliumSound: true,breakTime:3,type:"wood"
},
{
name: "warpedNylium",Name:"Warped Nylium",
textures: ["netherrack", "warpedNyliumTop", "warpedNyliumSide"],
nyliumSound: true,breakTime:3,type:"wood"
},
{
name: "crimsonStem",Name:"Crimson Stem",
textures: ["crimsonStemTop", "crimsonStemSide"],
stemSound: true,breakTime:3,type:"wood"
},
{
name: "warpedStem",Name:"Warped Stem",
textures: ["warpedStemTop", "warpedStemSide"],
stemSound: true,breakTime:3,type:"wood"
},
{ name: "netherWartBlock",Name:"Nether Wart Block",breakTime:1,
digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
{ name: "warpedWartBlock",Name:"Warped Wart Block",breakTime:1,
digSound: ["block.netherwart.dig1", "block.netherwart.dig2", "block.netherwart.dig3", "block.netherwart.dig4", "block.netherwart.dig5", "block.netherwart.dig6"],
stepSound: ["block.netherwart.step1", "block.netherwart.step2","block.netherwart.step3","block.netherwart.step4","block.netherwart.step5"]},
{ name: "shroomlight", Name:"Shroomlight",lightLevel:15,breakTime:2,
digSound: ["block.shroomlight.dig1", "block.shroomlight.dig2", "block.shroomlight.dig3", "block.shroomlight.dig4", "block.shroomlight.dig5"],
stepSound: ["block.shroomlight.step1", "block.shroomlight.step2","block.shroomlight.step3","block.shroomlight.step4","block.shroomlight.step5","block.shroomlight.step6"]},
{ 
name: "warpedFungus",Name:"Warped Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
},
{
name: "blackstone",Name:"Blackstone",
textures: ["blackstoneTop", "blackstone" ],
stoneSound: true, breakTime:10, type:"rock1"
},
{ name: "gildedBlackstone", Name:"Gilded Blackstone",stoneSound: true, breakTime:20, type:"rock1"},
{ name: "polishedBlackstoneBricks", Name:"Polished Blackstone Bricks",stoneSound: true, breakTime:10, type:"rock1"},
{ name: "chiseledPolishedBlackstone", Name:"Chiseled Polished Blackstone",stoneSound: true, breakTime:10, type:"rock1"},
{
name: "netheriteBlock",
Name:"Netherite Block",
type:"rock4",
breakTime:250,
digSound: ["block.netherite.dig1", "block.netherite.dig2", "block.netherite.dig3", "block.netherite.dig4"],
stepSound: ["block.netherite.step1", "block.netherite.step2","block.netherite.step3","block.netherite.step4","block.netherite.step5","block.netherite.step6"]
},
{
name: "basalt",
Name: "Basalt",
textures: [ "basaltTop", "basaltSide" ],
basaltSound: true, breakTime:10, type:"rock1"
},
{
name: "polishedBasalt",
Name: "Polished Basalt",
textures: [ "polishedBasaltTop", "polishedBasaltSide" ],
basaltSound: true, breakTime:10, type:"rock1"
},
{ name: "chain", Name:"Chain",transparent:true, shadow:false, chain:true, iconTexture:"chainIcon", breakTime:10, type:"rock1",
digSound: ["block.chain.dig1", "block.chain.dig2", "block.chain.dig3", "block.chain.dig4"],
stepSound: ["block.chain.step1", "block.chain.step2","block.chain.step3","block.chain.step4","block.chain.step5","block.chain.step6"]},
{ name: "warpedPlanks", woodSound:true, Name:"Warped Planks", breakTime:3, type:"wood"},
{ 
name: "warpedTrapdoor",
Name: "Warped Trapdoor",
transparent: true,
shadow: false,
trapdoor: true,
woodSound:true, breakTime:3, type:"wood"
},
{ name: "magma", Name:"Magma Block", lightLevel:15, breakTime:10, type:"rock1",
damage:1,
dieMessage: () => username+" discovered the floor was lava."},
{
name: "crimsonFungus",
Name: "Crimson Fungus",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
potCross: true,
digSound: ["block.fungus.dig1", "block.fungus.dig2", "block.fungus.dig3", "block.fungus.dig4", "block.fungus.dig5", "block.fungus.dig6"]
},
{ 
name: "warpedRoots",
Name: "Warped Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true
},
{ 
name: "crimsonRoots",
Name: "Crimson Roots",
transparent: true,
solid: false,
shadow: false,
crossShape: true,
rootSound: true
},
{ 
name: "twistingVines",
Name: "Twisting Vines Top",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true
},
{ 
name: "twistingVinesPlant",
Name: "Twisting Vines",
transparent: true,
solid: false,
shadow: false,
transparent: true,
crossShape: true
},
{ 
name: "weepingVines",
Name: "Weeping Vines Bottom",
transparent: true,
solid: false,
shadow: false,
crossShape: true
},
{ 
name: "weepingVinesPlant",
Name: "Weeping Vines",
transparent: true,
solid: false,
shadow: false,
crossShape: true
},
{ 
name: "netherSprouts",
Name: "Nether Sprouts",
solid: false,
shadow: false,
transparent: true,
crossShape: true,
digSound: ["block.nether_sprouts.dig1", "block.nether_sprouts.dig2", "block.nether_sprouts.dig3", "block.nether_sprouts.dig4"],
stepSound: ["block.nether_sprouts.step1", "block.nether_sprouts.step2","block.nether_sprouts.step3","block.nether_sprouts.step4","block.nether_sprouts.step5"]
},
{ name: "stoneButton", Name:"Stone Button",textures:"stone", button:true, transparent: true, breakTime:10, type:"rock1"},
{ 
name: "RespawnAnchorOff",
Name: "Respawn Anchor (Off)",
textures: ["respawnAnchorBottom", "respawnAnchorTopOff", "respawnAnchorSide0"], breakTime:20, type:"rock2",
//onupdate: (x,y,z) => {if(world.type !== "nether"){explode(x,y,z,2)}}
},
{ 
name: "RespawnAnchor1",
Name: "Respawn Anchor (#1)",
textures: ["respawnAnchorBottom", "respawnAnchorTop1", "respawnAnchorSide1"], breakTime:20, type:"rock2",
drop: "RespawnAnchorOff",
//hidden: true
},
{ 
name: "RespawnAnchor2",
Name: "Respawn Anchor (#2)",
textures: ["respawnAnchorBottom", "respawnAnchorTop2", "respawnAnchorSide2"], breakTime:20, type:"rock2",
drop: "RespawnAnchorOff",
//hidden: true
},
{ 
name: "RespawnAnchor3",
Name: "Respawn Anchor (#3)",
textures: ["respawnAnchorBottom", "respawnAnchorTop3", "respawnAnchorSide3"], breakTime:20, type:"rock2",
drop: "RespawnAnchorOff",
//hidden: true
},
{ 
name: "RespawnAnchor",
Name: "Respawn Anchor (filled)",
textures: ["respawnAnchorBottom", "respawnAnchorTop", "respawnAnchorSide4"], breakTime:20, type:"rock2",
//hidden: true
},
{
name:"redBed",
Name:"Red Bed",
textures: "bedbottom",
iconTexture: "bedIcon",
flatIcon: true,
onclick: (x,y,z) => {
if(world.type !== ""){explode(x,y,z,5); return}
world.spawnPoint.x=x
world.spawnPoint.y=y
world.spawnPoint.z=z
Messages.add("You can't sleep in beds yet")
Messages.add("Respawn point set")
},
transparent: true,
bed: true,
bounciness: 0.6
},
{
name: "flintAndSteel",
Name:"Flint & Steel",
textures: "flintAndSteel",
item: true,
onuse: (x,y,z, block, replaceItem, useDurability) => {
if(block === blockIds.tnt){
blockData[blockIds.tnt].explode(x,y,z)
}else{
var pos = getPosition()
if (world.getBlock(pos[0]-1,pos[1],pos[2]) === blockIds.obsidian || world.getBlock(pos[0]+1,pos[1],pos[2]) === blockIds.obsidian || world.getBlock(pos[0],pos[1],pos[2]-1) === blockIds.obsidian || world.getBlock(pos[0],pos[1],pos[2]+1) === blockIds.obsidian) {
world.setBlock(pos[0],pos[1],pos[2],blockIds.portal)
} else {
world.setBlock(pos[0],pos[1],pos[2],blockIds.fire)
}
useDurability(1)
playSound("block.fire.ignite",0,posSound(x,y,z))
if(multiplayer) send({type:"playSound", data:"block.fire.ignite", x:x,y:y,z:z})
}
},
durability:64,
stackSize:1
},
{
name: "barrier",
Name:"That Invisible Block with a ?? Icon",
textures: "none",
iconTexture: "barrier",
flatIcon:true,
transparent:true,
breakTime:99999,
},
{
name: "oakSapling",
Name:"Oak Sapling",
crossShape: true,
potCross: true,
transparent: true,
solid: false,
shadow:false,
grow: function(wx,wy,wz){
let i=wx, j=wy, k=wz
var ground = wy//this.chunk.tops[i * 16 + k]
var top = ground + floor(4.5 + (Math.random()*2.5) )
var rand = floor(Math.random()*4096)
let tree = blockIds.oakLog
let leaf = blockIds.oakLeaves
let groundBlock = blockIds.dirt
//Center
for (let j = ground + 1; j <= top; j++) {
world.setBlock(i, j, k, tree)
}
world.setBlock(i, top + 1, k, leaf)
world.setBlock(i, ground, k, groundBlock)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top - 2, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top - 2, wz + z, leaf)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top - 1, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top - 1, wz + z, leaf)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top, wz + z, leaf)
}
}
}
}
//Top leaves
world.setBlock(wx + 1, top + 1, wz, leaf)
world.setBlock(wx, top + 1, wz - 1, leaf)
world.setBlock(wx, top + 1, wz + 1, leaf)
world.setBlock(wx - 1, top + 1, wz, leaf)
}
},
{ 
name: "crimsonTrapdoor",
Name:"Crimson Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "oakTrapdoor",
Name:"Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "spruceTrapdoor",
Name:"Spruce Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "darkOakTrapdoor",
Name:"Dark Oak Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "birchTrapdoor",
Name:"Birck Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "jungleTrapdoor",
Name:"Jungle Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "acaciaTrapdoor",
Name:"Acaica Trapdoor",
transparent: true,
trapdoor: true,
woodSound: true, breakTime:3, type:"wood"
},
{ 
name: "ironTrapdoor",
Name:"Iron Trapdoor",
transparent: true,
trapdoor: true,
stoneSound: true, breakTime:10, type:"rock1"
},
{ 
name: "cryingObsidian",
Name:"Obsidian: ??",
shadow: false,
lightLevel: 10, breakTime:40, type:"rock3"
},
{ name: "netherGoldOre",
Name:"Nether Gold Ore",breakTime:10, type:"rock1",
digSound: ["block.nether_ore.dig1", "block.nether_ore.dig2", "block.nether_ore.dig3", "block.nether_ore.dig4"],
stepSound: ["block.nether_ore.step1", "block.nether_ore.step2","block.nether_ore.step3","block.nether_ore.step4","block.nether_ore.step5"],
drop: "goldNugget",
dropAmount: [1,3]
},
{
name: "flowerPot",
Name:"Flower Pot",
transparent: true,
shadow: false,
pot: true,
iconTexture:"flowerPotIcon",
flatIcon:true
},
{
name: "acaciaSapling",
Name:"Acacia Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true
},
{
name: "birchSapling",
Name:"Birch Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true,
grow:function(wx,wy,wz){
let i=wx, j=wy, k=wz
var ground = wy//this.chunk.tops[i * 16 + k]
var top = ground + floor(4.5 + (Math.random()*2.5) )
var rand = floor(Math.random()*4096)
let tree = blockIds.birchLog
let leaf = blockIds.birchLeaves
let groundBlock = blockIds.dirt
//Center
for (let j = ground + 1; j <= top; j++) {
world.setBlock(i, j, k, tree)
}
world.setBlock(i, top + 1, k, leaf)
world.setBlock(i, ground, k, groundBlock)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top - 2, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top - 2, wz + z, leaf)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top - 1, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top - 1, wz + z, leaf)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.setBlock(wx + x, top, wz + z, leaf)
}
} else {
world.setBlock(wx + x, top, wz + z, leaf)
}
}
}
}
//Top leaves
world.setBlock(wx + 1, top + 1, wz, leaf)
world.setBlock(wx, top + 1, wz - 1, leaf)
world.setBlock(wx, top + 1, wz + 1, leaf)
world.setBlock(wx - 1, top + 1, wz, leaf)
}
},
{
name: "darkOakSapling",
Name:"Dark Oak Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true
},
{
name: "jungleSapling",
Name:"Jungle Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true
},
{
name: "spruceSapling",
Name:"Spruce Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true
},
{
name: "blueOrchidPot",
Name: "Blue Orchid Pot",
transparent: true,
shadow: false,
solid: false,
potCross: true
},
{
name: "warpedRootsPot",
Name: "Warped Roots Pot",
transparent: true,
shadow: false,
solid: false,
potCross: true
},
{
name: "crimsonRootsPot",
Name: "Crimson Roots Pot",
transparent: true,
shadow: false,
solid: false,
potCross: true
},
{ name: "whiteCarpet", Name: "White Carpet",textures: "whiteWool", carpet: true, clothSound:true},
{ name: "orangeCarpet", Name: "Orange Carpet",textures: "orangeWool", carpet: true, clothSound:true},
{ name: "magentaCarpet", Name: "Magenta Carpet",textures: "magentaWool", carpet: true, clothSound:true},
{ name: "lightBlueCarpet", Name: "Light Blue Carpet",textures: "lightBlueWool", carpet: true, clothSound:true},
{ name: "yellowCarpet", Name: "Yellow Carpet",textures: "yellowWool", carpet: true, clothSound:true},
{ name: "limeCarpet", Name: "Lime Carpet",textures: "limeWool", carpet: true, clothSound:true},
{ name: "pinkCarpet", Name: "Pink Carpet",textures: "pinkWool", carpet: true, clothSound:true},
{ name: "grayCarpet", Name: "Gray Carpet",textures: "grayWool", carpet: true, clothSound:true},
{ name: "lightGrayCarpet", Name: "Light Gray Carpet",textures: "lightGrayWool", carpet: true, clothSound:true},
{ name: "cyanCarpet", Name: "Cyan Carpet",textures: "cyanWool", carpet: true, clothSound:true},
{ name: "purpleCarpet", Name: "Purple Carpet",textures: "purpleWool", carpet: true, clothSound:true},
{ name: "blueCarpet", Name: "Blue Carpet",textures: "blueWool", carpet: true, clothSound:true},
{ name: "brownCarpet", Name: "Brown Carpet",textures: "brownWool", carpet: true, clothSound:true},
{ name: "greenCarpet", Name: "Green Carpet",textures: "greenWool", carpet: true, clothSound:true},
{ name: "redCarpet", Name: "Red Carpet",textures: "redWool", carpet: true, clothSound:true},
{ name: "blackCarpet", Name: "Black Carpet",textures: "blackWool", carpet: true, clothSound:true},
{ name: "polishedBlackstone", Name: "Polished Blackstone",stoneSound:true},
{ name: "chiseledNetherBricks",Name: "Chiseled Nether Bricks",
digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
{ name: "crackedNetherBricks",Name: "Cracked Nether Bricks",
digSound: ["block.nether_bricks.dig1", "block.nether_bricks.dig2", "block.nether_bricks.dig3", "block.nether_bricks.dig4", "block.nether_bricks.dig5", "block.nether_bricks.dig6"],
stepSound: ["block.nether_bricks.step1", "block.nether_bricks.step2","block.nether_bricks.step3","block.nether_bricks.step4","block.nether_bricks.step5","block.nether_bricks.step6"]},
{ name: "smoothBasalt", Name: "Smooth Basalt",basaltSound: true},
{
name: "oakLogSW",Name: "Oak Log (SW)",
textures: ["logSide","logSide","logTop","oakLogSW"],
rotate: true, woodSound:true
},
{
name: "acaciaLogSW",Name: "Acacia Log (SW)",
textures: ["acaciaLogSide","acaciaLogSide","acaciaLogTop","acaciaLogSW"],
rotate: true, woodSound:true
},
{
name: "birchLogSW",Name: "Birch Log (SW)",
textures: ["birchLogSide","birchLogSide","birchLogTop","birchLogSW"],
rotate: true, woodSound:true
},
{
name: "darkOakLogSW",Name: "Dark Oak Log (SW)",
textures: ["darkOakLogSide","darkOakLogSide","darkOakLogTop","darkOakLogSW"],
rotate: true, woodSound:true
},
{
name: "jungleLogSW",Name: "Jungle Log (SW)",
textures: ["jungleLogSide","jungleLogSide","jungleLogTop","jungleLogSW"],
rotate: true, woodSound:true
},
{
name: "spruceLogSW",Name: "Spruce Log (SW)",
textures: ["spruceLogSide","spruceLogSide","spruceLogTop","spruceLogSW"],
rotate: true, woodSound:true
},
{
name: "crimsonStemSW",Name: "Crimson Stem (SW)",
textures: ["crimsonStemSide","crimsonStemSide","crimsonStemTop","crimsonStemSW"],
rotate: true, stemSound:true
},
{
name: "warpedStemSW",Name: "Warped Stem (SW)",
textures: ["warpedStemSide","warpedStemSide","warpedStemTop","warpedStemSW"],
rotate: true, stemSound:true
},
{
name: "basaltSW",Name: "Basalt (SW)",
textures: ["basaltSide","basaltSide","basaltTop","basaltSideSW"],
rotate: true, basaltSound:true
},
{
name: "polishedBasaltSW",Name: "Polished Basalt (SW)",
textures: ["polishedBasaltSide","polishedBasaltSide","polishedBasaltTop","polishedBasaltSideSW"],
rotate: true, basaltSound: true
},
{ name:"crimsonPlanks",Name: "Crimson Planks",woodSound:true,breakTime:3, type:"wood"},
{
name:"deadBush",
Name:"Dead Bush",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
drop: "stick",
dropAmount: [0,2],
dropSelfWhenSheared:true,
shearDropAmount:1
},
{ name:"stick", Name:"Stick", item:true },
{ name:"coal", Name:"Coal", item:true },
{ name:"ironIngot", Name:"Iron Ingot", item:true },
{ name:"copperIngot", Name:"Copper Ingot", item:true },
{ name:"goldIngot", Name:"Gold Ingot", item:true },
{ name:"diamond", Name:"Diamond", item:true },
{ name:"lapisLazuli", Name:"Lapis Lazuli", item:true },
{ name:"emerald", Name:"Emerald", item:true },
{ name:"copperOre", Name:"Copper Ore", breakTime:15, drop:"rawCopper", dropAmount:[2,5], type:"rock2", stoneSound:true },
{ name:"rawIron", Name:"Raw Iron", item:true },
{ name:"rawCopper", Name:"Raw Copper", item:true },
{ name:"rawGold", Name:"Raw Gold", item:true },
{
name: "netherWart",
Name:"Nether Wart",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"netherWartIcon"
},
{
name: "wheat",
Name:"Wheat",
transparent: true,
shadow: false,
solid: false,
crop: true,
flatIcon:true,
iconTexture:"wheatIcon",
fullDrop:["wheat","wheatSeeds"],
drop:"wheatSeeds",
textures:new Array(6).fill('wheatStage0'),
textures1:new Array(6).fill('wheatStage1'),
textures2:new Array(6).fill('wheatStage2'),
textures3:new Array(6).fill('wheatStage3'),
textures4:new Array(6).fill('wheatStage4'),
textures5:new Array(6).fill('wheatStage5'),
textures6:new Array(6).fill('wheatStage6'),
textures7:new Array(6).fill('wheat'),
},
{
name: "lodestone",
Name:"Lodestone",
textures: ["lodestoneTop", "lodestoneSide"]
},
{
name: "anvil",
Name:"Anvil",
transparent: true,breakTime:30, type:"rock2",
anvil: true,
digSound: "block.anvil.land",
stepSound: ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
onupdate: function(x,y,z,b){
fall(x,y,z,b)
},
},
{ name: "slime",
Name:"Slime",
transparent: true,
shadow: false,
bounciness: 0.6,
speedFactor: 0.5
},
{ 
name:"soulSoil",
Name:"Soul Soil",
speedFactor: 0.5,
},
{ name:"blueIce", Name:"Blue Ice", slide:0.9, glassSound: true},
{ name:"ice", Name:"Ice", transparent:true, shadow:false, slide:0.9, glassSound: true},
{ name:"packedIce", Name:"Packed Ice", slide:0.9, glassSound: true},
{ name:"calcite", Name:"Calcite" },
{
name:"furnace",
Name:"Furnace",
textures: ["furnaceTop","furnaceTop","furnaceSide","furnaceFront","furnaceSide","furnaceSide"],
rotate: true,
onclick: (x,y,z) => {
furnaceData.x = x
furnaceData.y = y
furnaceData.z = z
changeScene("furnace")
releasePointer()
},
stoneSound:true,breakTime:10, type:"rock1"
},
{
name:"blastFurnace",
Name:"Blast Furnace",
textures: ["blastFurnaceTop","blastFurnaceTop","blastFurnaceSide","blastFurnaceFront","blastFurnaceSide","blastFurnaceSide"],
rotate: true,breakTime:10, type:"rock1"
},
{
name:"smoker",
Name:"Smoker",
textures: ["smokerBottom","smokerTop","smokerSide","smokerFront","smokerSide","smokerSide"],
rotate: true,breakTime:10, type:"rock1"
},
{
name:"noteBlock",
Name:"Note Block",breakTime:3, type:"wood"
},
{
name:"jukebox",
Name:"Jukebox",breakTime:3, type:"wood",
textures: ["jukeboxTop","jukeboxSide"]
},
{
name:"loom",
Name:"Loom",
textures: ["loomBottom","loomTop","loomFront","loomSide","loomSide","loomSide"],
rotate: true
},
{
name:"sandstone",
Name:"Sandstone",breakTime:3, type:"wood",
textures: ["sandstoneBottom", "sandstoneTop", "sandstone"]
},
{ name:"chiseledSandstone",
Name:"Chiseled Sandstone",breakTime:3, type:"wood",
textures: ["sandstoneBottom", "sandstoneTop","chiseledSandstone"]
},
{ name:"cutSandstone",
Name:"Cut Sandstone",breakTime:3, type:"wood",
textures: ["sandstoneBottom", "sandstoneTop","cutSandstone"]
},
{ name:"smoothSandstone", Name:"Smooth Sandstone", textures:"sandstoneTop", breakTime:3, type:"wood"},
{
name: "DoubleTallGrass",
Name:"Tall Grass",
solid: false,
transparent: true,
shadow: false,
textures: "tallGrassTop",
tallcrossShape: true,
drop:function(){
if(rand() > 0.9){
return "tomatoSeeds"
}else{
return "DoubleTallGrass"
}
}
},
{
name:"apple",
Name:"Apple",
item:true,
edible: true,
eatWhenFull: false,
food: 4,
saturation: 2.4,
eatResult: "appleCore"
},
{
name:"woodenSword",
Name:"Wooden Swords (not sharp)",
item: true,
sword: true,
durability: 59,
attackDamage: 4
},
{
name:"stoneSword",
Name:"Stone Sword",
item: true,
sword: true,
durability: 131,
attackDamage: 5
},
{
name:"ironSword",
Name:"Iron Sword",
item: true,
sword: true,
durability: 250,
attackDamage: 6
},
{
name:"goldenSword",
Name:"Golden Sword",
item: true,
sword: true,
durability: 32,
attackDamage: 4
},
{
name:"diamondSword",
Name:"Diamond Sword",
item: true,
sword: true,
durability: 1561,
attackDamage: 7
},
{
name:"netheriteSword",
Name:"Netherite Sword",
item: true,
sword: true,
durability: 2031,
attackDamage: 8
},
{
name:"woodenPickaxe",
Name:"Wooden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 2,
durability: 59,
attackDamage: 2
},
{
name:"stonePickaxe",
Name:"Stone Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 4,
durability: 131,
attackDamage: 2
},
{
name:"ironPickaxe",
Name:"Iron Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 6,
durability: 250,
attackDamage: 3
},
{
name:"goldenPickaxe",
Name:"Golden Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 12,
durability: 32,
attackDamage: 4
},
{
name:"diamondPickaxe",
Name:"Diamond Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 8,
durability: 1561,
attackDamage: 5
},
{
name:"netheritePickaxe",
Name:"Netherite Pickaxe",
item: true,
pickaxe: true,
mineSpeed: 9,
durability: 2031,
attackDamage: 6
},
{
name:"woodenAxe",
Name:"Wooden Axe",
item: true,
axe: true,
durability: 59,
mineSpeed:2,
attackDamage: 7,
attackSpeed:0.8
},
{
name:"stoneAxe",
Name:"Stone Axe",
item: true,
axe: true,
durability: 131,
mineSpeed:4,
attackDamage: 9,
attackSpeed:0.8
},
{
name:"ironAxe",
Name:"Iron Axe",
item: true,
axe: true,
durability: 250,
mineSpeed:6,
attackDamage: 9,
attackSpeed:0.9
},
{
name:"goldenAxe",
Name:"Golden Axe",
item: true,
axe: true,
durability: 32,
mineSpeed:12,
attackDamage: 7,
attackSpeed:1
},
{
name:"diamondAxe",
Name:"Diamond Axe",
item: true,
axe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 9,
attackSpeed:1
},
{
name:"netheriteAxe",
Name:"Netherite Axe",
item: true,
axe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 10,
attackSpeed:1
},
{
name:"woodenShovel",
Name:"Wooden Shovel",
item: true,
shovel: true,
durability: 59,
mineSpeed:2,
attackDamage: 2
},
{
name:"stoneShovel",
Name:"Stone Shovel",
item: true,
shovel: true,
durability: 131,
mineSpeed:3.6,
attackDamage: 4
},
{
name:"ironShovel",
Name:"Iron Shovel",
item: true,
shovel: true,
durability: 250,
mineSpeed:6,
attackDamage: 4
},
{
name:"goldenShovel",
Name:"Golden Shovel",
item: true,
shovel: true,
durability: 32,
mineSpeed:12,
attackDamage: 2
},
{
name:"diamondShovel",
Name:"Diamond Shovel",
item: true,
shovel: true,
durability: 1561,
mineSpeed:8,
attackDamage: 5
},
{
name:"netheriteShovel",
Name:"Netherite Shovel",
item: true,
shovel: true,
durability: 2031,
mineSpeed:9,
attackDamage: 6
},
{
name:"woodenHoe",
Name:"Wooden Hoe",
item: true,
hoe: true,
durability: 59,
mineSpeed:2,
attackDamage: 1,
attackSpeed:1
},
{
name:"stoneHoe",
Name:"Stone Hoe",
item: true,
hoe: true,
durability: 131,
mineSpeed:4,
attackDamage: 1,
attackSpeed:2
},
{
name:"ironHoe",
Name:"Iron Hoe",
item: true,
hoe: true,
durability: 250,
mineSpeed:6,
attackDamage: 1,
attackSpeed:3
},
{
name:"goldenHoe",
Name:"Golden Hoe",
item: true,
hoe: true,
durability: 32,
mineSpeed:12,
attackDamage: 1,
attackSpeed:1
},
{
name:"diamondHoe",
Name:"Diamond Hoe",
item: true,
hoe: true,
durability: 1561,
mineSpeed:8,
attackDamage: 1,
attackSpeed:4
},
{
name:"netheriteHoe",
Name:"Nethrite Hoe",
item: true,
hoe: true,
durability: 2031,
mineSpeed:9,
attackDamage: 1,
attackSpeed:4
},
{ name:"flint", Name:"Flint", item:true },
{
name:"mossBlock",Name: "Moss Block",
breakTime:0.15,
type: "plant2"
},
{
name:"mossCarpet",Name: "Moss Carpet",
textures: "mossBlock",
breakTime:0.15,
carpet: true
},
{
name: "caveVines",Name: "Cave Vines",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
},
{
name: "caveVinesPlant",Name: "Cave Vines Plant",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
},
{
name: "caveVinesLit",Name: "Lit Cave Vines",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14
},
{
name: "caveVinesPlantLit",Name: "Lit Cave Vines Plant",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
lightLevel: 14
},
{
name:"sporeBlossom",
Name:"Spore Blossom",
sporeBlossom: true,
shadow:false,
transparent: true
},
{
name: "rootedDirt",Name: "Rooted Dirt",breakTime:1,
},
{
name: "hangingRoots",Name: "Hanging Roots",
solid: false,
transparent: true,
shadow: false,
crossShape: true
},
{
name:"azalea",
Name:"Azalea",
textures: ["azaleaTop", "azaleaSide"],
potTex:["pottedAzaleaBushTop","pottedAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true
},
{
name:"floweringAzalea",
Name:"Flowering Azalea",
textures: ["floweringAzaleaTop","floweringAzaleaSide"],
potTex:["pottedFloweringAzaleaBushTop","pottedFloweringAzaleaBushSide"],
azalea: true,
transparent: true,
potCross:true
},
{
name:"sunflower",
Name:"Sunflower",
textures:["sunflowerBack","sunflowerFront","sunflowerTop"],
sunflower: true,
transparent:true,
shadow:false,
iconTexture: "sunflowerFront",
solid:false
},
{
name: "bucket",
Name:"Bucket",
item: true,
onuse: (x,y,z, block, replaceItem) => {
if(blockData[block].name === "Water"){
replaceItem(blockIds.waterBucket)
world.setBlock(x,y,z,0)
}
if(blockData[block].name === "Lava"){
replaceItem(blockIds.lavaBucket)
world.setBlock(x,y,z,0)
}
if(block === blockIds.powderSnow){
replaceItem(blockIds.powderSnowBucket)
world.setBlock(x,y,z,0)
}
},
stackSize: 1,
allHitbox: true
},
{
name: "waterBucket",
Name:"Water Bucket",
item: true,
onuse: (x,y,z, block, replaceItem) => {
if(survival)replaceItem(blockIds.bucket)
var pos = getPosition()
world.setBlock(pos[0],pos[1],pos[2],blockIds.Water)
},
stackSize: 1
},
{
name: "lavaBucket",
Name:"Lava Bucket",
item: true,
onuse: (x,y,z, block, replaceItem) => {
if(survival)replaceItem(blockIds.bucket)
var pos = getPosition()
if (world.getBlock(pos[0],pos[1]+1,pos[2]) === blockIds.Water) {
world.setBlock(pos[0],pos[1],pos[2],blockIds.obsidian)
} else {
world.setBlock(pos[0],pos[1],pos[2],blockIds.Lava)
}
},
stackSize: 1
},
{
name: "cowSpawnEgg",Name: "minekhan:cow_spawn_egg",
item: true,
onuse: (x,y,z, block, replaceItem) => {
world.addEntity(new Cow(p2.x,p2.y,p2.z))
},
minusOnUse:true
},
{
name: "pigSpawnEgg",Name:"minekhan:pig_spawn_egg",
item: true,
onuse: (x,y,z, block, replaceItem) => {
world.addEntity(new Pig(p2.x,p2.y,p2.z))
},
minusOnUse:true
},
{
name:"sugarCane",
Name:"Sugarcane",
iconTexture: "sugarCaneIcon",
crossShape: true,
solid: false,
transparent: true,
shadow: false,
},
{ name:"azaleaLeaves",Name:"Azalea Leaves",
transparent: true,
breakTime: 0,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{ name:"floweringAzaleaLeaves",Name:"Flowering Azalea Leaves",
transparent: true,
breakTime: 0,
type:"plant2",
drop: function(){
if(rand() > 0.05){
let r = floor(rand(2))
if(r === 0) return "azalea"
else return "floweringAzalea"
}
},
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{name:"tuff",Name:"Tuff",breakTime:1.5},
{name:"deepslate", Name:"Deepslate", textures:["deepslateTop","deepslate"],breakTime:3,deepslateSound:true},
{name:"cobbledDeepslate", Name:"Cobbled Deepslate",deepslateSound:true},
{name:"chiseledDeepslate", Name:"Chiseled Deepslate",breakTime:3.5,deepslateSound:true},
{name:"polishedDeepslate",Name:"Polished Deepslate",breakTime:3.5,deepslateSound:true},
{name:"deepslateTiles",Name:"Deepslate Tiles",breakTime:3.5,deepslateSound:true},
{name:"deepslateBricks",Name:"Deepslate Bricks",breakTime:3.5,deepslateBricksSound:true},
{name:"crackedDeepslateTiles",Name:"Cracked Deepslate Tiles",deepslateSound:true},
{name:"crackedDeepslateBricks",Name:"Cracked Deepslate Bricks",deepslateBricksSound:true},
{name:"deepslateCoalOre",Name:"Deepslate Coal Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateIronOre",Name:"Deepslate Iron Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateCopperOre",Name:"Deepslate Copper Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateGoldOre",Name:"Deepslate Gold Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateDiamondOre",Name:"Deepslate Diamond Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateRedstoneOre",Name:"Deepslate Redstone Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateEmeraldOre",Name:"Deepslate Emerald Ore",breakTime:22.5,deepslateSound:true},
{name:"deepslateLapisOre",Name:"Deepslate Lapis Lazuli Ore",breakTime:22.5,deepslateSound:true},
{name:"amethystBlock",Name:"Amethyst Block", amethystSound: true},
{name:"amethystShard",Name:"Amythest Shard",item:true},
{name:"buddingAmethyst",Name:"Budding Amethyst", amethystSound: true},
{name:"smallAmethystBud",Name:"Small Amethyst Bud",sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true
},
{name:"mediumAmethystBud",Name:"Medium Amethyst Bud",sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true
},
{name:"largeAmethystBud",Name:"Large Amethyst Bud",sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true
},
{name:"amethystCluster",Name:"Amethyst Cluster",sideCross:true,
solid: false,
transparent: true,
shadow: false,
amethystClusterSound: true,
drop: "amethystShard"
},
{
name:"snowBlock",
Name:"Block of Snow",
textures:"snow",
breakTime: 1,
drop:"snowball",
dropAmount: 4
},
{
name:"snow",
Name:"Snow Layer",
layers: true,
transparent:true,
drop:"snowball",
breakTime: 0.5,
onupdate: function(x,y,z,b){
fall(x,y,z,b)
},
},
{
name:"powderSnow",
Name:"Powder Snow",
solid:false,
powder: true,
breakTime: 1.5,
drop:"air",
transparent:true
},
{
name:"snowball",
Name:"Snowball",
item: true,
onuse:function(){
var pd = p.direction
world.addEntity(new Snowball(p.x+pd.x,p.y+pd.y,p.z+pd.z, pd.x*0.8, pd.y*0.8, pd.z*0.8))
},
minusOnUse:true,
useAnywhere:true
},
{
name:"powderSnowBucket",
Name:"Powder Snow Bucket",
item:true,
onuse: (x,y,z, block, replaceItem) => {
if(survival)replaceItem(blockIds.bucket)
var pos = getPosition()
world.setBlock(pos[0],pos[1],pos[2],blockIds.powderSnow)
},
stackSize: 1
},
{
name:"bread",
Name:"Bread",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 11
},
{
name:"boneBlock",Name:"Bone Block",
textures:["boneBlockTop","boneBlockSide"],breakTime:3, type:"wood"
},
{
name:"farmland",
Name:"Farmland",
textures:["dirt","farmland","dirt"],breakTime:1,
_1PixLower: true
},
{
name:"glowBerries",
Name:"Glow Berries",
edible: true,
item:true,
eatWhenFull: false,
food: 2,
saturation: 0.4
},
{
name:"hayBlock",
Name:"Hay Bale",
textures:["hayBlockTop","hayBlockSide"],breakTime:1, type:"plant2",
type:"plant2"
},
{
name:"hayBlockSW",Name: "Hay Bale (SW)",
textures: ["hayBlockSide","hayBlockSide","hayBlockTop","hayBlockSW"],
rotate: true,
},
{
name: "strippedOakLog",Name: "Stripped Oak Log",
textures: ["strippedOakLogTop", "strippedOakLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedOakLogSW",Name: "Stripped Oak Log (SW)",
textures: ["strippedOakLog", "strippedOakLog", "strippedOakLogTop","strippedOakLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name: "strippedBirchLog",Name: "Stripped Birch Log",
textures: ["strippedBirchLogTop", "strippedBirchLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedBirchLogSW",Name: "Stripped Birch Log (SW)",
textures: ["strippedBirchLog", "strippedBirchLog", "strippedBirchLogTop","strippedBirchLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name: "strippedAcaciaLog",Name: "Stripped Acacia Log",
textures: ["strippedAcaciaLogTop", "strippedAcaciaLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedAcaciaLogSW",Name: "Stripped Acacia Log (SW)",
textures: ["strippedAcaciaLog", "strippedAcaciaLog", "strippedAcaciaLogTop","strippedAcaciaLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name: "strippedJungleLog",Name: "Stripped Jungle Log",
textures: ["strippedJungleLogTop", "strippedJungleLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedJungleLogSW",Name: "Stripped Jungle Log (SW)",
textures: ["strippedJungleLog", "strippedJungleLog", "strippedJungleLogTop","strippedJungleLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name: "strippedSpruceLog",Name: "Stripped Spruce Log",
textures: ["strippedSpruceLogTop", "strippedSpruceLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedSpruceLogSW",Name: "Stripped Spruce Log (SW)",
textures: ["strippedSpruceLog", "strippedSpruceLog", "strippedSpruceLogTop","strippedSpruceLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name: "strippedDarkOakLog",Name: "Stripped Dark Oak Log",
textures: ["strippedDarkOakLogTop", "strippedDarkOakLog"],
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedDarkOakLogSW",Name: "Stripped Dark Oak Log (SW)",
textures: ["strippedDarkOakLog", "strippedDarkOakLog", "strippedDarkOakLogTop","strippedDarkOakLogSW"],
breakTime:3,
woodSound:true,
type:"wood",
rotate:true
},
{
name:"boneBlockSW",Name: "Bone Block (SW)",
textures:["boneBlockSide","boneBlockSide","boneBlockTop","boneBlockSW"],
rotate:true
},
{
name:"redMushroom",
Name:"Red Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1
},
{
name:"brownMushroom",
Name:"Brown Mushroom",
solid: false,
transparent: true,
shadow: false,
potCross: true,
crossShape: true,
lightLevel:1
},
{
name:"mushroomStem",Name: "Mushroom Stem",
mushroomBlock:true
},
{
name:"redMushroomBlock",Name: "Red Mushroom Block",
mushroomBlock:true
},
{
name:"brownMushroomBlock",Name: "Brown Mushroom Block",
mushroomBlock:true
},
{
name:"mycelium",
Name:"Mycelium",
textures:["dirt","myceliumTop","myceliumSide"],
type:"ground"
},
{
name:"terracotta",
Name:"Terracotta"
},
{
name:"redTerracotta",
Name:"Terracotta with watermelon juice"
},
{
name:"blueTerracotta",
Name:"Terracotta with blueberry juice"
},
{
name:"cyanTerracotta",
Name:"Terracotta with cyan colored fruit punch"
},
{
name:"grayTerracotta",
Name:"Dusty Terracotta"
},
{
name:"limeTerracotta",
Name:"Terracotta with leaf juice"
},
{
name:"pinkTerracotta",
Name:"Terracotta with fruit punch"
},
{
name:"blackTerracotta",
Name:"Terracotta painted black"
},
{
name:"brownTerracotta",
Name:"Dirty Terracotta"
},
{
name:"greenTerracotta",
Name:"Terracotta with some other leaf juice"
},
{
name:"whiteTerracotta",
Name:"Terracotta with flour"
},
{
name:"orangeTerracotta",
Name:"Orange Terracotta"
},
{
name:"purpleTerracotta",
Name:"Purple Terracotta"
},
{
name:"yellowTerracotta",
Name:"Terracotta with lemon juice"
},
{
name:"magentaTerracotta",
Name:"Magenta Terracotta"
},
{
name:"lightBlueTerracotta",
Name:"Light Blue Terracotta"
},
{
name:"lightGrayTerracotta",
Name:"Light Gray Terracotta"
},
{
name:"redGlazedTerracotta",
rotate:true,
Name:"Watermelon Swirl"
},
{
name:"blueGlazedTerracotta",
rotate:true,
Name:"Blue Fan"
},
{
name:"cyanGlazedTerracotta",
rotate:true,
Name:"Creeper in the skies"
},
{
name:"grayGlazedTerracotta",
rotate:true,
Name:"Bunch of Dust"
},
{
name:"limeGlazedTerracotta",
rotate:true,
Name:"Overlapping lilies"
},
{
name:"pinkGlazedTerracotta",
rotate:true,
Name:"Pink turtle shell"
},
{
name:"blackGlazedTerracotta",
rotate:true,
Name:"Red monster"
},
{
name:"brownGlazedTerracotta",
rotate:true,
Name:"Mudslide in the ocean"
},
{
name:"greenGlazedTerracotta",
rotate:true,
Name:"Camouflaged monster"
},
{
name:"whiteGlazedTerracotta",
rotate:true,
Name:"Sun & clouds"
},
{
name:"orangeGlazedTerracotta",
rotate:true,
Name:"Flower Monster"
},
{
name:"purpleGlazedTerracotta",
rotate:true,
Name:"Sword & pickaxe monster"
},
{
name:"yellowGlazedTerracotta",
rotate:true,
Name:"Some kind of bug"
},
{
name:"magentaGlazedTerracotta",
rotate:true,
Name:"Arrow"
},
{
name:"lightBlueGlazedTerracotta",
rotate:true,
Name:"Monster sticking out tongue and eyes facing opposite direction"
},
{
name:"lightGrayGlazedTerracotta",
rotate:true,
Name:"Monster with blue eyes and mouth"
},
{
name:"ancientDebris",
Name:"Ancient Debris",breakTime:50, type:"rock4",
textures:["ancientDebrisTop","ancientDebrisSide"]
},
{
name:"wheatSeeds",
Name:"Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland") return "wheat"
}
},
{
name:"yellowStainedGlass",Name: "Yellow Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"whiteStainedGlass",Name: "White Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"redStainedGlass",Name: "Red Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"purpleStainedGlass",Name: "Purple Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"pinkStainedGlass",Name: "Pink Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"orangeStainedGlass",Name: "Orange Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"magentaStainedGlass",Name: "Magenta Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"limeStainedGlass",Name: "Lime Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"lightGrayStainedGlass",Name: "Light Gray Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"lightBlueStainedGlass",Name: "Light Blue Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"greenStainedGlass",Name: "Green Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"grayStainedGlass",Name: "Gray Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"cyanStainedGlass",Name: "Cyan Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"brownStainedGlass",Name: "Brown Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"blueStainedGlass",Name: "Blue Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name:"blackStainedGlass",Name: "Black Stained Glass",
transparent: true,
shadow: false,
breakTime: 0.3,
type:"glass",
glassSound: true
},
{
name: "yellowStainedGlassPane",Name: "Yellow Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["yellowStainedGlassPaneTop","yellowStainedGlassPaneTop","yellowStainedGlass","yellowStainedGlass","yellowStainedGlassPaneSide","yellowStainedGlassPaneSide"],
glassSound: true
},
{
name: "whiteStainedGlassPane",Name: "White Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["whiteStainedGlassPaneTop","whiteStainedGlassPaneTop","whiteStainedGlass","whiteStainedGlass","whiteStainedGlassPaneSide","whiteStainedGlassPaneSide"],
glassSound: true
},
{
name: "redStainedGlassPane",Name: "Red Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["redStainedGlassPaneTop","redStainedGlassPaneTop","redStainedGlass","redStainedGlass","redStainedGlassPaneSide","redStainedGlassPaneSide"],
glassSound: true
},
{
name: "purpleStainedGlassPane",Name: "Purple Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["purpleStainedGlassPaneTop","purpleStainedGlassPaneTop","purpleStainedGlass","purpleStainedGlass","purpleStainedGlassPaneSide","purpleStainedGlassPaneSide"],
glassSound: true
},
{
name: "pinkStainedGlassPane",Name: "Pink Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["pinkStainedGlassPaneTop","pinkStainedGlassPaneTop","pinkStainedGlass","pinkStainedGlass","pinkStainedGlassPaneSide","pinkStainedGlassPaneSide"],
glassSound: true
},
{
name: "orangeStainedGlassPane",Name: "Orange Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["orangeStainedGlassPaneTop","orangeStainedGlassPaneTop","orangeStainedGlass","orangeStainedGlass","orangeStainedGlassPaneSide","orangeStainedGlassPaneSide"],
glassSound: true
},
{
name: "magentaStainedGlassPane",Name: "Magenta Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["magentaStainedGlassPaneTop","magentaStainedGlassPaneTop","magentaStainedGlass","magentaStainedGlass","magentaStainedGlassPaneSide","magentaStainedGlassPaneSide"],
glassSound: true
},
{
name: "limeStainedGlassPane",Name: "Lime Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["limeStainedGlassPaneTop","limeStainedGlassPaneTop","limeStainedGlass","limeStainedGlass","limeStainedGlassPaneSide","limeStainedGlassPaneSide"],
glassSound: true
},
{
name: "lightGrayStainedGlassPane",Name: "Light Gray Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["lightGrayStainedGlassPaneTop","lightGrayStainedGlassPaneTop","lightGrayStainedGlass","lightGrayStainedGlass","lightGrayStainedGlassPaneSide","lightGrayStainedGlassPaneSide"],
glassSound: true
},
{
name: "lightBlueStainedGlassPane",Name: "Light Blue Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["lightBlueStainedGlassPaneTop","lightBlueStainedGlassPaneTop","lightBlueStainedGlass","lightBlueStainedGlass","lightBlueStainedGlassPaneSide","lightBlueStainedGlassPaneSide"],
glassSound: true
},
{
name: "greenStainedGlassPane",Name: "Green Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["greenStainedGlassPaneTop","greenStainedGlassPaneTop","greenStainedGlass","greenStainedGlass","greenStainedGlassPaneSide","greenStainedGlassPaneSide"],
glassSound: true
},
{
name: "grayStainedGlassPane",Name: "Gray Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["grayStainedGlassPaneTop","grayStainedGlassPaneTop","grayStainedGlass","grayStainedGlass","grayStainedGlassPaneSide","grayStainedGlassPaneSide"],
glassSound: true
},
{
name: "cyanStainedGlassPane",Name: "Cyan Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["cyanStainedGlassPaneTop","cyanStainedGlassPaneTop","cyanStainedGlass","cyanStainedGlass","cyanStainedGlassPaneSide","cyanStainedGlassPaneSide"],
glassSound: true
},
{
name: "brownStainedGlassPane",Name: "Brown Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["brownStainedGlassPaneTop","brownStainedGlassPaneTop","brownStainedGlass","brownStainedGlass","brownStainedGlassPaneSide","brownStainedGlassPaneSide"],
glassSound: true
},
{
name: "blueStainedGlassPane",Name: "Blue Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["blueStainedGlassPaneTop","blueStainedGlassPaneTop","blueStainedGlass","blueStainedGlass","blueStainedGlassPaneSide","blueStainedGlassPaneSide"],
glassSound: true
},
{
name: "blackStainedGlassPane",Name: "Black Stained Glass Pane",
transparent: true,
shadow: false,
breakTime: 0.3,
pane:true,
textures: ["blackStainedGlassPaneTop","blackStainedGlassPaneTop","blackStainedGlass","blackStainedGlass","blackStainedGlassPaneSide","blackStainedGlassPaneSide"],
glassSound: true
},
{
name: "cobweb",
Name:"Cobweb",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
breakTime:20,
noDrop:true,
dropSelfWhenSheared:true,
shearBreakTime:0.4
},
{
name: "strippedCrimsonStem",Name: "Stripped Crimson Stem",
textures: ["strippedCrimsonStemTop", "strippedCrimsonStem"],
breakTime:2,
stemSound:true
},
{
name: "strippedCrimsonStemSW",Name: "Stripped Crimson Stem (SW)",
textures: ["strippedCrimsonStem", "strippedCrimsonStem", "strippedCrimsonStemTop","strippedCrimsonStemSW"],
breakTime:2,
stemSound:true,
rotate:true
},
{
name: "strippedWarpedStem",Name: "Stripped Warped Stem",
textures: ["strippedWarpedStemTop", "strippedWarpedStem"],
breakTime:2,
stemSound:true
},
{
name: "strippedWarpedStemSW",Name: "Stripped Warped Stem (SW)",
textures: ["strippedWarpedStem", "strippedWarpedStem", "strippedWarpedStemTop","strippedWarpedStemSW"],
breakTime:2,
stemSound:true,
rotate:true
},
{
name: "oakPressurePlate",Name: "Oak Pressure Plate",
textures: "oakPlanks",
pressurePlate: true
},
{
name: "birchPressurePlate",Name: "Birch Pressure Plate",
textures: "birchPlanks",
pressurePlate: true
},
{
name: "sprucePressurePlate",Name: "Spruce Pressure Plate",
textures: "sprucePlanks",
pressurePlate: true
},
{
name: "junglePressurePlate",Name: "Jungle Pressure Plate",
textures: "junglePlanks",
pressurePlate: true
},
{
name: "acaciaPressurePlate",Name: "Acacia Pressure Plate",
textures: "acaciaPlanks",
pressurePlate: true
},
{
name:"darkOakPressurePlate",Name: "Dark Oak Pressure Plate",
textures: "darkOakPlanks",
pressurePlate: true
},
{
name: "warpedPressurePlate",Name: "Warped Pressure Plate",
textures: "warpedPlanks",
pressurePlate: true
},
{
name: "crimsonPressurePlate",Name: "Crimson Pressure Plate",
textures: "crimsonPlanks",
pressurePlate: true
},
{
name: "stonePressurePlate",Name: "Stone Pressure Plate",
textures: "stone",
pressurePlate: true,
breakTime: 3
},
{
name: "polishedBlackstonePressurePlate",Name: "Polished Blackstone Pressure Plate",
textures: "polishedBlackstone",
pressurePlate: true,
breakTime: 3
},
{
name: "lightWeightedPressurePlate",Name: "Light Weighted Pressure Plate",
textures: "goldBlock",
pressurePlate: true,
breakTime: 3
},
{
name: "heavyWeightedPressurePlate",Name: "Heavy Weighted Pressure Plate",
textures: "ironBlock",
pressurePlate: true,
breakTime: 3,
},
{
name:"oakButton",Name: "Oak Button",
textures:"oakPlanks",
button:true,
transparent: true
},
{
name:"birchButton",Name: "Birch Button",
textures:"birchPlanks",
button:true,
transparent: true
},
{
name:"acaciaButton",Name: "Acacia Button",
textures:"acaciaPlanks",
button:true,
transparent: true
},
{
name:"darkOakButton",Name: "Dark Oak Button",
textures:"darkOakPlanks",
button:true,
transparent: true
},
{
name:"jungleButton",Name: "Jungle Button",
textures:"junglePlanks",
button:true,
transparent: true
},
{
name:"spruceButton",Name: "Spruce Button",
textures:"sprucePlanks",
button:true,
transparent: true
},
{
name:"warpedButton",Name: "Warped Button",
textures:"warpedPlanks",
button:true,
transparent: true
},
{
name:"crimsonButton",Name: "Crimson Button",
textures:"crimsonPlanks",
button:true,
transparent: true
},
{
name:"polishedBlackstoneButton",Name: "Polished Blackstone Button",
textures:"polishedBlackstone",
button:true,
transparent:true,
breakTime: 3,
},
{
name:"crackedPolishedBlackstoneBricks",
Name:"Cracked Polished Blackstone Bricks"
},
{
name:"crackedStoneBricks",
Name:"Cracked Stone Bricks"
},
{
name:"podzol",
Name:"Podzol",
textures:["dirt","podzolTop","podzolSide"]
},
{
name:"rawIronBlock",
Name:"Block of Raw Iron",
type:"rock2",
breakTime:25
},
{
name:"rawGoldBlock",
Name:"Block of Raw Gold",
type:"rock3",
breakTime:25
},
{
name:"rawCopperBlock",
Name:"Block of Raw Copper",
type:"rock2",
breakTime:25
},
{
name:"netheriteScrap",
Name:"Netherite Scrap",
item:true
},
{
name:"netheriteIngot",
Name:"Netherite Ingot",
item:true
},
{
name:"cartographyTable",
Name:"Cartograpgy Table",
textures: ["cartographyTableSide3","cartographyTableTop","cartographyTableSide3","cartographyTableSide1","cartographyTableSide2","cartographyTableSide3"],
rotate:true
},
{
name:"cake",
Name:"Cake",
textures:["cakeBottom","cakeTop","cakeSide"],
cake:true,
transparent:true,
flatIcon:true,
iconTexture:"cake"
},
{
name:"smithingTable",
Name:"Smithing Table",
textures:["smithingTableBottom","smithingTableTop","smithingTableFront","smithingTableSide"],breakTime:3, type:"wood"
},
{
name:"stonecutter",
Name:"Stonecutter",
textures:["stonecutterBottom","stonecutterTop","stonecutterSide"],breakTime:8, type:"rock1",
transparent:true,
stonecutter:true
},
{
name:"itemFrame",
Name:"Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"itemFrameIcon"
},
{
name:"enderPearl",
Name:"Ender Pearl",
item:true,
onuse:function(){
world.addEntity(new EnderPearl(p.x,p.y,p.z, p.direction.x, p.direction.y, p.direction.z))
},
minusOnUse:true,
useAnywhere:true
},
{
name:"ironNugget",
Name:"Iron Nugget",
item:true
},
{
name:"goldNugget",
Name:"Gold Nugget",
item:true
},
{
name:"pumpkin",
Name:"Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide"]
},
{
name:"carvedPumpkin",
Name:"Carved Pumpkin",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","carvedPumpkin","pumpkinSide","pumpkinSide"],
rotate:true
},
{
name:"jackOLantern",
Name:"Jack o'Lantern",
textures:["pumpkinSide","pumpkinTop","pumpkinSide","jackOLantern","pumpkinSide","pumpkinSide"],
lightLevel:15,
rotate:true
},
{
name:"shears",
Name:"Shears",
item:true,
shears:true
},
{
name:"pumpkinSeeds",
Name:"Pumpkin Seeds",
item:true
},
{
name:"melonSeeds",
Name:"Watermelon Seeds",
item:true
},
{
name:"melon",
Name:"Watermelon",
textures:["melonSide","melonTop","melonSide"],
breakTime:1.5,
drop:"melonSlice",
dropAmount:[3,7]
},
{
name:"melonSlice",
Name:"Slice of Watermelon",
item:true,
edible: true,
food: 2,
saturation: 1.2
},
{
name:"redstoneLamp",
Name:"Redstone Lamp",
},
{
name:"glowstoneDust",Name:"Glowstone Dust",
item:true
},
{
name:"quartz",
Name:"Quartz",
item:true
},
{
name: "endPortalFrame", 
Name:"End Portal Frame",
textures: ["endStone", "endPortalFrameTop", "endPortalFrameSide"]
},
{
name: "eyeOfEnder",
Name:"Eye of Ender",
item:true,
iconTexture:"enderEye",
shadow: false,
canPlace:function(block){
return blockData[block].name === "endPortalFrame"
},
placeSound:["block.end_portal.eyeplace1","block.end_portal.eyeplace2","block.end_portal.eyeplace3"],
eyeOfEnder: true
},
{
name:"endStone",
Name:"End Stone",breakTime:16, type:"rock1"
},
{
name:"redSand",
Name:"Red Sand",
breakTime:0.75,
onupdate: function(x,y,z,block){
fall(x,y,z,block)
},
digSound: ["block.sand.dig1", "block.sand.dig2", "block.sand.dig3", "block.sand.dig4"],
stepSound: ["block.sand.step1", "block.sand.step2","block.sand.step3","block.sand.step4","block.sand.step5"]
},
{
name:"redSandstone",
Name:"Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop", "redSandstone"],breakTime:10, type:"rock1"
},
{ name:"chiseledRedSandstone",
Name:"Chiseled Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","chiseledRedSandstone"],breakTime:10, type:"rock1"
},
{ name:"cutRedSandstone",
Name:"Cut Red Sandstone",
textures: ["redSandstoneBottom", "redSandstoneTop","cutRedSandstone"],breakTime:10, type:"rock1"
},
{ name:"smoothredSandstone", Name:"Smooth Red Sandstone", textures:"redSandstoneTop" ,breakTime:10, type:"rock1"},
{
name:"purpurBlock",
Name:"Purpur Block",breakTime:10, type:"rock1"
},
{
name:"purpurPillar",
Name:"Purpur Pillar",
textures:["purpurPillarTop","purpurPillar"],breakTime:10, type:"rock1"
},
{
name:"purpurPillarSW",Name:"Purpur Pillar (SW)",
textures:["purpurPillar","purpurPillar","purpurPillarTop","purpurPillarSW"],breakTime:10, type:"rock1",
rotate:true
},
{
name:"prismarine",
Name:"Prismarine",breakTime:10, type:"rock1"
},
{
name:"prismarineBricks",
Name:"Prismarine Bricks",breakTime:10, type:"rock1"
},
{
name:"darkPrismarine",
Name:"Dark Prismarine",breakTime:10, type:"rock1"
},
{
name:"prismarineCrystals",
Name:"Prismarine Crystals",
item:true
},
{
name:"prismarineShard",
Name:"Prismarine Shard",
item:true
},
{
name:"seaLantern",
Name:"Sea Lantern",
lightLevel:15,
breakTime:0.45
},
{
name:"oakLeaves",
Name: "Oak Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(5))
if(r === 0) return "stick"
else if(r === 1) return "oakSapling"
else if(r === 2) return "string"
else{
return rand() > 0.8 ? "orange" : "apple"
}
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "acaciaLeaves",
Name:"Acacia Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "acaciaSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "birchLeaves",
Name:"Birch Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "birchSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "darkOakLeaves",
Name:"Dark Oak Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "darkOakSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "jungleLeaves",
Name:"Jungle Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "jungleSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name: "spruceLeaves",
Name:"Spruce Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "spruceSapling"
else return "apple"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name:"spyglass",
Name:"Spyglass",
item:true,
spyglass:true
},
{
name:"egg",
Name:"Egg",
item:true
},
{
name:"noodles",
Name:"Noodles",
item:true
},
{
name:"bowl",
Name:"Bowl",
item:true
},
{
name:"mushroomStew",
Name:"Mushroom Stew",
edible: true,
item:true,
eatWhenFull: false,
food: 6,
saturation: 7.2,
eatResult:"bowl"
},
{
name:"ramen",
Name:"Ramen! Yum!",
edible: true,
item:true,
eatWhenFull: true,
food: 8,
saturation: 10,
eatResult:"bowl"
},
{
name:"orange",
Name:"Orange",
edible: true,
item:true,
eatWhenFull: false,
food: 4,
saturation: 2.4
},
{
name:"fern",
Name:"Fern",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
},
{
name: "largeFarn",
Name:"Large Fern",
solid: false,
transparent: true,
shadow: false,
textures: "largeFernTop",
tallcrossShape: true,
},
{
name:"fire",Name:"Fire",
fire:true,
damage:1,
burnPlayer:true,
transparent:true,
shadow:false,
solid:false,
lightLevel:15,
ambientSound:"block.fire.fire"
},
{
name: "endRod",
Name:"End Rod",
transparent: true,
shadow: false,
lightLevel: 15
},
{
name: "oakWood",
Name:"Oak Wood",
textures: "logSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "acaciaWood",
Name:"Acacia Wood",
textures: "acaciaLogSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "birchWood",
Name:"Birch Wood",
textures: "birchLogSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "darkOakWood",
Name:"Dark Oak Wood",
textures: "darkOakLogSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "jungleWood",
Name:"Jungle Wood",
textures: "jungleLogSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "spruceWood",
Name:"Spruce Wood",
textures: "spruceLogSide",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "crimsonHyphae",
textures: "crimsonStemSide",
stemSound: true
},
{
name: "warpedHyphae",
textures: "warpedStemSide",
stemSound: true
},
{
name: "strippedOakWood",
Name:"Stripped Oak Wood",
textures: "strippedOakLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedAcaciaWood",
Name:"Stripped Acacia Wood",
textures: "strippedAcaciaLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedBirchWood",
Name:"Stripped Birch Wood",
textures: "strippedBirchLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedDarkOakWood",
Name:"Stripped Dark Oak Wood",
textures: "strippedDarkOakLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedJungleWood",
Name:"Stripped Jungle Wood",
textures: "strippedJungleLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedSpruceWood",
Name:"Stripped Spruce Wood",
textures: "strippedSpruceLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name: "strippedCrimsonHyphae",
textures: "strippedCrimsonStem",
stemSound: true,
breakTime:3,
type:"wood",
},
{
name: "strippedWarpedHyphae",
textures: "strippedWarpedStem",
stemSound: true,
breakTime:3,
type:"wood",
},
{
name:"oakFenceGate",
Name:"Oak Fence Gate",
textures:"oakPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"acaciaFenceGate",
Name:"Acacia Fence Gate",
textures:"acaciaPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"birchFenceGate",
Name:"Birch Fence Gate",
textures:"birchPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"darkOakFenceGate",
Name:"Dark Oak Fence Gate",
textures:"darkOakPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"jungleFenceGate",
Name:"Jungle Fence Gate",
textures:"junglePlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"spruceFenceGate",
Name:"Spruce Fence Gate",
textures:"sprucePlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"crimsonFenceGate",
Name:"Crimson Fence Gate",
textures:"crimsonPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"warpedFenceGate",
Name:"Warped Fence Gate",
textures:"warpedPlanks",
fenceGate:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{ 
name: "kelp",Name:"Kelp Top",
transparent: true,
solid: false,
shadow: false,
crossShape: true
},
{ 
name: "kelpPlant",Name: "Kelp",
transparent: true,
solid: false,
shadow: false,
crossShape: true
},
{
name:"seagrass",
Name:"Seagrass",
iconTexture:"seagrassIcon",
transparent: true,
solid: false,
shadow: false,
crop:true
},
{
name:"tallSeagrass",Name: "Seagrass Top",
textures:"tallSeagrassTop",
transparent: true,
solid: false,
shadow: false,
tallCrop:true
},
{
name:"barrel",
Name:"Barrel",
textures:["barrelBottom","barrelTop","barrelSide"],
texturesOpen:fillTextureArray(["barrelBottom","barrelTopOpen","barrelSide"]),
texturesSW:fillTextureArray(["barrelSide","barrelSide","barrelTop","barrelSW"]),
texturesSWOpen:fillTextureArray(["barrelSide","barrelSide","barrelTopOpen","barrelSW"]),
texturesDown:fillTextureArray(["barrelTop","barrelBottom","barrelSide"]),
texturesDownOpen:fillTextureArray(["barrelTopOpen","barrelBottom","barrelSide"]),
onclick: () => Messages.write("this barrel doesn't work"),
woodSound:true,
barrel:true
},
{
name:"endStoneBricks",
Name:"End Stone Bricks",
stoneSound:true,breakTime:10, type:"rock1"
},
{
name:"beeNest",
Name:"Bee Nest",
textures:["beeNestBottom","beeNestTop","beeNestSide","beeNestFront","beeNestSide","beeNestSide"],
texturesHoney:["beeNestBottom","beeNestTop","beeNestSide","beeNestFrontHoney","beeNestSide","beeNestSide"],
rotate:true
},
{
name:"beehive",
Name:"Beehive",
textures:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFront","beehiveSide","beehiveSide"],
texturesHoney:["beehiveEnd","beehiveEnd","beehiveSide","beehiveFrontHoney","beehiveSide","beehiveSide"],
rotate:true
},
{
name:"honeyBlock",
Name:"Block of Honey",
textures:["honeyBlockBottom","honeyBlockTop","honeyBlockSide"],
transparent:true
},
{
name:"honeycomb",
Name:"Honeycomb",
item:true
},
{
name:"honeycombBlock",
Name:"Honeycomb Block"
},
{
name:"coarseDirt",
Name:"Coarse Dirt",breakTime:1.5
},
{
name:"inkSac",
Name:"Ink Sac",
item:true
},
{
name:"glowInkSac",
Name:"Glow Ink Sac",
item:true
},
{
name:"glowItemFrame",
Name:"Glow Item Frame",
transparent:true,
itemFrame:true,
flatIcon:true,
iconTexture:"glowItemFrameIcon"
},
{
name:"glowLichen",
transparent: true,
shadow: false,
wallFlat: true,
flatIcon:true,
lightLevel:7
},
{
name:"sponge",
Name:"Sponge",
wetTexture:new Array(6).fill("wetSponge"),
},
{
name:"cutCopper",
Name:"Cut Copper",breakTime:10, type:"rock1"
},
{
name:"exposedCopper",
Name:"Exposed Block of Copper",breakTime:10, type:"rock1"
},
{
name:"exposedCutCopper",
Name:"Exposed Cut Copper",breakTime:10, type:"rock1"
},
{
name:"weatheredCopper",
Name:"Weathered Block of Copper",breakTime:10, type:"rock1"
},
{
name:"weatheredCutCopper",
Name:"Weathered Cut Copper",breakTime:10, type:"rock1"
},
{
name:"oxidizedCopper",
Name:"Oxidized Block of Copper",breakTime:10, type:"rock1"
},
{
name:"oxidizedCutCopper",
Name:"Oxidized Cut Copper",breakTime:10, type:"rock1"
},
{
name:"quartzBricks",
Name:"Quartz Bricks",breakTime:10, type:"rock1",
stoneSound:true
},
{
name:"campfire",
Name:"Campfire",
flatIcon:true,
iconTexture:"campfire",
textures: "campfireLogLit",
campfire:true,
shadow:false,
lightLevel:15,
transparent:true,
woodSound:true,
drop:"campfire"
},
{
name:"soulCampfire",
Name:"Soul Campfire",
flatIcon:true,
iconTexture:"soulCampfire",
textures: "soulCampfireLogLit",
campfire:true,
shadow:false,
lightLevel:10,
transparent:true,
woodSound:true,
drop:"soulCampfire"
},
{
name:"bambooShoot",Name:"Bamboo Shoot",
textures:"bambooStage0",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
},
{
name:"bambooStalk",
Name:"Bamboo",
iconTexture:"bamboo",
flatIcon:true,
bamboo:true,
shadow: false,
potCross:true,
transparent:true,
drop:"bambooStalk",
breakTime:1.5,
onupdate:function(x,y,z,b){
needsSupportingBlocks(x,y,z,b)
}
},
{
name:"chest",
Name:"Chest",
textures:/*"christmasChestSide",//*/"chestFront",//christmas
transparent:true,
chest:true,
onclick:function(x,y,z){
chestData.x = x
chestData.y = y
chestData.z = z
changeScene("chest")
releasePointer()
},
onbreak:function(x,y,z, block, data){
if(!(data && data.chest && data.contents)) return
data = data.contents
for(var i=0; i<data.length; i++){
if(data[i] && data[i].id){
for(var j=0; j<data[i].amount; j++)world.addEntity(new Item(x,y,z,0,0,0,data[i].id, true, 1, data[i].durability))
}
}
}
},
{
name:"boneMeal",
Name:"Bone Meal (not for dogs)",
item:true,
onuse:function(x,y,z, block, replaceItem, useDurability, minusOne){
if(block === (blockIds.oakSapling | CROSS)){
blockData[blockIds.oakSapling].grow(x,y,z)
minusOne()
}else if(block === (blockIds.birchSapling | CROSS)){
blockData[blockIds.birchSapling].grow(x,y,z)
minusOne()
}else if(blockData[block].name === "wheat"){
world.setBlock(x,y,z, blockIds.wheat|LANTERN)
}else if(blockData[block].name === "tomatoPlant"){
world.setBlock(x,y,z, blockIds.tomatoPlant|TALLCROSS)
}
},
minusOnUse:true
},
{
name:"clay",
Name:"Clay",
breakTime:0.9,
type:"ground",
digSound: ["block.gravel.dig1", "block.gravel.dig2", "block.gravel.dig3", "block.gravel.dig4"],
stepSound: ["block.gravel.step1", "block.gravel.step2","block.gravel.step3","block.gravel.step4"],
drop:"clayBall",
dropAmount:4
},
{
name:"clayBall",
Name:"Clay Ball",
item:true
},
{
name:"brick",
Name:"Brick",
item:true
},
{
name:"charcoal",
Name:"Charcoal",
item:true
},
{
name:"appleCore",
Name:"Apple Core",
item:true
},
{
name:"tintedGlass",
Name:"Tinted Glass",
transparent: true,
shadow: true,
breakTime: 0.45,
type: "glass",
glassSound: true
},
{
name:"tomato",
Name:"Tomato",
item:true,
edible:true,
eatWhenFull: false,
food: 3,
saturation: 2,
eatResult:"tomatoSeeds"
},
{
name:"tomatoPlant",
Name:"Tomato Plant",
textures:new Array(6).fill("tomatoPlantStage0"),
textures1:new Array(6).fill("tomatoPlantStage1"),
textures2:new Array(6).fill("tomatoPlantStage2"),
textures3:new Array(6).fill("tomatoPlantStage3"),
textures4:new Array(6).fill("tomatoPlantStage4"),
iconTexture:"tomatoPlantStage3",
flatIcon:true,
shadow:false,
transparent:true,
solid:false,
onupdate:function(x,y,z,b){
needsSupportingBlocks(x,y,z,b)
}
},
{
name:"tomatoSeeds",
Name:"Tomato Seeds",
item:true,
useAs:function(x,y,z,block,face){
if(!block) return
if(face === "top" && blockData[block].name === "farmland"){
return "tomatoPlant"
}else{
Messages.write("tomato seeds need to be planted on farmland")
p.lastPlace = Date.now()
}
}
},
{
name:"newCactusFruit",
Name:"New Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true
},
{
name:"greenCactusFruit",
Name:"Green Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
cactusFruit:true
},
{
name:"redCactusFruit",
Name:"Red Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 2,
saturation: 1,
cactusFruit:true
},
{
name:"purpleCactusFruit",
Name:"Purple Cactus Fruit",
solid: false,
transparent: true,
shadow: false,
crossShape: true,
edible: true,
eatWhenFull: false,
food: 3,
saturation: 2,
cactusFruit:true
},
{
name:"cherry",
Name:"Cherry",
item:true,
edible:true,
eatWhenFull: false,
food: 1,
saturation: 1,
},
{
name:"cherryLog",
Name:"Cherry Log",
textures:["cherryLogTop","cherryLog"],
woodSound:true,
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"cherryLogSW",
name: "Cherry Log (SW)",
textures: ["cherryLog","cherryLog","cherryLogTop","cherryLogSW"],
rotate: true,
woodSound:true
},
{
name:"cherryLeaves",
Name:"Cherry Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name:"pinkCherryLeaves",
Name:"Pink Cherry Leaves",
transparent: true,
breakTime: 0.3,
type:"plant2",
drop: function(){
if(rand() > 0.8){
let r = floor(rand(3))
if(r === 0) return "stick"
else if(r === 1) return "cherrySapling"
else if(rand() > 0.5) return "cherry"
}
},
dropSelfWhenSheared:true,
shearBreakTime:0.05,
digSound: ["block.grass.dig1", "block.grass.dig2", "block.grass.dig3", "block.grass.dig4"],
stepSound: ["block.grass.step1", "block.grass.step2","block.grass.step3","block.grass.step4","block.grass.step5","block.grass.step6"]
},
{
name:"cherrySapling",
Name:"Cherry Sapling",
transparent: true,
shadow: false,
solid: false,
crossShape: true,
potCross: true
},
{
name:"cherryWood",
Name:"Cherry Wood",
textures: "cherryLog",
breakTime:3,
woodSound:true,
type:"wood",
},
{
name:"gun",
Name:"gun: something dangerous you should never use",
flatIcon:true,
onuse: function(x,y,z){
dieMessage = username+" died because he used a gun backwards. guns are dangerous and stuff"
die()
},
useAnywhere:true
},
{
name:"string",
Name:"String",
item:true
},
{
name:"redDye",
Name:"Red Dye",
item:true
},
/*
{ name: "pigFace" },
{ 
name: "steveFace",
textures: ["steveHeadTop", "steveFace"]
},
{ name: "sarahFace",
textures: ["sarahTop", "sarahFace"]
},
{
name: "lexiFace",
textures: ["lexiTop","lexiFace"]
},
{
name: "sallyFace",
textures: ["sallyTop","sallyFace"]
},
{
name: "face",
textures: ["faceTop","face"]
},//*/
];
window.BLOCK_COUNT = blockData.length;
window.console.log(BLOCK_COUNT,"blocks")
var texNum=0;for(var t in textures) texNum ++
window.console.log(texNum,"textures")
window.emptyFunc = function(){}
var stoneDigSound = ["block.stone.dig1", "block.stone.dig2", "block.stone.dig3", "block.stone.dig4"],
stoneStepSound = ["block.stone.step1", "block.stone.step2","block.stone.step3","block.stone.step4","block.stone.step5","block.stone.step6"],
woodDigSound = ["block.wood.dig1", "block.wood.dig2", "block.wood.dig3", "block.wood.dig4"],
woodStepSound = ["block.wood.step1", "block.wood.step2","block.wood.step3","block.wood.step4","block.wood.step5","block.wood.step6"],
clothDigSound = ["block.cloth.dig1", "block.cloth.dig2", "block.cloth.dig3", "block.cloth.dig4"],
clothStepSound = ["block.cloth.step1", "block.cloth.step2","block.cloth.step3","block.cloth.step4"],
glassDigSound = ["block.glass.dig1", "block.glass.dig2", "block.glass.dig3"],
nyliumDigSound = ["block.nylium.dig1", "block.nylium.dig2", "block.nylium.dig3", "block.nylium.dig4", "block.nylium.dig5", "block.nylium.dig6"],
nyliumStepSound = ["block.nylium.step1", "block.nylium.step2","block.nylium.step3","block.nylium.step4","block.nylium.step5","block.nylium.step6"],
stemDigSound = ["block.stem.dig1", "block.stem.dig2", "block.stem.dig3", "block.stem.dig4", "block.stem.dig5", "block.stem.dig6"],
stemStepSound = ["block.stem.step1", "block.stem.step2","block.stem.step3","block.stem.step4","block.stem.step5","block.stem.step6"],
basaltDigSound = ["block.basalt.dig1", "block.basalt.dig2", "block.basalt.dig3", "block.basalt.dig4", "block.basalt.dig5"],
basaltStepSound = ["block.basalt.step1", "block.basalt.step2","block.basalt.step3","block.basalt.step4","block.basalt.step5","block.basalt.step6"],
rootDigSound = ["block.roots.dig1", "block.roots.dig2", "block.roots.dig3", "block.roots.dig4", "block.roots.dig5", "block.roots.dig6"],
rootStepSound = ["block.roots.step1", "block.roots.step2","block.roots.step3","block.roots.step4","block.roots.step5","block.roots.step6"],
amethystPlaceSound = ["block.amethyst.place1","block.amethyst.place2","block.amethyst.place3","block.amethyst.place4"],
amethystDigSound = ["block.amethyst.dig1","block.amethyst.dig2","block.amethyst.dig3","block.amethyst.dig4"],
amethystStepSound = (function(){var arr=[]; for(var i=0; i<14; i++){arr.push("block.amethyst.step"+(i+1))};return arr})(),
amethystClusterPlaceSound = ["block.amethyst_cluster.place1", "block.amethyst_cluster.place2", "block.amethyst_cluster.place3", "block.amethyst_cluster.place4"],
amethystClusterDigSound = ["block.amethyst_cluster.dig1", "block.amethyst_cluster.dig2", "block.amethyst_cluster.dig3", "block.amethyst_cluster.dig4"],
deepslatePlaceSound = ["block.deepslate.place1","block.deepslate.place2","block.deepslate.place3","block.deepslate.place4","block.deepslate.place5","block.deepslate.place6"],
deepslateStepSound = ["block.deepslate.step1","block.deepslate.step2","block.deepslate.step3","block.deepslate.step4","block.deepslate.step5","block.deepslate.step6"],
deepslateDigSound = ["block.deepslate.dig1","block.deepslate.dig2","block.deepslate.dig3","block.deepslate.dig4"],
deepslateBricksPlaceSound = [1,2,3,4,5,6].map(v => "block.deepslate_bricks.place"+v),
deepslateBricksStepSound = [1,2,3,4,5].map(v => "block.deepslate_bricks.step"+v)
// Set defaults on blockData
for (let i = 1; i < BLOCK_COUNT; ++i) {
const data = blockData[i];
data.id = i;
if ( !("textures" in data) ) {
data.textures = new Array(6).fill(data.name);
} else if (typeof data.textures === "string") {
data.textures = new Array(6).fill(data.textures);
} else {
const { textures } = data;
if (textures.length === 3) {
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
} else if (textures.length === 2) {
// Top and bottom are the first texture, sides are the second.
textures[2] = textures[1];
textures[3] = textures[2];
textures[4] = textures[2];
textures[5] = textures[2];
textures[1] = textures[0];
}else if(textures.length === 4){
textures[4] = textures[5] = textures[3]
textures[3] = textures[2]
}
}
for(let t = 0; t<data.textures.length; t++){
if(!textures[data.textures[t]]){
window.console.log("Missing texture for "+data.textures[t])
data.textures[t] = "error"
}
}
data.transparent = data.transparent || false
data.shadow = data.shadow !== undefined ? data.shadow	: true
data.lightLevel = data.lightLevel || 0
data.onupdate = data.onupdate || emptyFunc
if(data.solid === undefined)data.solid = true
data.breakTime = data.breakTime ? data.breakTime*1000 : 0.05*1000 //time for breaking
if(data.dropAmount === undefined) data.dropAmount = 1
if(data.item || data.edible || data.crossShape || data.tallcrossShape || data.sideCross || data.ladder || data.torch || data.door || data.lantern || data.chain || data.sunflower || data.pane || data.fire || data.crop || data.tallCrop) data.flatIcon = true
if(data.door) data.iconTexture = data.name
if(data.liquid) data.noHitbox = true
if(!data.stackSize)data.stackSize = 64
if(data.pickaxe){
data.stackSize = 1
data.attackTime = 20/1.2
}
if(data.sword){
data.stackSize = 1
data.attackTime = 20/1.6
}
if(data.shovel){
data.stackSize = 1
data.attackTime = 20/1
}
if(data.axe || data.hoe){
data.stackSize = 1
}
data.tool = data.pickaxe || data.sword || data.shovel || data.axe || data.hoe
if(data.attackSpeed) data.attackTime = 20/data.attackSpeed
if(data.stoneSound){
data.digSound = stoneDigSound
data.stepSound = stoneStepSound
}
if(data.woodSound){
data.digSound = woodDigSound
data.stepSound = woodStepSound
}
if(data.clothSound){
data.digSound = clothDigSound
data.stepSound = clothStepSound
}
if(data.glassSound){
data.digSound = glassDigSound
data.placeSound = stoneDigSound
}
if(data.nyliumSound){
data.digSound = nyliumDigSound
data.stepSound = nyliumStepSound
}
if(data.stemSound){
data.digSound = stemDigSound
data.stepSound = stemStepSound
}
if(data.basaltSound){
data.digSound = basaltDigSound
data.stepSound = basaltStepSound
}
if(data.rootSound){
data.digSound = rootDigSound
data.stepSound = rootStepSound
}
if(data.amethystSound){
data.placeSound = amethystPlaceSound
data.digSound = amethystDigSound
data.stepSound = amethystStepSound
}
if(data.amethystClusterSound){
data.placeSound = amethystClusterPlaceSound
data.digSound = amethystClusterDigSound
}
if(data.deepslateSound){
data.placeSound = deepslatePlaceSound
data.digSound = deepslateDigSound
data.stepSound = deepslateStepSound
}
if(data.deepslateBricksSound){
data.placeSound = deepslateBricksPlaceSound
data.stepSound = deepslateBricksStepSound
}
data.Name = data.Name || data.name
}
// survival inventory
let invItems = [];
let invLength = 13*9;
for(let i=0; i<invLength; i++){
invItems.push({id:0,amount:64})
}
function clearInv(){
for(let i=0; i<invLength; i++){
if(typeof invItems[i] === "object"){
invItems[i].id = 0
}else{
invItems[i] = {id:0,amount:64}
}
}
}
//add something to inventory
function newInvItem(id, durability){
//look for empty slot
for(let i=0; i<inventory.hotbar.length; i++){
if(!inventory.hotbar[i].id){
inventory.hotbar[i] = {id:id, amount:1, durability:durability, animation:1.5}
if(i === inventory.hotbarSlot){
inventory.showName = 1.5
holding = inventory.hotbar[inventory.hotbarSlot].id
}
return true
}
if(inventory.hotbar[i].id === id && inventory.hotbar[i].amount < blockData[inventory.hotbar[i].id].stackSize){
inventory.hotbar[i].amount ++;
inventory.hotbar[i].animation = 1.5
return true
}
}
for(let i=0; i<invLength; i++){
if(!(invItems[i] && invItems[i].id)){
invItems[i] = {id:id, durability:durability, amount:1}
return true
}
if(invItems[i].id === id && invItems[i].amount < blockData[invItems[i].id].stackSize){
invItems[i].amount ++;
return true
}
}
return false
}
const crafts = {
"oakLog": {name:"oakPlanks", amount:4, shapeless: true},
"acaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"birchLog": {name:"birchPlanks", amount:4, shapeless: true},
"darkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"jungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"spruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"oakPlanks,air,air,oakPlanks": {name:"stick", amount:4, shaped:true},
"acaciaPlanks,air,air,acaciaPlanks": {name:"stick", amount:4, shaped:true},
"birchPlanks,air,air,birchPlanks": {name:"stick", amount:4, shaped:true},
"darkOakPlanks,air,air,darkOakPlanks": {name:"stick", amount:4, shaped:true},
"junglePlanks,air,air,junglePlanks": {name:"stick", amount:4, shaped:true},
"sprucePlanks,air,air,sprucePlanks": {name:"stick", amount:4, shaped:true},
"poppy": {name:"redDye", amount:1, shapeless: true},
"string,string,air,string,string": {name:"whiteWool", amount:1},
"whiteWool,redDye": {name:"redWool", amount:1},
"oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"oakDoor", amount:3},
"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"acaciaDoor", amount:3},
"birchPlanks,birchPlanks,air,birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"birchDoor", amount:3},
"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"darkOakDoor", amount:3},
"junglePlanks,junglePlanks,air,junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"jungleDoor", amount:3},
"sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"spruceDoor", amount:3},
"warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"warpedDoor", amount:3},
"crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks,air":{name:"crimsonDoor",amount:3},
"ironIngot,ironIngot,air,ironIngot,ironIngot,air,ironIngot,ironIngot,air":{name:"ironDoor",amount:3},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"oakTrapdoor", amount:2},
"birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks,birchPlanks":{name:"birchTrapdoor", amount:2},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks,darkOakPlanks":{name:"darkOakTrapdoor", amount:2},
"junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks,junglePlanks":{name:"jungleTrapdoor", amount:2},
"sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks,sprucePlanks":{name:"spruceTrapdoor", amount:2},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks,acaciaPlanks":{name:"acaciaTrapdoor", amount:2},
"warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks,warpedPlanks":{name:"warpedTrapdoor", amount:2},
"crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks,crimsonPlanks":{name:"crimsonTrapdoor", amount:2},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironTrapdoor", amount:2},
"whiteWool,whiteWool,whiteWool,oakPlanks,oakPlanks,oakPlanks":{name:"redBed", amount:1},
"redWool,redWool,redWool,oakPlanks,oakPlanks,oakPlanks":{name:"redBed", amount:1},
"oakPlanks,oakPlanks,air,oakPlanks,oakPlanks":{name:"craftingTable"},
"birchPlanks,birchPlanks,air,birchPlanks,birchPlanks":{name:"craftingTable"},
"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,darkOakPlanks":{name:"craftingTable"},
"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,acaciaPlanks":{name:"craftingTable"},
"sprucePlanks,sprucePlanks,air,sprucePlanks,sprucePlanks":{name:"craftingTable"},
"junglePlanks,junglePlanks,air,junglePlanks,junglePlanks":{name:"craftingTable"},
"warpedPlanks,warpedPlanks,air,warpedPlanks,warpedPlanks":{name:"craftingTable"},
"crimsonPlanks,crimsonPlanks,air,crimsonPlanks,crimsonPlanks":{name:"craftingTable"},
"coal,air,air,stick":{name:"torch",amount:4},
"coal,coal,coal,coal,coal,coal,coal,coal,coal":{name:"coalBlock"},
"ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot,ironIngot":{name:"ironBlock"},
"goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot,goldIngot":{name:"goldBlock"},
"diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond,diamond":{name:"diamondBlock"},
"lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli,lapisLazuli":{name:"lapisBlock"},
"emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald,emerald":{name:"emeraldBlock"},
"oakPlanks,oakPlanks,oakPlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"birchPlanks,birchPlanks,birchPlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"sprucePlanks,sprucePlanks,sprucePlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"junglePlanks,junglePlanks,junglePlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"darkOakPlanks,darkOakPlanks,darkOakPlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"acaciaPlanks,acaciaPlanks,acaciaPlanks,air,stick,air,air,stick":{name:"woodenPickaxe"},
"cobblestone,cobblestone,cobblestone,air,stick,air,air,stick":{name:"stonePickaxe"},
"ironIngot,ironIngot,ironIngot,air,stick,air,air,stick":{name:"ironPickaxe"},
"goldIngot,goldIngot,goldIngot,air,stick,air,air,stick":{name:"goldenPickaxe"},
"diamond,diamond,diamond,air,stick,air,air,stick":{name:"diamondPickaxe"},
"ironIngot,air,air,air,flint": {name:"flintAndSteel"},
"air,oakPlanks,air,air,oakPlanks,air,air,stick": {name:"woodenSword"},
"air,birchPlanks,air,air,birchPlanks,air,air,stick": {name:"woodenSword"},
"air,sprucePlanks,air,air,sprucePlanks,air,air,stick": {name:"woodenSword"},
"air,junglePlanks,air,air,junglePlanks,air,air,stick": {name:"woodenSword"},
"air,darkOakPlanks,air,air,darkOakPlanks,air,air,stick": {name:"woodenSword"},
"air,acaciaPlanks,air,air,acaciaPlanks,air,air,stick": {name:"woodenSword"},
"air,cobblestone,air,air,cobblestone,air,air,stick": {name:"stoneSword"},
"air,ironIngot,air,air,ironIngot,air,air,stick": {name:"ironSword"},
"air,goldIngot,air,air,goldIngot,air,air,stick": {name:"goldenSword"},
"air,diamond,air,air,diamond,air,air,stick": {name:"diamondSword"},
"air,air,air,snowBlock,snowBlock,snowBlock": {name:"snow", amount:6},
"snowball,snowball,air,snowball,snowball": {name:"snowBlock"},
"ironIngot,air,ironIngot,air,ironIngot":{name:"bucket"},
"cobblestone,cobblestone,cobblestone,cobblestone,air,cobblestone,cobblestone,cobblestone,cobblestone":{name:"furnace"},
"wheat,wheat,wheat":{name:"bread"},
"oakPlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"birchPlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"sprucePlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"junglePlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"darkOakPlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"acaciaPlanks,air,air,stick,air,air,stick":{name:"woodenShovel"},
"cobblestone,air,air,stick,air,air,stick":{name:"stoneShovel"},
"ironIngot,air,air,stick,air,air,stick":{name:"ironShovel"},
"goldIngot,air,air,stick,air,air,stick":{name:"goldenShovel"},
"diamond,air,air,stick,air,air,stick":{name:"diamondShovel"},
"birchPlanks,birchPlanks,air,birchPlanks,stick,air,air,stick":{name:"woodenAxe"},
"oakPlanks,oakPlanks,air,oakPlanks,stick,air,air,stick":{name:"woodenAxe"},
"sprucePlanks,sprucePlanks,air,sprucePlanks,stick,air,air,stick":{name:"woodenAxe"},
"junglePlanks,junglePlanks,air,junglePlanks,stick,air,air,stick":{name:"woodenAxe"},
"darkOakPlanks,darkOakPlanks,air,darkOakPlanks,stick,air,air,stick":{name:"woodenAxe"},
"acaciaPlanks,acaciaPlanks,air,acaciaPlanks,stick,air,air,stick":{name:"woodenAxe"},
"cobblestone,cobblestone,air,cobblestone,stick,air,air,stick":{name:"stoneAxe"},
"ironIngot,ironIngot,air,ironIngot,stick,air,air,stick":{name:"ironAxe"},
"goldIngot,goldIngot,air,goldIngot,stick,air,air,stick":{name:"goldenAxe"},
"diamond,diamond,air,diamond,stick,air,air,stick":{name:"diamondAxe"},
"birchPlanks,birchPlanks":{name:"birchPressurePlate",shapeless:true},
"oakPlanks,oakPlanks":{name:"oakPressurePlate",shapeless:true},
"junglePlanks,junglePlanks":{name:"junglePressurePlate",shapeless:true},
"sprucePlanks,sprucePlanks":{name:"sprucePressurePlate",shapeless:true},
"darkOakPlanks,darkOakPlanks":{name:"darkOakPressurePlate",shapeless:true},
"acaciaPlanks,acaciaPlanks":{name:"acaciaPressurePlate",shapeless:true},
"warpedPlanks,warpedPlanks":{name:"warpedPressurePlate",shapeless:true},
"crimsonPlanks,crimsonPlanks":{name:"crimsonPressurePlate",shapeless:true},
"stone,stone":{name:"stonePressurePlate",shapeless:true},
"polishedBlackstone,polishedBlackstone":{name:"polishedBlackstone",shapeless:true},
"goldIngot,goldIngot":{name:"lightWeightedPressurePlate",shapeless:true},
"ironIngot,ironIngot":{name:"heavyWeightedPressurePlate",shapeless:true},
"strippedOakLog": {name:"oakPlanks", amount:4, shapeless: true},
"strippedAcaciaLog": {name:"acaciaPlanks", amount:4, shapeless: true},
"strippedBirchLog": {name:"birchPlanks", amount:4, shapeless: true},
"strippedDarkOakLog": {name:"darkOakPlanks", amount:4, shapeless: true},
"strippedJungleLog": {name:"junglePlanks", amount:4, shapeless: true},
"strippedSpruceLog": {name:"sprucePlanks", amount:4, shapeless: true},
"warpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"crimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"strippedWarpedStem": {name:"warpedPlanks", amount:4, shapeless: true},
"strippedCrimsonStem":{name:"crimsonPlanks", amount:4, shapeless: true},
"warpedPlanks,air,air,warpedPlanks": {name:"stick", amount:4},
"crimsonPlanks,air,air,crimsonPlanks": {name:"stick", amount:4},
"stone":{name:"stoneButton", shapeless: true},
"oakPlanks":{name:"oakButton", shapeless: true},
"birchPlanks":{name:"birchButton", shapeless: true},
"darkOakPlanks":{name:"darkOakButton", shapeless: true},
"acaciaPlanks":{name:"acaciaButton", shapeless: true},
"sprucePlanks":{name:"spruceButton", shapeless: true},
"junglePlanks":{name:"jungleButton", shapeless: true},
"warpedPlanks":{name:"warpedButton", shapeless: true},
"crimsonPlanks":{name:"crimsonButton", shapeless: true},
"polishedBlackstone":{name:"polishedBlackstoneButton", shapeless:true},
"ironBlock": {name:"ironIngot",amount:9,shapeless:true},
"goldBlock": {name:"goldIngot",amount:9,shapeless:true},
"coalBlock": {name:"coal",amount:9,shapeless:true},
"emeraldBlock": {name:"emerald",amount:9,shapeless:true},
"diamondBlock": {name:"diamond",amount:9,shapeless:true},
"copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot,copperIngot":{name:"copperBlock"},
"copperBlock": {name:"copperIngot",amount:9,shapeless:true},
"oakPlanks,oakPlanks,air,air,stick,air,air,stick":{name:"woodenHoe"},
"cobblestone,cobblestone,air,air,stick,air,air,stick":{name:"stoneHoe"},
"ironIngot,ironIngot,air,air,stick,air,air,stick":{name:"ironHoe"},
"goldIngot,goldIngot,air,air,stick,air,air,stick":{name:"goldenHoe"},
"diamond,diamond,air,air,stick,air,air,stick":{name:"diamondHoe"},
"rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron,rawIron":{name:"rawIronBlock"},
"rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold,rawGold":{name:"rawGoldBlock"},
"rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper,rawCopper":{name:"rawCopperBlock"},
"rawIronBlock":{name:"rawIron",amount:9,shapeless:true},
"rawGoldBlock":{name:"rawGold",amount:9,shapeless:true},
"rawCopperBlock":{name:"rawCopper",amount:9,shapeless:true},
"netheriteScrap,netheriteScrap,netheriteScrap,netheriteScrap,goldIngot,goldIngot,goldIngot,goldIngot":{name:"netheriteIngot"},
"netheriteIngot,netheriteIngot,netheriteIngot,air,stick,air,air,stick":{name:"netheritePickaxe"},
"netheriteIngot,air,air,netheriteIngot,air,air,stick":{name:"netheriteSword"},
"netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteShovel"},
"netheriteIngot,netheriteIngot,air,netheriteIngot,stick,air,air,stick":{name:"netheriteAxe"},
"netheriteIngot,netheriteIngot,air,air,stick,air,air,stick":{name:"netheriteHoe"},
"netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot,netheriteIngot":{name:"netheriteBlock"},
"netheriteBlock":{name:"netheriteIngot",amount:9,shapeless:true},
"wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat,wheat":{name:"hayBlock"},
"hayBlock":{name:"wheat",amount:9,shapeless:true},
"ironIngot":{name:"ironNugget",amount:9,shapeless:true},
"goldIngot":{name:"goldNugget",amount:9,shapeless:true},
"ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget,ironNugget":{name:"ironIngot"},
"goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget,goldNugget":{name:"goldIngot"},
"ironNugget,ironNugget,ironNugget,ironNugget,torch,ironNugget,ironNugget,ironNugget,ironNugget":{name:"lantern"},
"stick,air,stick,stick,stick,stick,stick,air,stick":{name:"ladder",amount:3},
"ironNugget,air,air,ironIngot,air,air,ironNugget":{name:"chain"},
"stone,stone,air,stone,stone":{name:"stoneBricks",amount:4},
"stoneBricks,vine":{name:"mossyStoneBricks",shapeless:true},
"cobblestone,vine":{name:"mossyCobble",shapeless:true},
"chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,netheriteIngot,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks,chiseledStoneBricks":{name:"lodestone"},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,redstoneDust,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"noteBlock"},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,diamond,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"jukebox"},
"ironIngot,ironIngot,ironIngot,ironIngot,furnace,ironIngot,smoothStone,smoothStone,smoothStone":{name:"blastFurnace"},
"air,oakLog,air,oakLog,furnace,oakLog,air,oakLog":{name:"smoker"},
"carvedPumpkin,torch":{name:"jackOLantern",shapeless:true},
"air,ironIngot,air,ironIngot":{name:"shears"},
"melonSlice":{name:"melonSeeds",shapeless:true},
"melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice,melonSlice":{name:"melon"},
"redstoneDust,redstoneDust,redstoneDust,redstoneDust,redstoneDust,redstoneDust,redstoneDust,redstoneDust,redstoneDust":{name:"redstoneBlock"},
"air,redstoneDust,air,redstoneDust,glowstone,redstoneDust,air,redstoneDust":{name:"redstoneLamp"},
"glowstoneDust,glowstoneDust,air,glowstoneDust,glowstoneDust":{name:"glowstone"},
"cobblestone,quartz,air,quartz,cobblestone":{name:"diorite",amount:2,shaped:true},
"diorite,diorite,air,diorite,diorite":{name:"polishedDiorite",amount:4,shaped:true},
"cobblestone,diorite":{name:"andesite",amount:2,shapeless:true},
"andesite,andesite,air,andesite,andesite":{name:"polishedAndesite",amount:4,shaped:true},
"diorite,quartz":{name:"granite",shapeless:true},
"granite,granite,air,granite,granite":{name:"polishedGranite",amount:4,shaped:true},
"amethystShard,air,air,copperIngot,air,air,copperIngot":{name:"spyglass",shaped:true},
"oakPlanks,air,oakPlanks,air,oakPlanks":{name:"bowl",amount:4,shaped:true},
"redMushroom,brownMushroom,bowl":{name:"mushroomStew",shapeless:true},
"egg,noodles,wheatSeeds,bowl":{name:"ramen",shapeless:true},
"wheat,egg,wheat":{name:"noodles",shaped:true},
"endStone,endStone,air,endStone,endStone":{name:"endStoneBricks",amount:4,shaped:true},
"dirt,gravel,air,gravel,dirt":{name:"coarseDirt",amount:4,shaped:true},
"itemFrame,glowInkSac":{name:"glowItemFrame",shapeless:true},
"copperBlock,copperBlock,air,copperBlock,copperBlock":{name:"cutCopper",amount:4,shaped:true},
"air,stick,air,stick,coal,stick,oakLog,oakLog,oakLog":{name:"campfire"},
"air,stick,air,stick,soulSand,stick,oakLog,oakLog,oakLog":{name:"soulCampfire"},
"oakPlanks,oakPlanks,oakPlanks,oakPlanks,air,oakPlanks,oakPlanks,oakPlanks,oakPlanks":{name:"chest"},
"clayBall,clayBall,air,clayBall,clayBall":{name:"clay",shaped:true},
"brick,brick,air,brick,brick":{name:"bricks",shaped:true},
"brick,air,brick,air,brick":{name:"flowerPot",shaped:true},
"air,amethystShard,air,amethystShard,glass,amethystShard,air,amethystShard":{name:"tintedGlass",amount:2},
}
var breakTypes = {
plant: "axe",
wood: "axe",
metal1: "pickaxe",
metal2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
metal4: ["diamondPickaxe","netheritePickaxe"],
rock1: "pickaxe",
rock2: ["stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock3: ["ironPickaxe","diamondPickaxe","netheritePickaxe"],
rock4: ["diamondPickaxe","netheritePickaxe"],
ground: "shovel",
plant2: "hoe"
}
var handBreakable = [
"plant","wood","plant2","ground"
]
var allPickaxes = ["woodenPickaxe","stonePickaxe","ironPickaxe","diamondPickaxe","netheritePickaxe","goldenPickaxe"]
var allShovels = ["woodenShovel","stoneShovel","ironShovel","diamondShovel","netheriteShovel","goldenShovel"]
for(var b in breakTypes){
var t = breakTypes[b]
if(t === "pickaxe"){
breakTypes[b] = allPickaxes
}
if(t === "shovel"){
breakTypes[b] = allShovels
}
}
var smelts = {
rawIron: {name:"ironIngot", time:200, xp:0.7},
rawCopper: {name:"copperIngot", time:200, xp:0.7},
rawGold: {name:"goldIngot", time:200, xp:1},
ancientDebris: {name:"netheriteScrap", time:200, xp:1},
sand: {name:"glass",time:200,xp:0.1, furnace:true},//furnace propertie means it can only be smelted in furnace
cobblestone: {name:"stone",time:200,xp:0.1, furnace:true},
stone: {name:"smoothStone", time:200, xp:0.1, furnace:true},
stoneBricks: {name:"crackedStoneBricks",time:200,xp:0.1, furnace:true},
clay: {name:"terracotta",time:200,xp:0.35},
clayBall: {name:"brick",time:200,xp:0.3}
}
var smeltFuel = { //time is in seconds
oakLog: {time:15},
birchLog: {time:15},
spruceLog: {time:15},
jungleLog: {time:15},
darkOakLog: {time:15},
acaciaLog: {time:15},
coal: {time:80},
oakPlanks: {time:15},
birchPlanks: {time:15},
sprucePlanks: {time:15},
junglePlanks: {time:15},
darkOakPlanks: {time:15},
acaciaPlanks: {time:15},
stick: {time:5},
coalBlock: {time:690},
lavaBucket: {time:1000},
}
var achievementTypes = {
"Taking Inventory":{
score: 10,
description:"Open your inventory"
},
"Getting Wood":{
score:10,
description:"Punch a tree until a block of wood pops out."
},
"Benchmaking":{
score:10,
description:"Craft a Crafting Table with four blocks of wooden planks."
},
"Time to Mine!":{
score:10,
description:"Use planks and sticks to make a pickaxe."
},
"Getting an Upgrade":{
score:15,
description:"Construct a better pickaxe."
},
"Bake Bread":{
score:15,
description:"Turn wheat into bread."
},
"Time to Strike!":{
score:10,
description:"Use planks and sticks to make a sword."
},
"DIAMONDS!":{
score:20,
description:"Acquire diamonds with your iron tools."
},
"Diamonds to you!":{ //how is this possible to code???
score:15,
description:"Throw diamonds at another player."
},
"Time to Farm!":{
score:10,
description:"Make a Hoe."
},
"Time to plant tomatoes!":{
score:10,
description:"Get tomato seeds from Tall Grass."
},
"Hidden In The Depths":{
score:20,
description:"Get Ancient Debris"
}
}
for(var a in achievementTypes){
achievementTypes[a].name = a
}
var achievments = []
function achievment(name){
var a = achievementTypes[name]
if(!a) return console.log("No such achievment: "+name)
if(achievments.includes(name)) return
if(cheats) return
achievments.push(name)
sideMessage("Achievment made: "+a.name, a.description)
if(multiplayer) send({type:"achievment",data:a.name})
}
// implementation of xxHash
const {
seedHash,
hash
} = (() => {
// closure around mutable `seed`; updated via calls to `seedHash`
let seed = Math.random() * 2100000000 | 0;
const PRIME32_2 = 1883677709;
const PRIME32_3 = 2034071983;
const PRIME32_4 = 668265263;
const PRIME32_5 = 374761393;
const seedHash = s => {
seed = s | 0;
}
const { imul } = Math;
const hash = (x, y) => {
let h32 = 0;
h32 = seed + PRIME32_5 | 0;
h32 += 8;
h32 += imul(x, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 += imul(y, PRIME32_3);
h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
h32 ^= h32 >> 15;
h32 *= PRIME32_2;
h32 ^= h32 >> 13;
h32 *= PRIME32_3;
h32 ^= h32 >> 16;
return h32 / 2147483647;
};
return {
seedHash,
hash
};
})();
const win = window.parent;
const doc = document;
const { console } = win;
win.world = undefined;
let worldSeed;
win.dimensions = null
function setSeed(seed){
worldSeed = seed
seedHash(worldSeed)
caveNoise = openSimplexNoise(worldSeed)
noiseProfile.noiseSeed(worldSeed)
p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
console.log("worldSeed "+worldSeed)
}
win.setSeed = setSeed
win.getSeed = () => worldSeed
class Marsaglia {
// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
nextInt() {
const { z, w } = this;
this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;
return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
}
nextDouble() {
const i = this.nextInt() / 4294967296;
const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0
return is_less_than_zero + i;
}
constructor(i1, i2) { // better param names
this.z = (i1 | 0) || 362436069;
this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
}
}
// The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
const {
randomSeed,
random
} = (() => {
// closure around mut `currentRandom`
let currentRandom = null;
const randomSeed = seed => {
currentRandom = new Marsaglia(seed);
};
const random = (min, max) => {
if (!max) {
if (min) {
max = min;
min = 0;
} else {
min = 0;
max = 1;
}
}
return currentRandom.nextDouble() * (max - min) + min;
};
return {
randomSeed,
random
};
})();
class PerlinNoise {
// http://www.noisemachine.com/talk1/17b.html
// http://mrl.nyu.edu/~perlin/noise/
static grad3d(i, x, y, z) {
const h = i & 15; // convert into 12 gradient directions
const u = h < 8
? x
: y;
const v = h < 4
? y
: h === 12 || h === 14
? x
: z;
return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
}
static grad2d(i, x, y) {
const v = (i & 1) === 0
? x
: y;
return (i & 2) === 0
? -v
: v;
}
static grad1d(i, x) {
return (i & 1) === 0
? -x
: x;
}
static lerp(t, a, b) {
return a + t * (b - a);
}
// end of statics
// permutation
perm = new Uint8Array(0x200);
// prototype functions:
noise3d(x, y, z) {
const { floor } = Math;
const X = floor(x) & 0xff;
const Y = floor(y) & 0xff;
const Z = floor(z) & 0xff;
x -= floor(x);
y -= floor(y);
z -= floor(z);
const fx = (3 - 2 * x) * x * x;
const fy = (3 - 2 * y) * y * y;
const fz = (3 - 2 * z) * z * z;
const { perm } = this;
const p0 = perm[X] + Y;
const p00 = perm[p0] + Z;
const p01 = perm[p0 + 1] + Z;
const p1 = perm[X + 1] + Y;
const p10 = perm[p1] + Z;
const p11 = perm[p1 + 1] + Z;
const { lerp, grad3d } = PerlinNoise;
return lerp(
fz,
lerp(
fy,
lerp(
fx,
grad3d(perm[p00], x, y, z),
grad3d(perm[p10], x - 1, y, z)
),
lerp(
fx,
grad3d(perm[p01], x, y - 1, z),
grad3d(perm[p11],x - 1, y - 1, z)
)
),
lerp(
fy,
lerp(
fx,
grad3d(perm[p00 + 1], x, y, z - 1),
grad3d(perm[p10 + 1], x - 1, y, z - 1)
),
lerp(
fx,
grad3d(perm[p01 + 1], x, y - 1, z - 1),
grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
)
)
);
}
noise2d(x, y) {
const { floor } = Math;
const X = floor(x) & 0xff;
const Y = floor(y) & 0xff;
x -= floor(x);
y -= floor(y);
const { perm } = this;
const fx = (3 - 2 * x) * x * x;
const fy = (3 - 2 * y) * y * y;
const p0 = perm[X] + Y;
const p1 = perm[X + 1] + Y;
const { lerp, grad2d } = PerlinNoise;
return lerp(
fy,
lerp(
fx,
grad2d(
perm[p0],
x,
y
),
grad2d(
perm[p1],
x - 1,
y
)
),
lerp(
fx,
grad2d(
perm[p0 + 1],
x,
y - 1
),
grad2d(
perm[p1 + 1],
x - 1,
y - 1
)
)
);
}
noise1d(x) {
const { floor } = Math;
const X = floor(x) & 0xff;
x -= floor(x);
const fx = (3 - 2 * x) * x * x;
const { lerp, grad1d } = PerlinNoise;
return lerp(
fx,
grad1d(perm[X], x),
grad1d(perm[X + 1], x - 1)
);
}
constructor(seed) {
if (seed === undefined) {
throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
}
const rnd = new Marsaglia(seed);
// generate permutation
const { perm } = this;
// fill 0x0..0x100
for (let i = 0; i < 0x100; ++i) {
perm[i] = i;
}
for (let i = 0; i < 0x100; ++i) {
const j = rnd.nextInt() & 0xFF;
const t = perm[j];
perm[j] = perm[i];
perm[i] = t;
}
// copy to avoid taking mod in perm[0]
// copies from first half of array, into the second half
perm.copyWithin(0x100, 0x0, 0x100);
}
}
const noiseProfile = {
generator: undefined,
octaves: 4,
fallout: 0.5,
seed: undefined,
noiseSeed(seed) {
this.seed = seed;
this.generator = new PerlinNoise(noiseProfile.seed);
},
noise(x, y, z) {
const { generator, octaves, fallout } = (this || noiseProfile);
let effect = 1,
k = 1,
sum = 0;
for (let i = 0; i < octaves; ++i) {
effect *= fallout;
const k = 1 << i;
let temp;
switch (arguments.length) {
case 1: {
temp = generator.noise1d(k * x);
break;
} case 2: {
temp = generator.noise2d(k * x, k * y);
break;
} case 3: {
temp = generator.noise3d(k * x, k * y, k * z);
break;
}
}
sum += effect * (1 + temp) / 2;
}
return sum;
}
};
const noise = noiseProfile.noise
let caveNoise;
// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
function openSimplexNoise(clientSeed) {
const SQ4 = 2
const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) }
const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) }
const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) }
const NORM_3D = 1.0 / 206.0
const SQUISH_3D = 1 / 3
const STRETCH_3D = -1 / 6
var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) }
var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a }
const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} }
function shuffleSeed(seed,count){
seed = seed * 1664525 + 1013904223 | 0
count -= 1
return count > 0 ? shuffleSeed(seed, count) : seed
}
const types = {
_3D : {
base : base3D,
squish : SQUISH_3D,
dimensions : 3,
pD : p3D,
lookup : lookupPairs3D,
}
}
function createContribution(type, baseSet, index) {
var i = 0
const multiplier = baseSet[index ++]
const c = { next : undefined }
while(i < type.dimensions) {
const axis = ("xyzw")[i]
c[axis + "sb"] = baseSet[index + i]
c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
}
return c
}
function createLookupPairs(lookupArray, contributions){
var i
const a = lookupArray()
const res = new Map()
for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
return res
}
function createContributionArray(type) {
const conts = []
const d = type.dimensions
const baseStep = d * d
var k, i = 0
while (i < type.pD.length) {
const baseSet = type.base[type.pD[i]]
let previous, current
k = 0
do {
current = createContribution(type, baseSet, k)
if (!previous) { conts[i / baseStep] = current; }
else { previous.next = current; }
previous = current
k += d + 1
} while(k < baseSet.length)
current.next = createContribution(type, type.pD, i + 1)
if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
i += baseStep
}
const result = [conts, createLookupPairs(type.lookup, conts)]
type.base = undefined
type.lookup = undefined
return result
}
let temp = createContributionArray(types._3D)
const contributions3D = temp[0], lookup3D = temp[1]
const perm = new Uint8Array(256)
const perm3D = new Uint8Array(256)
const source = new Uint8Array(setOf(256))
var seed = shuffleSeed(clientSeed, 3)
doFor(256, function(i) {
i = 255 - i
seed = shuffleSeed(seed, 1)
var r = (seed + 31) % (i + 1)
r += r < 0 ? i + 1 : 0
perm[i] = source[r]
perm3D[i] = (perm[i] % 24) * 3
source[r] = source[i]
})
base3D = undefined
lookupPairs3D = undefined
p3D = undefined
return function(x, y, z) {
const pD = perm3D
const p = perm
const g = gradients3D
const stretchOffset = (x + y + z) * STRETCH_3D
const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
const inSum = xins + yins + zins
var c = lookup3D.get(
(yins - zins + 1) |
((xins - yins + 1) << 1) |
((xins - zins + 1) << 2) |
(inSum << 3) |
((inSum + zins) << 5) |
((inSum + yins) << 7) |
((inSum + xins) << 9)
)
var i, value = 0
while (c !== undefined) {
const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
let attn = 2 - dx * dx - dy * dy - dz * dz
if (attn > 0) {
i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF]
attn *= attn
value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
}
c = c.next
}
return value * NORM_3D + 0.5
}
}
//copied from https://gist.github.com/bzdgn/d722c961f45d97ea8efc6cef3aa39e76
function nodeRotationX(node, theta) {
var cosTheta = Math.cos(theta);
var sinTheta = Math.sin(theta);
var y = node.y;
var z = node.z;
node.y = y * cosTheta - z * sinTheta;
node.z = y * sinTheta + z * cosTheta;
}
function nodeRotationY(node, theta) {
var cosTheta = Math.cos(theta);
var sinTheta = Math.sin(theta);
var x = node.x;
var z = node.z;
node.x = x * cosTheta - z * sinTheta;
node.z = x * sinTheta + z * cosTheta;
}
var node = {x:0, y:0, z:0}
function getRotation(rotX, rotY){
//node.x = -sin(rotY) * cos(rotX)
//node.y = sin(rotX)
//node.z = cos(rotY) * cos(rotX)
node.x = 0;node.y=0;node.z=1
nodeRotationX(node,rotX+Math.PI)
node.z = -node.z
nodeRotationY(node,rotY)
return node
}
win.getRotation = getRotation
class PVector {
constructor(x, y, z) {
this.x = x
this.y = y
this.z = z
}
set(x, y, z) {
if (y === undefined) {
this.x = x.x
this.y = x.y
this.z = x.z
} else {
this.x = x
this.y = y
this.z = z
}
}
normalize() {
let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
this.x /= mag
this.y /= mag
this.z /= mag
}
add(v) {
this.x += v.x
this.y += v.y
this.z += v.z
}
mult(m) {
this.x *= m
this.y *= m
this.z *= m
}
crossProduct(x,y,z,vector) {
vector.x = this.y * z - this.z * y
vector.y = this.z * x - this.x * z
vector.z = this.x * y - this.y * x
return vector
}
product(x,y,z,vector) {
vector.x = this.x * x
vector.y = this.y * y
vector.z = this.z * z
return vector
}
}
let fill = function(r, g, b, a) {
if (g === undefined) {
g = r
b = r
}
a = a || a === 0 ? a : 100
ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ", "+a+"%)"
}
let stroke = function(r, g, b) {
if (g === undefined) {
g = r
b = r
}
ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
}
let line = function(x1, y1, x2, y2) {
ctx.moveTo(x1, y1)
ctx.lineTo(x2, y2)
}
let ellipse = function(x,y,w,h){
if(ctx.ellipse){
ctx.ellipse(x,y,w,h,0, 0,Math.PI*2)
}
}
function text(txt, x, y, h) {
h = h || 0
let lines = txt.split("\n")
for (let i = 0; i < lines.length; i++) {
if(lines[i].includes("§")){
var textAlign = ctx.textAlign
ctx.textAlign = "left"
var fillStyle = ctx.fillStyle
let tw = ctx.measureText(lines[i].replace(/§./g, "")).width
let m2 = tw / 2
switch(textAlign){
case "right":
x -= m2
break
case "center":
break
default:
x += m2
break
}
let codes = lines[i].split("§")
ctx.fillText(codes[0], x-m2, y + h * i)
var xStr = codes[0]
let tx = ctx.measureText(xStr).width
for(var j=1; j<codes.length; j++){
let str = codes[j]
ctx.fillStyle = colors[str.substring(0,1)]
str = str.substring(1)
ctx.fillText(str, x+tx-m2, y+h*i)
xStr += str
tx = ctx.measureText(xStr).width
}
ctx.textAlign = textAlign
ctx.fillStyle = fillStyle
}else{
ctx.fillText(lines[i], x, y + h * i)
}
}
}
function textSize(size) {
ctx.font = size + 'px VT323' // VT323
}
let strokeWeight = function(num) {
ctx.lineWidth = num
}
function map(v, min, max, min2, max2){
return min2 + (max2 - min2) * ((v - min) / (max - min));
}
function dist2(x,y,x2,y2){
let xDist = x - x2
let yDist = y - y2
return sqrt((xDist*xDist)+(yDist*yDist))
}
function dist3(x,y,z,x2,y2,z2){
let xDist = x - x2
let yDist = y - y2
let zDist = z - z2
return sqrt((xDist*xDist)+(yDist*yDist)+(zDist*zDist))
}
win.dist2 = dist2; win.dist3 = dist3
const ARROW = "arrow"
const HAND = "pointer"
let cursor = function(type) {
canvas.style.cursor = type
}
randomSeed(Math.random() * 10000000 | 0)
async function createDatabase() {
return await new Promise(async (resolve, reject) => {
let request = window.indexedDB.open("MineKhan", 1)
request.onupgradeneeded = function(event) {
let DB = event.target.result
// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
// and a "data" string that's identical to the copy/paste save string
let store = DB.createObjectStore("worlds", { keyPath: "id" })
store.createIndex("id", "id", { unique: true })
store.createIndex("data", "data", { unique: false })
}
request.onsuccess = function(e) {
resolve(request.result)
}
request.onerror = function(e) {
console.error(e)
reject(e)
}
})
}
async function loadFromDB(id) {
return await new Promise(async (resolve, reject) => {
let db = await createDatabase()
let trans = db.transaction("worlds", "readwrite")
let store = trans.objectStore("worlds")
let req = id ? store.get(id) : store.getAll()
req.onsuccess = function(e) {
resolve(req.result)
db.close()
}
req.onerror = function(e) { 
resolve(null)
db.close()
}
})
}
async function saveToDB(id, data) {
return new Promise(async (resolve, reject) => {
let db = await createDatabase()
let trans = db.transaction("worlds", "readwrite")
let store = trans.objectStore("worlds")
let req = store.put({ id: id, data: data })
req.onsuccess = function() {
resolve(req.result)
}
req.onerror = function(e) {
reject(e)
}
})
}
async function deleteFromDB(id) {
return new Promise(async (resolve, reject) => {
let db = await createDatabase()
let trans = db.transaction("worlds", "readwrite")
let store = trans.objectStore("worlds")
let req = store.delete(id)
req.onsuccess = function() {
resolve(req.result)
}
req.onerror = function(e) {
reject(e)
}
})
}
function save(getObj) {
world = dimensions.overworld
var obj = {
id: world.id,
edited: Date.now(),
name: world.name,
version: world.version || version,
code: world.getSaveString(),
nether: world.getNetherSaveString(),
inv: world.getInv(),
surviv: world.getSurvivStr(),
ent: world.getEntities(),
tags: world.getEditedTags(),
mod: world.mod,
thumbnail: genWorldImage(),
achievments:achievments,
playersInv: playersInv,
settings: worldSettings
}
if(!getObj){
saveToDB(world.id, obj).then(() => world.edited = Date.now()).catch(e => console.error(e))
}else{
return obj
}
}
win.save = save
function getSaveJSON(){
var obj = save(true)
delete obj.thumbnail
return JSON.stringify(obj)
}
let thumbCnv = document.createElement("canvas")
thumbCnv.width = thumbCnv.height = 64
let thumbCtx = thumbCnv.getContext("2d")
win.genWorldImage = function(){
var midx = gl.canvas.width / 2, midy = gl.canvas.height / 2
var size = min(gl.canvas.width, gl.canvas.height), s2 = size / 2
thumbCtx.drawImage(gl.canvas, midx - s2, midy - s2, size,size, 0,0,64,64)
return thumbCnv.toDataURL("image/png")
}
win.thumbCnv = thumbCnv, win.thumbCtx = thumbCtx
// Expose these functions to the global scope for debugging
win.saveToDB = saveToDB
win.loadFromDB = loadFromDB
win.createDatabase = createDatabase
win.deleteFromDB = deleteFromDB
//globals
//{
let version = "Alpha 1.0.4"
doc.title = "MineKhan "+version
let normReach = 5
let bigReach = 40
let reach = normReach // Max distance player can place or break blocks
let defaultSky = [0.6, 0.8, 0.9]
let sky = [...defaultSky]/*[0.33, 0.54, 0.72, (originl sky)]*/ // 0 to 1 RGB color scale
let superflat = false
let trees = true
let caves = true
let survival = false;
let cheats = false
let dieMessage = ""
let touchMoveLimit = 500 //(touch screen only) miliseconds before it decides you want to break a block
let blockIds = {}
blockData.forEach(block => blockIds[block.name] = block.id)
blockData.forEach(block => {
if(block.rotate && block.name.includes("SW")){
var unSw = block.name.replace("SW",'')
if(blockIds[unSw]){
block.drop = unSw
var obj = blockData[blockIds[unSw]]
block.breakTime = obj.breakTime
block.type = obj.type
}
}
})
win.blockData = blockData
win.blockIds = blockIds
win.eachFrame = null
var currentAmbient = {} //Object with ambient sound sources
var currentAmbientVolume = {}
win.currentAmbient = currentAmbient
//fill the crafts that have less than 9 items. Ex: "thing" => "thing,air,air..."
let arr, arr2 = new Array(9)
for(let i in crafts){
arr = i.split(",")
for(let j = 0; j<9; j++){
if(arr[j]){
arr[j] = blockIds[arr[j]]
}else{
arr.push(0)
}
}
crafts[i].id = blockIds[crafts[i].name]
if(crafts[i].amount === undefined) crafts[i].amount = 1
crafts[arr.join(",")] = crafts[i]
//shaped recipes
if(crafts[i].shaped){
var craft2 = Object.assign({},crafts[i])
craft2.hidden = true
var xSpace = 3, ySpace = 3
//find how much empty space there is
for(var x=2; x>=0; x--){
var a = arr[x]
var b = arr[x+3]
var c = arr[x+6]
if(a||b||c){
xSpace = x
break
}
}
for(var y=2; y>=0; y--){
var a = arr[y*3]
var b = arr[(y*3)+1]
var c = arr[(y*3)+2]
if(a||b||c){
ySpace = y
break
}
}
var offsetX = -1, offsetY = -1
for(var x = xSpace; x<3; x++){
offsetX ++
for(var y = ySpace; y<3; y++){
offsetY ++
if(x === xSpace && y === ySpace) continue
arr2.fill(0)
for(var x2 = 0; x2<3; x2++){
for(var y2 = 0; y2<3; y2++){
var b = arr[x2+(y2*3)]
if(b){
var bx = x2 + offsetX
var by = y2 + offsetY
arr2[bx+(by*3)] = b
}
}
}
crafts[arr2.join(",")] = craft2
}
offsetY = -1
}
}
delete crafts[i]
}
win.crafts = crafts
function shapelessCraft(craft) {
let arr2 = craft;
arr2.sort(function(a, b) {
return a - b;
});
let arr = [];
for(let i in crafts) {
if(!crafts[i].shapeless) continue;
arr = i.split(",");
arr.sort(function(a, b) {
return a - b;
});
let comp = arr.map(num => Number(num));
if(arrayValues(comp,arr2)) {
return i;
}
}
}
for(i in smelts){
smelts[i].id = blockIds[smelts[i].name]
smelts[blockIds[i]] = smelts[i]
delete smelts[i]
}
for(i in smeltFuel){
smeltFuel[i].operations = smeltFuel[i].time / 10
smeltFuel[i].ops = smeltFuel[i].operations / smeltFuel[i].time //operations per seconds
smeltFuel[blockIds[i]] = smeltFuel[i]
delete smeltFuel[i]
}
win.smelts = smelts; win.smeltFuel = smeltFuel
let currentFov
// Configurable and savable settings
let settings = {
renderDistance: 4,
fov: 70, // Field of view in degrees
mouseSense: 100, // Mouse sensitivity as a percentage of the default
volume: 1, //volume for all the sounds
narrator: false, //read chat & stuff
narratorPitch: 1,
narratorRate: 1,
narratorVoice: null, // defined later
controls: {}
}
win.settings = settings
// Some settings for the world
let defaultWorldSettings = {
tntExplode:true,
killCmdOff:false,
dayNightCycle: true,
blocksFall: true,
pvp: true,
}
let worldSettings = Object.assign({}, defaultWorldSettings)
win.worldSettings = worldSettings
let locked = true
let generatedChunks
let mouseX, mouseY, mouseDown
let width = window.innerWidth
let height = window.innerHeight
class Skybox{ //from https://www.khanacademy.org/computer-programming/skybox/5709195676041216 with syntax modifications
constructor(){
this.vertexData = new Float32Array([
//bottom vertices
-1.0, -1.0, -1.0,
1.0, -1.0, -1.0,
1.0, -1.0,  1.0,
-1.0, -1.0,  1.0,
// top vertices
-1.0,  1.0, -1.0,
1.0,  1.0, -1.0,
1.0,  1.0,  1.0,
-1.0,  1.0,  1.0
]);
this.faceData = new Uint8Array([
//-y
1, 0, 3,
1, 3, 2,
//+y
5, 7, 4,
5, 6, 7,
//+x
1, 2, 5,
2, 6, 5,
//-x
0, 4, 3,
3, 4, 7,
//-z
0, 1, 5,
0, 5, 4,
//+z
3, 7, 6,
3, 6, 2
]);
gl.enableVertexAttribArray(glCache.skyboxVertex);
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
this.buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
this.indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.faceData, gl.DYNAMIC_DRAW);
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
render() {
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.vertexAttribPointer(glCache.skyboxVertex, 3, gl.FLOAT, false, 4 * 3, 0);
gl.uniformMatrix4fv(glCache.skyboxView, false, p.transformation.elements)
gl.drawElements(gl.TRIANGLES, this.faceData.length, gl.UNSIGNED_BYTE, 0);
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
let skybox
let colors = {
0: "#000",
1: "#00a",
2: "#0a0",
3: "#0aa",
4: "#a00",
5: "#a0a",
6: "#fa0",
7: "#aaa",
8: "#555",
9: "#55f",
a: "#5f5",
b: "#5ff",
c: "#f55",
d: "#f5f",
e: "#ff5",
f: "#fff",
g: "#DDD605",//minecoin gold
}
if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")
let generator = {
height: 80, // Height of the hills
smooth: 0.01, // Smoothness of the terrain
extra: 30, // Extra height added to the world.
caveSize: 0.00, // Redefined right above where it's used
biomeSmooth: 0.007, // Smoothness of biomes
}
win.generator = generator //for mods
let maxHeight = 255
let blockOutlines = false
let blockFill = true
let updateHUD = true
var explodeVaos = [], experienceOrbVaos = [], genericVaos = []
let images = {
attackIndicatorCrosshair: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAHBAMAAAC8U9OhAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAKlBMVEUAAAD///86OzzS0tbX2erq7PI6OzxbSkmCbWxtWVfX2er////q7PL///+PAAbaAAAABnRSTlMAAAAAAABupgeRAAAAAWJLR0QN9rRh9QAAAAd0SU1FB+UICBISCBYUzEAAAAABb3JOVAHPoneaAAAASklEQVQI12NgYGOAAHYwyQilGRjSoKCzcxUYQOnVMAmFzs4zu4HABEobMKAZxeIAMwoNMAoKigouAWIsEoJRqxwFA7HpCFkClAAAVfMfb4rLipMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDgtMDhUMTg6MTc6MTgrMDA6MDB6HTijAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA4LTA4VDE4OjE3OjE4KzAwOjAwC0CAHwAAAABJRU5ErkJggg==",
deadHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==",
heart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=",
halfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC",
whiteHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAARUlEQVQoU61QQQ4AIAiK/z+aBsuNbN7ykKQEJtYJkhQEgMSu6VBRzQn7VRFKNbP7/0h9jscqZ+m2efePcg21ghS4SJP1BvDiR/68vCmnAAAAAElFTkSuQmCC",
witherHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJ1BMVEUAAAAAAAA7ExPLy8srKysvDw8nJycdHR0qDg4gICA5HBxHHBz///8BX2maAAAAAXRSTlMAQObYZgAAAAFiS0dEDIGzUWMAAAAHdElNRQfkCBcNAScIdsCqAAAAAW9yTlQBz6J3mgAAADpJREFUCNdjYBBkFGBgYFQSUmRgEDJRcRJgEHVxcxdgkJjmMkuAgbHTcyEDA4PEbKAaBsaNDCAAZAIArksGwN+RpQkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTM6MDE6MzkrMDA6MDAs2fv0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDEzOjAxOjM5KzAwOjAwXYRDSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MTg3Njk53UrJaAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTA3NzIwNzAyOTQ0NjEzMTIwMzcf2rzMAAAAAElFTkSuQmCC",
witherHalfHeart: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAlElEQVQoU2NkQID/UCYjAwMDMpsBJAAC/y24ucGME1+/MoiLi4PZL1++BFGMYF0gBVMOHmSIjo5mEHzyhOE+Dw/cfJBCsCJtNjaGP4qKcIkPHz5gKlJlY2P4KiLCwMHBwcDKysqATRHYTTCFvLy8cEXIboIZDVf49+9fuKPBLkcKArCJrqKiDLtfv0aRQ1cEVoiuGQBusjgHiQpSWAAAAABJRU5ErkJggg==",
freezeHeart:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAKVJREFUKFNjZECA/1AmIwMDAzKbASTAwMjE/N9r5zWwmq2u6gzeu2/C2SBpsC6QYKy1KsPio7cZzLTFGU5dfckQZ6PGsOjILbAmuCKQVpACDUF+hhvvP4IVwkwGK1r5/T9YIlGMnyFz/y2wKSA+SEM4JyPETWCH7v/E0Kj+D6xw/quPDPU3mRgYHPnAToYpQlGIrACsCikI4AphJsDk0BVBFKJpBgBbYkAHTYvoqAAAAABJRU5ErkJggg==",
freezeHalfHeart:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAJxJREFUKFNjZECA/1AmIwMDAzKbASTAwMjE/N9r5zWwmq2u6gwaGhpg9o0bN8DSYF3eu28yxFqrMiw+epvBTFucYbmTBdx8kEK4IpAoSIGGID9DvaEmpqKV3/8z3Hj/kSFRjJ8hc/8thru5/hiKQAL/GfZ/YmhU/wdW6KYDMQnZTTBdcIUgN8EUgF2OFARwExkc+VDk0BVBFKJpBgBAXzsHeDkERgAAAABJRU5ErkJggg==",
bubble: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEUAAAAAAAAAlP/R6/9WuP////8DieLBAAAAAXRSTlMAQObYZgAAAAFiS0dEBfhv6ccAAAAHdElNRQflBhwAOQFmUYA6AAAAAW9yTlQBz6J3mgAAAC9JREFUCNdjYGAUZAACISUBBgZGBQZFIJPZgEUASDKASAYQCRR3BKoRcQGqAasHADZEAh1qmnpBAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTA2LTI4VDAwOjU1OjAxKzAwOjAwEE5qGwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wNi0yOFQwMDo1NTowMSswMDowMGET0qcAAAAASUVORK5CYII=",
bubblePop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAADFBMVEUAAAAAlP8AAAD///8Mq+G/AAAAAXRSTlMAQObYZgAAAAFiS0dEAxEMTPIAAAAHdElNRQflBhwBAwbcXqHXAAAAAW9yTlQBz6J3mgAAACVJREFUCNdjYHBgYHBwZGCY0MbAoMDBAAYOjA4MLUwNDBIsYDEAStwDy/jv20gAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjEtMDYtMjhUMDE6MDM6MDYrMDA6MDB0NlEVAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIxLTA2LTI4VDAxOjAzOjA2KzAwOjAwBWvpqQAAAABJRU5ErkJggg==",
drumstickBG: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAQAAABKmM6bAAAABGdBTUEAALGPC/xhBQAAAAJiS0dEAP+Hj8y/AAAAB3RJTUUH5AgXESYlKYFJ9wAAAAFvck5UAc+id5oAAAA8SURBVAjXZc2xDcAwDAPBk6bR/tN4G6VQ4MTwV8SDBIHWNoEurMmIEX4yv0GZeYrlJLml/dnV5zdeeXU9xdgUJaD0S9kAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTc6Mzg6MzcrMDA6MDDZqKf0AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDE3OjM4OjM3KzAwOjAwqPUfSAAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MjA0MzE3ULE6DQAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTIwMTgzMjY0MzU0MzI0OTcxOTF/QUjUAAAAAElFTkSuQmCC",
drumstick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJFBMVEUAAAAAAADUKiqyGBjfsY+4hFidbUNhPBt7US3i1ar/99z///9NiP3lAAAAAXRSTlMAQObYZgAAAAFiS0dECx/XxMAAAAAHdElNRQfkCBcRJiawiBhNAAAAAW9yTlQBz6J3mgAAAC5JREFUCNdjYBBkAAJGZQEgKeQUCCSFVVOBHMaKNJCQeAeIZBScCKIYpMCkIAMAcDQEJB3YgfcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjNUMTc6Mzg6MzgrMDA6MDAv4NcdAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIzVDE3OjM4OjM4KzAwOjAwXr1voQAAACB0RVh0c29mdHdhcmUAaHR0cHM6Ly9pbWFnZW1hZ2ljay5vcme8zx2dAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA5Gf/zMgAAABV0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAA51JEX7wAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTk4MjA0MzE4wA4nnAAAAA50RVh0VGh1bWI6OlNpemUAMELJbxjtAAAANnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL3RodW1ibHIvaW1nMTMzODIyODY4OTM1NDEwNTg2ODQQPSTjAAAAAElFTkSuQmCC",
halfDrumstick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAjUlEQVQoU2NkQID/UCYjkhiYCRP4r6GhwdD98iWD7/v3yOJwRWAFB+fWMbxJqGe49+YNhkKQSWBFILChIJjhb+8qhicJRgzu1SvhJmJYB5J5HWPAkDR5P4YikADYREvBNwzS4qIMLRuuY1UEVgjz2eNraxhktUJQfIfua7CG/9/vMjByKsODAKsiWLgBAAIkLghjp1NyAAAAAElFTkSuQmCC",
cold:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAHxJREFUKFNjZEAD/S/+7y+UYHREFmaEcUCSILYlDwPD8S8QUZhixuwHEEkVDlQFILGrj1+CFTN63oAoUuKA6AYphkm+fPsBociYn4Hh7EeIoj9v3jBwfHmL4lK4STBR8hXBTIC5DdmkzR4a4KCABwFMseuR1/t324iihBMAZ9FAUIfw/h8AAAAASUVORK5CYII=",
hot:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAGxJREFUKFOFkDsKgDAQRN+C19NCsPCEKQQLvZ4QmTXRxCBus595GYYYPxV7omXGlx3fm/lLLGF7QxLlqHueK3sXZiCAd1XgyeAHCROwpD5erlXwG9IDgXJpoBXoIhwGycVzld/kmbYIg7lD1k5Fkzjr1as+mQAAAABJRU5ErkJggg==",
warm:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAFlJREFUKFNjZCACMOJSY1rzfz9I7nQLoyOGIpgkSMGvN9cZLs7QQlUEUmCvwcBw8AbEfJApIBpuEroCmCkYimDuAykAAZBVWBXBFGBVBBIEWYluCopJ+IILAI7OLwq+l1sIAAAAAElFTkSuQmCC",
experienceBar:[
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALYAAAAKCAMAAAAuJlQ4AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACVVBMVEUAAAAJEAw2QzwuOjMpNS8UHxkgKyUgLCUZJB4oMy0IHBEWLRoiPSItSylDaSRjkECLylmIxleGxFdglzRajTE4XhpSgSxMdylxpEh4rk1yp0trm0UsSRVGbSV9tFCPzlx4rkxYijBQfiwzVRhLdShFbCVchTt6sU5TgixHbiVrnEV3rUxVhi5XiC81VhdxpUl9tVB2qkxOeSpNeSouSxV0p0p7s1B1qkt3rExTgy0yUxdZizCJx1iEwFVTgSxbkDGBvFNtnUVUhC4gOg0gOA10qkhllT9eijtOeioaPipMdilpmENIcSdzp0pvoUlTfy96sU95r05TgS1ypUiHxFd9tU9Why92qUtvoEZNeClqmUR2qktKdCiHw1aP0V1Ugy1IcCZJcidsnUZ8tFB5sE6IxlhTgi2NwGS09X6f2nGTyWh6pleOwmVeiT2Rx2ea0myEtF14o1VxmlBpmESY0GuCsFuLvmKLvmOKvGJmlEIvTxZnlUKGt112oVOf2nCo5neLyVluoEeVzGmu7nqj3nOPw2SRxmaCvVQzVRlolkOBsFuWzWplkUCDs1yArlqVy2l3olQWNSRq",
"mkWIuWCRxWdfiz5/rVmCslxmk0Gp5nab1W2Ds12NwmOXzmqDslwuTBWUy2l8qViz832QxGaLvWOCsVxjjz9jjj+LvWKJvGGCsV2MvmOIuWF+rFhHbyZvokhOeytlkkFfiT1RfyxzpkpPfCtUgyxSfyxzqEtWiC9fiT5Ugi1ijUB1qUxdjzVelDN5sE1zp0mKyVlwo0hPfStypkn///82xGcQAAAAAXRSTlMAQObYZgAAAAFiS0dExvoCes0AAAAHdElNRQflCgkTMix8LVIBAAAAAW9yTlQBz6J3mgAAAqxJREFUOMvVU2dXE0EU3VBlN8xiBAecQUWTWTVEoqBA7Bp1zcauKLGCPYBZFwgoYgdlKQp2sfeKYi/Y9X85s2QTjp/hA+/TPfe+d+edOfdxnGUYFsdZ4uITWMXHJQ4ySkoaMmsLZ0lIHsEqOSFxkFFKypBZW4brbw/TbHO8IFhpCbR4hgSelUkZIpN4s4+pDKVa2YBgjvJRMerGG9OpVmtkgtEGKUTfiODoI0LsEQP2c9QkNbYN1ejWAIhpI222UekZo2Fmlm0MAgCD7LHjbONRzoSJdgdBNglNmowBIFOckpTrmgphnnsaQtPzC7Khe8bMwiJXsQfOmj3HKTnnujzF82zz0woX2Bcu8gK4eMlSQqC8zCcTpIjE58B+gNzu5StW+pjhqtUiyadozdp1adL6Euix+xVpw0YRlHoACLg3ETFnM/ZDZcvWvMycbXh7WfkO585du2We48mevfuCFRWVBFftD1WqBzS1GpNgTa0arqs/eKjhcG2NplUwrjEUCoaPHD2WcfzEyVNN4XDz6TMtQV3TdFUlONBaqTKs",
"4LZ2nZpoWkcBbg+dPUe5OtTZdZ6Kmt5RhdsuNKsUqhcxuaQ3NWr65RZ85eq1uu5uXc/zlF+/wRpvoltt6u07Wn1IIxi13r13X1UfPMSPHj95qj97/oLQtXvSXxKisD9+VdIrNiAkl2JZJq8bkGL8e1ZRF0L5FL15S1XFT9E7RMRCyeXAENI+hdC+0vdIpC6QqrJCCAlA4PV+gNT5o1MGnWUyERXDsPhTL5VRD8AOGVHAOEc2+UyUauDH9i8i6ev7+g16cr//+Cn9+m33Y/DnL6LmbBlAxC5EER/NdiS0kdgZcaKB4gdmkTdRZCLSaJImN+AEzEQL/S5CNPvW/46FhdeAlBPMw4gFPnYEgtHP/QMLi7iU40xIawAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0xMC0wOVQxOTo1MDowOCswMDowMPuKPhEAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMTAtMDlUMTk6NTA6MDgrMDA6MDCK14atAAAAAElFTkSuQmCC"
//splitting it because it is too long
].join(""),
generic: "https://data.thingmaker.repl.co/images/generic.png",
explode: "https://data.thingmaker.repl.co/images/explode.png",
experienceOrb:"https://data.thingmaker.repl.co/images/experience_orb.png",
freezeEffect: "https://data.thingmaker.repl.co/images/freeze_effect.png",
spyglassScope:"https://data.thingmaker.repl.co/images/spyglass_scope.png",
skin:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAFDUlEQVR42u2a20sUURzH97G0LKMotPuWbVpslj1olJXdjCgyisowsSjzgrB0gSKyC5UF1ZNQWEEQSBQ9dHsIe+zJ/+nXfM/sb/rN4ZwZ96LOrnPgyxzP/M7Z+X7OZc96JpEISfWrFhK0YcU8knlozeJKunE4HahEqSc2nF6zSEkCgGCyb+82enyqybtCZQWAzdfVVFgBJJNJn1BWFgC49/VpwGVlD0CaxQiA5HSYEwBM5sMAdKTqygcAG9+8coHKY/XXAZhUNgDYuBSPjJL/GkzVVhAEU5tqK5XZ7cnFtHWtq/TahdSw2l0HUisr1UKIWJQBAMehDuqiDdzndsP2EZECAG1ZXaWMwOCODdXqysLf++uXUGv9MhUHIByDOijjdiSAoH3ErANQD73C7TXXuGOsFj1d4YH4OTJAEy8y9Hd0mCaeZ5z8dfp88zw1bVyiYhCLOg1ZeAqC0ybaDttHRGME1DhDeVWV26u17lRAPr2+mj7dvULfHw2q65fhQRrLXKDfIxkau3ZMCTGIRR3URR5toU38HbaPiMwUcKfBAkoun09PzrbQ2KWD1JJaqswjdeweoR93rirzyCMBCmIQizqoizZkm2H7iOgAcHrMHbbV9KijkUYv7qOn55sdc4fo250e+vUg4329/Xk6QB/6DtOws+dHDGJRB3XRBve+XARt+4hIrAF4UAzbnrY0ve07QW8uHfB+0LzqanMM7qVb+3f69LJrD90/1axiEIs6qIs21BTIToewfcSsA+Bfb2x67OoR1aPPzu2i60fSNHRwCw221Suz0O3jO+jh6V1KyCMGse9721XdN5ePutdsewxS30cwuMjtC860T5JUKpXyKbSByUn7psi5l+juDlZYGh9324GcPKbkycaN3jUSAGxb46IAYPNZzW0AzgiQ5tVnzLUpUDCAbakMQXXrOtX1UMtHn+Q9/X5L4wgl7t37r85OSrx+TYl379SCia9KXjxRpiTjIZTBFOvrV1f8ty2eY/T7XJ81FQAwmA8ASH1ob68r5PnBsxA88/xAMh6SpqW4HRnLBrkOA9Xv5wPAZjAUgOkB+SHxgBgR0qSMh0zmZRsmwDJm1gFg2PMDIC8/nAHIMls8x8GgzOsG5WiaqREgYzDvpTwjLDy8NM15LpexDEA3LepjU8Z64my+8PtDCmUyRr+fFwA2J0eAFYA0AxgSgMmYBMZTwFQnO9RNAEaHOj2DXF5UADmvAToA2ftyxZYA5BqgmZZApDkdAK4mAKo8GzPlr8G8AehzMAyA/i1girUA0HtYB2CaIkUBEHQ/cBHSvwF0AKZFS5M0ZwMQtEaEAmhtbSUoDADH9ff3++QZ4o0I957e+zYAMt6wHkhzpjkuAcgpwNcpA7AZDLsvpwiuOkBvxygA6Bsvb0HlaeKIF2EbADZpGiGzBsA0gnwQHGOhW2snRpbpPexbAB2Z1oicAMQpTnGKU5ziFKc4xSlOcYpTnOIUpzgVmgo+XC324WfJAdDO/+ceADkCpuMFiFKbApEHkOv7BfzfXt+5gpT8V7rpfYJcDz+jAsB233r6yyBsJ0mlBCDofuBJkel4vOwBFPv8fyYAFPJ+wbSf/88UANNRVy4Awo6+Ig2gkCmgA5DHWjoA+X7AlM//owLANkX0w0359od++pvX8fdMAcj3/QJ9iJsAFPQCxHSnQt8vMJ3v2wCYpkhkAOR7vG7q4aCXoMoSgG8hFAuc/grMdAD4B/kHl9da7Ne9AAAAAElFTkSuQmCC",
minekhan: "https://data.thingmaker.repl.co/images/minekhan.png",
panorama: /*"https://i.servimg.com/u/f48/18/06/99/75/fr-min10.jpg"//*/"https://server.thingmaker.repl.co/panorama",
}
let crossOriginImages = ["generic","explode","experienceOrb","panorama"]
for(var i in images){
var url = images[i]
images[i] = new Image()
images[i].src = url
images[i].onload = () => loadDone()
images[i].onerror = err => {loadDone(); console.log(err)}
if(crossOriginImages.includes(i)){
images[i].crossOrigin = ""
}
}
win.images = images
let audioCtx
let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,WALL,
WALLU,//wall withe exteion under another wall
FENCQ,//fence (one extension)
BUTTON,CHAIN,POT,POTCROSS,CARPET,LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
let isCube
var prevConstVersion = null
var curConst = 0
function nextConst(rotate, flip){
var n = 1
if(rotate) n = 4
if(flip) n = 8
var p=curConst
curConst += n*500
return p
}
function verMoreThan(a,b){
a = a.split(".")
b = b.split(".")
if(a[0] > b[0]) return true
if(a[1] > b[1] && a[0] === b[0]) return true
if(a[2] > b[2] && a[1] === b[1]) return true
}
function constVersion(v){
if(v === prevConstVersion) return
prevConstVersion = v
isCube = 0xff
var verNum = v.replace(/Alpha /, '')//.replace(/(?<=\..*)\./g, '') //second regex removes the periods after the first
if(verMoreThan(verNum, "1.0.3") || verNum==="1.0.3"){
CUBE = 0
LAYER2 = SLAB = 0x100<<5 // 9th bit
LAYER3 = STAIR = 0x200<<5 // 10th bit
LAYER4 = CROSS = 0x300<<5
LAYER5 = TALLCROSS = 0x700<<5
LAYER6 = LANTERN = 0x900<<5
LAYER7 = LANTERNHANG=0x1100<<5
BEACON = 0x1300<<5
CACTUS = 0x1400<<5
POT = 0x1500<<5
POTCROSS = 0x1700<<5
LAYER1 = TORCH = 0x1800<<5
CHAIN = 0x1900<<5
LAYER8 = DOOR = 0x2100<<5
PORTAL = 0x2200<<5
WALLFLAT = 0x2300<<5
PANE = 0x4400<<5
TRAPDOOR = 0x2800<<5
TRAPDOOROPEN=0x4000<<5
FENCE = 0x6000<<5
WALLPOST = 0x6200<<5
WALL = 0x6400<<5
WALLU = 0x6600<<5 //wall withe exteion under another wall
FENCQ = 0x4100<<5 //fence (one extension)
BUTTON = 0x4200<<5
CARPET    = 0x4300<<5
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
isCube = BLOCK_COUNT
}else if(verNum >= 1){
CUBE = 0
LAYER2 = SLAB = 0x100 // 9th bit
LAYER3 = STAIR = 0x200 // 10th bit
LAYER4 = CROSS = 0x300
FLIP = 0x400 // 11th bit
LAYER5 = TALLCROSS = 0x700
LAYER6 = LANTERN = 0x900
LAYER7 = LANTERNHANG=0x1100
BEACON = 0x1300
CACTUS = 0x1400
POT = 0x1500
POTCROSS = 0x1700
LAYER1 = TORCH = 0x1800
CHAIN = 0x1900
LAYER8 = DOOR = 0x2100
PORTAL = 0x2200
WALLFLAT = 0x2300
PANE = 0x4400
TRAPDOOR = 0x2800
TRAPDOOROPEN=0x4000
FENCE = 0x6000
WALLPOST = 0x6200
WALL = 0x6400
WALLU = 0x6600 //wall withe exteion under another wall
FENCQ = 0x4100 //fence (one extension)
BUTTON = 0x4200
CARPET    = 0x4300
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits
}else{
CUBE      = 0
LAYER2 = SLAB      = 0x100 // 9th bit
LAYER3 = STAIR     = 0x200 // 10th bit
LAYER4 = CROSS     = 0x2000
LAYER5 = TALLCROSS = 0x2200
LAYER8 = DOOR      = 0x2400
LAYER1 = TORCH     = 0x2600
LAYER6 = LANTERN   = 0x2800
LAYER7 = LANTERNHANG=0x3000
BEACON    = 0x4200
CACTUS    = 0x4400
PANE      = 0x4600
PORTAL    = 0x5000
WALLFLAT  = 0x4800
TRAPDOOR  = 0x5200
TRAPDOOROPEN=0x5400
FENCE     = 0x6000
WALLPOST  = 0x6200
WALL      = 0x6400
WALLU     = 0x6600 //wall withe exteion under another wall
FENCQ     = 0x6800 //fence (one extension)
BUTTON    = 0x7000
CHAIN     = 0x7200
POT       = 0x8000
POTCROSS  = 0x8200
CARPET    = 0x8400
FLIP      = 0x400 // 11th bit
NORTH     = 0 // 12th and 13th bits for the 4 directions
SOUTH     = 0x800
EAST      = 0x1000
WEST      = 0x1800
ROTATION  = 0x1800 // Mask for the direction bits
}
initBlockData()
genIcons()
}
let blockMode   = CUBE
win.changeBlockMode = m => blockMode = m
let tex
let textureAtlas
let textureMap
let dirtBuffer, netherBuffer
let dirtTexture, netherTexture, explodeTexture, panoramaTexture, experienceOrbTexture, genericTexture, skinTexture
let textureCoords
let texCoordsBuffers
let mainbg, dirtbg, netherbg // Background images
let bigArray = win.bigArray || new Float32Array(6000000)
win.bigArray = bigArray
// Callback functions for all the screens; will define them further down the page
let drawScreens = {
"main menu": () => {},
"options": () => {},
"play": () => {},
"pause": () => {},
"creation menu": () => {},
"inventory": () => {},
"multiplayer menu": () => {},
"comingsoon menu": () => {},
"loadsave menu": () => {},
"marketplace": () => {},
}
let html = {
initLoading:{
enter:[window.loader],
onexit: () => {
loader.style.opacity = 0
setTimeout(() => {
loader.style.opacity = 1
loader.classList.add("hidden")
finishedLoading()
},1000)
}
},
pause: {
enter: [window.message],
exit: [window.savebox, window.saveDirections, window.message]
},
"loadsave menu": {
enter: [window.worlds, window.boxCenterTop, window.uploadWorld, window.quota],
exit: [window.worlds, window.boxCenterTop, window.uploadWorld, window.quota],
onenter: () => {
window.boxCenterTop.placeholder = "Enter Save String (Optional)"
if (navigator && navigator.storage && navigator.storage.estimate) {
navigator.storage.estimate().then(data => {
window.quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
}).catch(console.error)
}
window.boxCenterTop.onmousedown = e => {
let elem = document.getElementsByClassName("selected")
if (elem && elem[0]) {
elem[0].classList.remove("selected")
}
selectedWorld = 0
Button.draw()
}
},
onexit: () => {
window.boxCenterTop.onmousedown = null
}
},
"multiplayer menu": {
enter: [window.servers],
exit: [window.servers],
onenter: initServersMenu
},
"creation menu": {
enter: [window.boxCenterTop],
exit: [window.boxCenterTop],
onenter: () => {
window.boxCenterTop.placeholder = "Enter World Name"
window.boxCenterTop.value = ""
}
},
loading: {
onenter: () => {
startLoad()
constVersion(world.version || version)
},
onexit: () => {
if(multiplayer){
send({
"type":"joined",
username: username
})
}
Messages.add("<span style='color:lime;'>Press / to open chat. "+(cheats ? "Type /? for help with commands." : "")+"</span>")
}
},
netherLoading: {
onenter: startLoad
},
editworld: {
enter: [window.boxCenterTop, window.editworld],
exit: [window.boxCenterTop, window.editworld],
onenter: () => {
var w = worlds[selectedWorld]
window.boxCenterTop.placeholder = "Enter World Name"
window.boxCenterTop.value = w.name
window.url.value = w.thumbnail
}
},
marketplace: {
enter: [window.marketplace],
exit: [window.marketplace]
},
play: {
enter: [window.messageHolder, window.onscreenControl_Element],
exit: [window.messageHolder, window.onscreenControl_Element],
onexit: () => Messages.clear()
},
"options controls":{
enter: [window.controls],
exit: [window.controls, window.controlDetect]
},
"options narrator":{
enter: [window.narratorVoiceSelect],
exit: [window.narratorVoiceSelect]
},
help:{
enter: [window.help],
exit: [window.help]
}
}
let screen = "main menu"
let previousScreen = screen
let beforeOptionsScreen = screen
function changeScene(newScene) {
if (screen === "options") {
saveToDB("settings", settings).catch(e => console.error(e))
}
if (html[screen] && html[screen].exit) {
for (let element of html[screen].exit) {
element.classList.add("hidden")
}
}
if (html[newScene] && html[newScene].enter) {
for (let element of html[newScene].enter) {
element.classList.remove("hidden")
}
}
if (html[newScene] && html[newScene].onenter) {
html[newScene].onenter()
}
if (html[screen] && html[screen].onexit) {
html[screen].onexit()
}
if(newScene === "options" && !screen.startsWith("options ")){
beforeOptionsScreen = screen
}
if(screen === "play"){
for(var i in currentAmbient){
currentAmbient[i].gain.value = 0
}
}
previousScreen = screen
screen = newScene
mouseDown = false
drawScreens[screen]()
Button.draw()
Slider.draw()
if(newScene === "main menu" || newScene === "play" || newScene === "paused" || newScene === "inventory" || newScene === "options"){
themeColor.content = "#fff"
}else{
themeColor.content = "#110"
}
}
win.changeScene = changeScene
win.getScene = () => screen
let hitBox = {}
win.hitBox = hitBox
win.entHitbox = {}
let holding = 0
let crack = {
0: "crack1",
1: "crack2",
2: "crack3",
3: "crack4",
4: "crack5",
5: "crack6",
6: "crack7",
7: "crack8",
8: "crack9",
9: "crack10",
10: "crack10",
length: 10,
idx: 0, // block will break if idx is 4
tex: "crack1",
shape: null,
pos: [0,0,0],
prevPos: [-1,-1,-1],
breakStart: 0,
delayBetween:3/10*1000,
delayStart:0,
entity: null, //define later
soundTimer: 0
}
win.crack = crack
let entityFire
var speakVoices
function speak(what, rate, pitch){
var utterThis = new SpeechSynthesisUtterance(what);
for(var voice of speakVoices){
if(voice.name === settings.narratorVoice) utterThis.voice = voice
}
if(isFinite(pitch)) {
utterThis.pitch = pitch;
}else{
utterThis.pitch = settings.narratorPitch;
}
if(isFinite(rate)) {
utterThis.rate = rate;
}else{
utterThis.rate = settings.narratorRate;
}
win.speechSynthesis.speak(utterThis);
}
win.speak = speak
function speakIt(){if(settings.narrator)speak("hello")}
function populateVoicesList(){// put options in the select
speakVoices = win.speechSynthesis.getVoices();
if(!speakVoices.length) return
var select = narratorVoiceSelect
for(var i=0; i<speakVoices.length; i++){
var voice = speakVoices[i]
var option = document.createElement("option")
option.textContent = voice.name + ' (' + voice.lang + ')'
if(voice.default) {
option.textContent += ' -- DEFAULT';
}
option.setAttribute('data-lang', voice.lang);
option.setAttribute('data-name', voice.name);
select.appendChild(option)
}
if(settings.narratorVoice === null){
settings.narratorVoice = speakVoices[0].name
select.children[0].selected = true
}
narratorVoiceSelect.onchange = () => {
settings.narratorVoice = narratorVoiceSelect.selectedOptions[0].getAttribute("data-name")
speakIt()
}
}
populateVoicesList()
win.speechSynthesis.onvoiceschanged = populateVoicesList;
function selectVoiceFromList(name){
var select = narratorVoiceSelect
for(var option of select.children){
if(option.getAttribute("data-name") === name){
option.selected = true
}
}
}
{
//command system
var copiedBlocks = [];
var prevPos;
function fill(x,y,z,x2,y2,z2, blockID){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
world.setBlock(X,Y,Z,blockID)
}
}
}
}
function copy(x,y,z,x2,y2,z2){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
copiedBlocks = [];
for(var X=x; x2>=X; X++){
var xRow = [];
for(var Y=y; y2>=Y; Y++){
var yRow = []
for(var Z=z; z2>=Z; Z++){
yRow.push(world.getBlock(X,Y,Z));
}
xRow.push(yRow);
}
copiedBlocks.push(xRow);
}
}
function paste(x,y,z){
for(var X = 0; X<copiedBlocks.length; X++){
var xRow = copiedBlocks[X];
for(var Y=0; Y<xRow.length; Y++){
var yRow = xRow[Y];
for(var Z=0; Z<yRow.length; Z++){
var block = yRow[Z];
world.setBlock(X+x,Y+y,Z+z,block)
}
}
}
}
function replaceBlocks(x,y,z,x2,y2,z2, replace, into){
if(x>x2){var px=x; x=x2; x2=px}
if(y>y2){var py=y; y=y2; y2=py}
if(z>z2){var pz=z; z=z2; z2=pz}
for(var X=x; x2>=X; X++){
for(var Y=y; y2>=Y; Y++){
for(var Z=z; z2>=Z; Z++){
if(world.getBlock(X,Y,Z) === replace){
world.setBlock(X,Y,Z,into)
}
}
}
}
}
function fromPlayer(){
prevPos = [p2.x, p2.y, p2.z]
}
function fillToPlayer(id){
//fills at player feet
fill(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, id)
}
function copyToPlayer(){
copy(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z);
}
function pasteAtPlayer(){
paste(p2.x,p2.y-1,p2.z)
}
function hcyl(bottom, height, radius, id) {
let radsq = radius * radius
let innerRadsq = (radius - 1.2) * (radius - 1.2)
height += bottom
for (let x = -radius; x <= radius; x++) {
for (let y = bottom; y < height; y++) {
for (let z = -radius; z <= radius; z++) {
let d = x * x + z * z
if (d < radsq && d >= innerRadsq) {
world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
}
}
}
}
}
function cyl(bottom, height, radius, id) {
let radsq = radius * radius
height += bottom
for (let x = -radius; x <= radius; x++) {
for (let y = bottom; y < height; y++) {
for (let z = -radius; z <= radius; z++) {
let d = x * x + z * z
if (d < radsq) {
world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
}
}
}
}
}
function sphereoid(w, h, d, id, X,Y,Z) {
let w2 = w * w
let h2 = h * h
let d2 = d * d
let w3 = (w - 1.5) * (w - 1.5)
let h3 = (h - 1.5) * (h - 1.5)
let d3 = (d - 1.5) * (d - 1.5)
for (let y = -h; y < h; y++) {
for (let x = -w; x <= w; x++) {
for (let z = -d; z <= d; z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
let n2 = x * x / w3 + y * y / h3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(X + x, Y + y, Z + z, id)
}
}
}
}
}
var cmds = [
{
name: "showAll",
info: "Shows all messages.",
func: () => Messages.showAll(),
noCheats: true
},
{
name: "clear",
info: "Clears shown messages",
func: () => Messages.clear(),
noCheats: true
},
{
name: "fromPlayer",
info: "Sets starting position to player",
func: () => fromPlayer()
},
{
name: "fillToPlayer",
args: ["block_name"],
info: "Fills from starting position to player position",
func: split => {
let id = blockIds[split[1]]
if(!split[1]) id = 0
fillToPlayer(id)
}
},
{
name: "copyToPlayer",
info: "Copys blocks from starting position to player position",
func: () => copyToPlayer()
},
{
name: "pasteAtPlayer",
info: "Pastes copied blocks at the player's position",
func: () => pasteAtPlayer()
},
{
name: "sphereoid",
args: ["width", "height", "depth", "block_name", "x", "y", "z"],
func: split => {
let id = blockIds[split[4]]
if(!split[4]) id = 0
let x = split[5] ? parseInt(split[5]) : p2.x,
y = split[6] ? parseInt(split[6]) : p2.y,
z = split[7] ? parseInt(split[7]) : p2.z
sphereoid(split[1], split[2], split[3], id, x,y,z)
}
},
{
name: "replaceToPlayer",
args: ["replace_what", "with_what"],
func: split => {
let replace = blockIds[split[1]]
if(!split[1]) replace = 0
let into = blockIds[split[2]]
if(!split[2]) into = 0
replaceBlocks(prevPos[0], prevPos[1]-1, prevPos[2], p2.x, p2.y-1, p2.z, replace, into)
}
},
{
name: "give",
args: ["target", "block_name", "amount"],
info: "Gives the target the the specified amount of specified blocks",
func: split => {
let id = blockIds[split[2]]
var amount = split[3] || 1
if(split[1] === "@s"){
if(id){
for(var i=0; i<amount; i++){
newInvItem(id)
}
}
}else if(split[1] === "@a"){
for(var i in players){
var p = players[i]
for(var a=0; a<amount; a++){
world.addEntity(new Item(p.x,p.y,p.z,0,0,0,id))
}
}
}else if(hasPlayer(split[1])){
var p = getPlayerByUsername(split[1])
for(var a=0; a<amount; a++){
world.addEntity(new Item(p.x,p.y,p.z,0,0,0,id))
}
}else{
Messages.add("No such target: "+split[1])
}
}
},
{
name: "kill",
args: ["target","message"],
info: "Kills someone. Target can be: @s, your username, someone's uername, @a, @e",
func: split => {
if(worldSettings.killCmdOff) return Messages.add("Kill command is disabled on this world.")
split[1] = split[1] || "@s"
split[2] = split.splice(2,split.length).join(" ")
if(split[1] === "@s" || split[1] === username){
dieMessage = split[2] || (username+" killed themself with the kill command. Why would you do that???")
die()
}else if(split[1] === "@a" || hasPlayer(split[1])){
send({type:"kill", message:split[2] || username+" killed "+(split[1] === "@a" ? "everyone" : split[1])+" with the kill command.", data:split[1]})
}else if(split[1] === "@e"){
var killed = []
for(var i=world.entities.length-1; i>=0; i--){
killed.push(world.entities[i].type || "Entity")
world.deleteEntity(0,false,i)
}
Messages.add("Killed: "+killed.join(", "))
}else{
Messages.add("No such target: "+split[1])
}
}
},
{
name: "ban",
args: ["username","reason"],
info: "Bans a player. They cannot rejoin the world. Reason is the reason why you banned them. Only bans them until multiplayer turns off",
func: split => {
if(multiplayer && win.ban){
ban(split[1], split.slice(2).join(" "))
}else{
Messages.add("Error: can't ban.")
}
},
noCheats:true
},
{
name: "unban",
args: ["username"],
info: "Unbans a player.",
func: split => {
if(win.unban){
unban(split[1])
}else{
Messages.add("Error: can't ban.")
}
},
noCheats:true
},
{
name: "time",
args: ["mode","n"],
info: "mode can be: set, add, subtract. n is the time to set to. 1000 is a day. n an also be: day, night",
func: split => {
var time
if(split[2] === "day") time = -20
else if(split[2] === "night") time = 480
else time = parseInt(split[2]) || 0
time = time * Math.PId / 1000
if(split[1] === "set"){
worldTime = time
}else if(split[1] === "add"){
worldTime += time
}else if(split[1] === "subtract"){
worldTime -= time
}else{
Messages.add("No such mode: "+split[1])
}
}
},
{
name:"gamemode",
args: ["mode"],
info: "mode can be: creative, survival, spectator",
func: split => {
let m = split[1]
p.spectator = false
if(m === "creative") survival = false
else if(m === "survival") survival = true
else if(m === "spectator") p.spectator = p.flying = true
else Messages.add("Game mode doesn't exsist: "+m)
}
},
{
name:"tp",
args: ["to_who"],
info: "Teleport to someone. \"to_who\" should be a username.",
func: split => {
if(hasPlayer(split[1])){
var player = getPlayerByUsername(split[1])
p.x = player.x
p.y = player.y
p.z = player.z
}else{
Messages.add("Player doesn't exsist: "+split[1])
}
}
},
{
name:"online",
args:[],
noCheats: true,
info: "Lists people that are playing on this world.",
func: split => {
if(!multiplayer){
return Messages.add("You are not in a multiplayer world.")
}
send({type:"fetchUsers"})
}
},
{
name:"playSound",
args:["sound", "volume", "pitch"],
info:"Plays a sound. Sound can be any sound, for example: click, block.grass.dig1, entity.generic.explode1. Volume is a number from 0 to 1.",
func: split => {
if(!split[1]) return Messages.add("The first argument (sound) is required.")
var volume = parseFloat(split[2])
var pitch = parseFloat(split[3])
if(playSound(split[1], 0, volume, pitch)){
if(multiplayer) send({type:"playSound", data:split[1], volume:volume, pitch:pitch})
}else{
Messages.add("That sound doesn't exsist.")
}
}
},
{
name:"sendEval",
args:["target","data"],
info:"Send javascript to players. Only works for certain people and if your'e the host. Target can be: username, @a, @A. If target isn't specified, it sends it to all players except you. If target is @A, it send to everyone including you.",
func: split => {
if(!multiplayer) return
split.splice(0,1)
var to = split.splice(0,1)[0]
if(to === "@a") to = ""
send({type:"eval",data:split.join(" ")}, to || undefined)
}
},
]
win.cmds = cmds
var cmdList = document.getElementById("cmdList")
cmds.forEach(cmd => {
//Now you really need cheats to get commands!
Object.defineProperty(cmd, 'noCheats', {
value: cmd.noCheats || false,
writable: false
})
var option = document.createElement("option")
option.value = cmd.name
cmdList.appendChild(option)
})
function getCmd(name){
for(var i=0; i<cmds.length; i++){
if(cmds[i].name === name){
return cmds[i]
}
}
}
function runCmd(str){
str = str.replace("/", '')
let split = str.split(" ")
let name = split[0]
if(name === "?"){
if(split[1]){
var cmd = getCmd(split[1])
if(cmd){
var str = "<b>/"+split[1]+"</b><br>"
str += "Syntax: /"+cmd.name+" "
if(cmd.args) str += cmd.args.join(" ")
str += "<br>"
if(cmd.info) str += "Description: "+cmd.info
Messages.add(str)
}else Messages.add("There is no information for /"+split[1])
}else{
if(cheats){
var str = "List of commands:<br>"
str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
cmds.forEach(r => {
str += "<span style='color:lightblue;'>/"+r.name+"</span> "
if(r.args) str += r.args.join(" ")
str += "<br>"
})
Messages.add(str)
}else{
var str = "List of available commands:<br>"
str += "Use <span style='color:lime;'>/? command_name</span> to get information about a command<br>"
cmds.forEach(r => {
if(!r.noCheats) return
str += "<span style='color:lightblue;'>/"+r.name+"</span> "
if(r.args) str += r.args.join(" ")
str += "<br>"
})
Messages.add(str)
}
}
}else{
var cmd = getCmd(name)
if(cmd){
if(!cheats && !cmd.noCheats){
Messages.add("§cThat command requires cheats")
return
}
cmd.func(split)
}else Messages.add("§cError: no such command called §f"+name)
}
}
win.runCmd = runCmd
}
let Messages = {
span: document.createElement("span"),
array: [],
all: [],
remove: (function(){
var arr = ["fuck","stupid"]
arr.forEach((value, i) => {
arr[i] = new RegExp("("+value+")", "gi")
})
return arr
})(),
setContent:function(arr){
if(arr.length === 0){
messages.innerHTML = ""
}else messages.innerHTML = arr.join("<br>")
messages.scrollTop = messages.scrollHeight;
},
update:function(){
this.setContent(this.array)
},
showAll: function(){
this.setContent(this.all)
},
clear: function(){this.array = [];this.update()},
add: function(msg){
msg = this.format(msg)
this.array.push(msg)
this.all.push(msg)
if(this.array.length > 8){
this.array.shift()
}
if(settings.narrator){
this.span.innerHTML = msg
speak(this.span.innerText)
}
this.update()
},
write: function(msg, from){
if(!from){
if(!msg) return
for(var regex of this.remove){ //remove bad words
msg = msg.replace(regex, "<span style='color:black; background:black;'>$1</span>")
}
}
this.add("<"+(from || username)+"> "+msg)
if(!from && multiplayer){
send({type:"message", data:msg, username:username})
}
},
showInput(){
messageInput.classList.remove("hidden")
messageInput.focus()
messageInput.onkeypress = (e) => {
if(e.key !== "Enter") return
if(messageInput.value[0] === "/"){
Messages.add(messageInput.value)
runCmd(messageInput.value)
}else{
Messages.write(messageInput.value)
}
messageInput.classList.add("hidden")
messageInput.value = ""
canvas.focus()
}
},
format(str){
if(str.includes("§")){
var arr = str.split("§")
var res = arr[0]
var spans = 0
for(var i=1; i<arr.length; i++){
var s = arr[i]
var col = colors[s.substring(0,1)]
s = s.substring(1)
res += "<span style='color:"+col+";'>"+s
spans ++
}
for(i=0; i<spans;i++) res += "</span>"
return res
}else return str
}
}
window.Messages = Messages
let title = ""
let subtitle = ""
let titleOpacity = 0
let titleColor = "black"
function showTitle(aTitle, aSubtitle, color){
title = aTitle
subtitle = aSubtitle
titleOpacity = 140
titleColor = color || "white"
}
win.showTitle = showTitle
let sideMessageTime = 0,
sideMessageTitle, sideMessageContent
function sideMessage(title, content){
sideMessageTime = 600
sideMessageTitle = title
sideMessageContent = content
}
win.sideMessage = sideMessage
function die(){
calculateTotalXP()
if(survival){
for(var i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i].id){
for(var j=0; j<inventory.hotbar[i].amount; j++)world.addEntity(new Item(p.x,p.y,p.z,0,0,0,inventory.hotbar[i].id,true, 1,inventory.hotbar[i].durability))
inventory.hotbar[i] = 0
}
}
for(var i=0; i<invLength; i++){
if(invItems[i] && invItems[i].id){
for(var j=0; j<invItems[i].amount; j++)world.addEntity(new Item(p.x,p.y,p.z,0,0,0,invItems[i].id, true, 1,invItems[i].durability))
invItems[i].id = 0
}
}
if(p.totalXP > 0) world.addEntity(new ExperienceOrb(p.x,p.y,p.z,p.totalXP))
}
changeScene("dead")
releasePointer()
p3.y = 0
if(multiplayer) send({type:"die", id:achexUsername, message:dieMessage})
}
function damage(amount, why, nosound,type){
p.health -= amount
harmEffect = 40
if(!nosound){
if(p.health <= 0){
oofSound()
}else{
switch(type){
case "drown":
drownHurtSound()
break
case "freeze":
freezeHurtSound()
break
case "smallfall":
playSound("damage.smallfall")
break
case "bigfall":
playSound("damage.bigfall")
break
default:
hitSound()
break
}
}
}
loseHealthEffect = 60
dieMessage = why
updateHUD = true
if(multiplayer) send({type:"harmEffect", id:achexUsername})
}
win.damage = damage
function XP(amount){
p.lastXP = performance.now()
p.XP += amount
if(p.XP >= p.nextLevel){
p.level += Math.floor(p.XP / p.nextLevel)
p.XP = p.XP % p.nextLevel
playSound("experience.levelup")
setLevel()
}else{
playSound("experience.orb")
}
updateHUD = true
}
function setLevel(){
if(p.level <= 15){
p.nextLevel = 2*p.level+7
}else if(p.level <= 30){
p.nextLevel = 5*p.level-38
}else{
p.nextLevel = 9*p.level-158
}
}
function calculateTotalXP(){
if(p.level <= 16){
p.totalXP = (p.level * p.level) + 6 * p.level
}else if(p.level <= 31){
p.totalXP = 2.5 * (p.level * p.level) - 40.5 * p.level + 360
}else if(p.level > 31){
p.totalXP = 4.5 * (p.level * p.level) - 162.5 * p.level + 2220
}else p.totalXP = -1 //it didn't match any (that's probably impossible)
if(p.totalXP !== -1){
p.totalXP += p.XP
}
}
let Key = {}
let modelView = win.modelView || new Float32Array(16)
win.modelView = modelView
let glCache
let worlds, selectedWorld = 0
let freezeFrame = 0
let p
let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector(), vec4 = new PVector()
let move = {
x: 0,
y: 0,
z: 0,
ang: Math.sqrt(0.5),
}
let p2 = {
x: 0,
y: 0,
z: 0,
}
let p3 = { //precise positions for multiplayer
x: 0,
y: 0,
z: 0,
survival: false,
username: ""
}
let controlMap = {}
function setControl(name, key, Name, shift = false, ctrl = false, alt = false){
if(controlMap[name]){
var c = controlMap[name]
c.key = key
c.shift = shift
c.ctrl = ctrl
c.alt = alt
}else{
controlMap[name] = {
key,
default:key,
name,
Name,
shift,
ctrl,
alt,
get pressed() {
return Boolean(Key[this.key]
&& (!this.shift || Key.ShiftLeft || Key.ShiftRight)
&& (!this.ctrl || Key.ControlLeft || Key.ControlRight)
&& (!this.alt || Key.AltLeft || Key.AltRight))
},
// Check to see if all of an event's data matches this key map
event(e) {
return Boolean(e.key === this.key
&& (!this.shift || e.shiftKey)
&& (!this.ctrl || e.ctrlKey)
&& (!this.alt || e.altKey))
}
}
}
settings.controls[name] = key
}
win.setControl = setControl
setControl("jump", " ", "Jump / Fly up")
setControl("forward", "w", "Walk forward")
setControl("left", "a", "Strafe keft")
setControl("backward", "s", "Walk backwards")
setControl("right", "d", "Strafe right")
setControl("sprint", "q", "Sprint")
setControl("inventory", "e", "Open inventory")
setControl("chat", "/", "Open chat")
setControl("pause", "p", "Pause")
setControl("hyperBuilder", "h", "Toggle Hyper Builder")
setControl("superBreaker", "b", "Toggle Super Breaker")
setControl("spectator", "l", "Toggle spectator mode")
setControl("zoom", "z", "Zoom in")
setControl("cycleBlockShapes", "enter", "Cycle block shapes")
setControl("sneak", "shift", "Sneak / Fly down")
setControl("dropItem", "backspace", "Drop item")
setControl("break", "leftMouse", "Attack / Destroy")
setControl("place", "rightMouse", "Use item / Place block")
setControl("pick", "middleMouse", "Pick block")
setControl("thirdPerson", "o", "Toggle third person mode")
function resetControls(){
for(var i in controlMap){
var c = controlMap[i]
setControl(c.name, c.default)
}
updateControls()
}
resetControls()
var controlsAreDefault
function updateControls(){
var el = window.controls
while (el.firstChild) {
el.removeChild(el.firstChild)
}
var table = document.createElement("table")
controlsAreDefault = true
for(var i in controlMap){
var c = controlMap[i]
var row = document.createElement("tr")
row.id = "control:"+i
row.classList.add("control")
var td = document.createElement("td")
td.innerHTML = c.Name
row.appendChild(td)
var td = document.createElement("td")
td.innerHTML = "<button title='Click to change key' onclick='changeKey(\""+i+"\")'>"+c.key+"</button>"
row.appendChild(td)
var td = document.createElement("td")
td.innerHTML = "<button onclick='resetKey(\""+i+"\")' "+(c.key === c.default ? "disabled" : "")+">Reset</button>"
row.appendChild(td)
table.appendChild(row)
if(c.key !== c.default) controlsAreDefault = false
}
el.appendChild(table)
}
win.changeKey = function(c){
c = controlMap[c]
function detected(key){
setControl(c.name, key)
controlDetect.classList.add("hidden")
controlDetect.onmouseup = null
controlDetect.onkeyup = null
updateControls()
controlDetect.blur()
}
controlDetect.classList.remove("hidden")
controlDetect.focus()
controlDetect.onmouseup = function(e){
switch(e.button) {
case 0:
detected("leftMouse")
break
case 1:
detected("middleMouse")
break
case 2:
detected("rightMouse")
break
}
}
controlDetect.onkeyup = function(e){
detected(e.key.toLowerCase())
}
}
win.resetKey = function(key){
var c = controlMap[key]
setControl(c.name, c.default)
updateControls()
}
function loadControls(){
var c = settings.controls
for(var i in c){
setControl(i, c[i])
}
updateControls()
}
let place
let liquid = false
let powder = false
let inWater = 0 //head is in liquid
let wet = false
let tick = false
let standingOn = 0 //block id you are standing on
let lastTick = 0
let lastLiquid = false
let attackCooldown = 0, attackCooldownStart = 0, attackCooldownTime = 0 //for swords
let harmEffect = 0
//let healTime = 5000 // miliseconds between each heal
let healEffect = 0 // health bar outline flash white
let lastHeal = 0
let lastBlockHarm = 0
let lastLoseOxygen = 0
let lastGetOxygen = 0
let witherEffect = 0
let witherDamage = 0
let witherTime = 0
let freezeEffect = 0
let lastFreezeHealth = 0
let loseHealthEffect = 0
let portalEffect = 0
let portalTriggerSound = null
let portalTriggerSoundGain = null
let touchingPortal = false
function portalTriggerSoundStart(source, gainNode){
portalTriggerSound = source
portalTriggerSoundGain = gainNode
}
win.lastStepSound = 0
let eatSoundTimer = 0
let inventory = {
hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
main: [],
hotbarSlot: 0,
showName:0,
size: 40 * min(width, height) / 600,
ts:(40 * min(width, height) / 600) / 16,
holding: 0,
space: invItems,
crafting: [0,0,0,0,0,0,0,0,0],
craftingStr: "",
craftingRes: 0, //block id
spreaded: [],
spreadPlace: "", //inventory, crafting, etc
spreadStart: -1,
spreading: false,
furnaceData: {
x:0,y:0,z:0,
data:null
},
chestData:{
x:0,y:0,z:0,
data:null
},
}
inventory.craftingStr = inventory.crafting.join(",")
let furnaceData = inventory.furnaceData
let chestData = inventory.chestData
win.inventory = inventory
//}
for(var i=0; i<9; i++){
inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
}
for(var i=0; i<9; i++){
inventory.crafting[i] = {id:inventory.crafting[i],amount:64}
}
function setHotbar(arr){
inventory.hotbar = arr
for(var i=0; i<9; i++){
inventory.hotbar[i] = {id:inventory.hotbar[i],amount:64}
}
}
function play() {
canvas.onblur()
p.lastBreak = Date.now()
updateHUD = true
use3d()
gl.clearColor(sky[0], sky[1], sky[2], 1.0)
getPointer()
fill(255, 255, 255)
textSize(10)
changeScene("play")
}
let gl
let glExtensions
function getPointer() {
if(touchScreen) return
if (canvas.requestPointerLock) {
try{
canvas.requestPointerLock()
}catch(e){
console.error(e)
}
}
}
function releasePointer() {
if (doc.exitPointerLock) {
doc.exitPointerLock()
}
}
let Block = {
top: 0x4,
bottom: 0x8,
north: 0x20,
south: 0x10,
east: 0x2,
west: 0x1,
}
let Sides = {
top: 0,
bottom: 1,
north: 2,
south: 3,
east: 4,
west: 5,
}
// GLSL Shader code (written in script tags at the top of the file)
let vertexShaderSrc3D
let fragmentShaderSrc3D
let vertexShaderSrc2D
let fragmentShaderSrc2D
let vertexShaderSrcPanorama
let fragmentShaderSrcPanorama
let skyboxVertex
let skyboxFragment
let vertexShaderSrcEntity
let fragmentShaderSrcEntity
let vertexShaderSrcParticle
let fragmentShaderSrcParticle
function updateGLSL(){
vertexShaderSrc3D = document.getElementById("blockVertexShader").text
fragmentShaderSrc3D = document.getElementById("blockFragmentShader").text
vertexShaderSrc2D = document.getElementById("2dVertexShader").text
fragmentShaderSrc2D = document.getElementById("2dFragmentShader").text
skyboxVertex = document.getElementById("skyboxVertexShader").text
skyboxFragment = document.getElementById("skyboxFragmentShader").text
vertexShaderSrcEntity = document.getElementById("entityVertexShader").text
fragmentShaderSrcEntity = document.getElementById("entityFragmentShader").text
vertexShaderSrcParticle = document.getElementById("particleVertexShader").text
fragmentShaderSrcParticle = document.getElementById("particleFragmentShader").text
}
updateGLSL()
win.updateGLSL = updateGLSL
function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
curContext.shaderSource(vertexShaderObject, vetexShaderSource)
curContext.compileShader(vertexShaderObject)
if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
throw curContext.getShaderInfoLog(vertexShaderObject)
}
let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
curContext.compileShader(fragmentShaderObject)
if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
throw curContext.getShaderInfoLog(fragmentShaderObject)
}
let programObject = curContext.createProgram()
curContext.attachShader(programObject, vertexShaderObject)
curContext.attachShader(programObject, fragmentShaderObject)
curContext.linkProgram(programObject)
if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
throw "Error linking shaders."
}
return programObject
}
let program3D, program2D, skyboxProgram, programEntity, programParticle
function objectify(x, y, z, width, height, textureX, textureY, texXFlip,texYFlip,rotateTex,texW,texH) {
return {
x: x,
y: y,
z: z,
w: width,
h: height,
tx: textureX,
ty: textureY,
txf: texXFlip,
rt:rotateTex,
tw:texW || width,
th:texH || height
}
}
function customFace(x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th){
tw = tw || 16
th = th || 16
return {
x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th,
custom:true
}
}
function generateItemShape(){
var arr = []
var bottom = [],
top = [],
east = [],
west = []
var i
for(i=0; i<16; i++){
bottom.push(objectify(0,i,7.5,16,1,0,(16-i)-1))
top.push(objectify(0,i+1,8.5,16,1,0,16-i-1))
east.push(objectify(i+1,16,7.5,1,16,(16-i)-1,0))
west.push(objectify(i,16,8.5,1,16,(16-i)-1,0))
}
return [bottom,top,
[objectify(16, 16, 8.5, 16, 16, 0, 0, true)],[objectify( 0, 16,  7.5, 16, 16, 0, 0)],
east,west]
}
function layerShape(h){
return [
[objectify(0,0,0,16,16,0,0)],
[objectify(0,h,16,16,16,0,0)],
[objectify(16, h, 16, 16, h, 0, 16-h)],
[objectify( 0, h,  0, 16, h, 0, 16-h)],
[objectify(16, h,  0, 16, h, 0, 16-h)],
[objectify( 0, h, 16, 16, h, 0, 16-h)]
]
}
let shapes = {
/*
[
[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
]
*/
cube: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
rotate: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
_1PixLower:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 15, 16, 16, 16, 0, 0)], //top
[objectify(16, 15, 16, 16, 15, 0, 1)], //north
[objectify( 0, 15,  0, 16, 15, 0, 1)], //south
[objectify(16, 15,  0, 16, 15, 0, 1)], //east
[objectify( 0, 15, 16, 16, 15, 0, 1)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
slab: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
[objectify(16, 8, 16, 16, 8, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
[objectify(16, 8,  0, 16, 8, 0, 0)], //east
[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 1,
south: 1,
east: 1,
west: 1
},
texVerts: [],
buffer: null,
size: 6,
varients: [],
flip: true,
rotate: false
},
stair: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 3,
south: 0,
east: 0,
west: 0
},
texVerts: [],
buffer: null,
size: 10,
varients: [],
flip: true,
rotate: true
},
cross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
hitbox: "cube"
},
sideCross: {
verts: [
[], //bottom
[], //top
[customFace(2,2,16, 14,14,16, 14,14,0, 2,2,0, 0,16,16,-16)], //north
[customFace(14,2,16, 2,14,16, 2,14,0, 14,2,0, 0,16,16,-16)], //south
[customFace(14,14,16, 2,2,16, 2,2,0, 14,14,0, 0,16,16,-16)], //east
[customFace(2,14,16, 14,2,16, 14,2,0, 2,14,0, 0,16,16,-16)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
hitbox: "cube",
rotate: true,
hitbox: "cube"
},
bottomCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 0,16,16,-16)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 0,16,16,-16)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 0,16,16,-16)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 0,16,16,-16)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
hitbox: "cube"
},
tallCross: {
verts: [
[], //bottom
[], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, 16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, 16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, 16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, 16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
door: {
verts: [
[objectify( 0,  0,  0, 16, 3, 0, 0, false,false,false,null,2)], //bottom
[objectify( 0, 16, 3, 16, 3, 0, 0),objectify( 0, 32, 3, 16, 3, -16, 0, false,false,false,null,2)], //top
[objectify(16, 16, 3, 16, 16, 0, 0),objectify(16, 32, 3, 16, 16, -16, 0)], //north
[objectify(0, 32, 0, 16, 16, -16,0, true),objectify(0, 16, 0, 16, 16, 0,0, true)], //south
[objectify(16, 16,  0, 3, 16, 0, 0, false,false,false,2),objectify(16, 32,  0, 3, 16, -16, 0, false,false,false,2)], //east
[objectify( 0, 16, 3, 3, 16, 0, 0, false,false,false,2),objectify( 0, 32, 3, 3, 16, -16, 0, false,false,false,2)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate: true
},
torch: {
verts: [
[objectify( 7,  0,  7, 2, 2, 7, 14)], //bottom
[objectify( 7, 10, 9, 2, 2, 7, 6)], //top
[objectify(9, 10, 9, 2, 10, 7, 6)], //north
[objectify( 7, 10,  7, 2, 10, 7, 6)], //south
[objectify(9, 10,  7, 2, 10, 7, 6)], //east
[objectify( 7, 10, 9, 2, 10, 7, 6)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
wallTorch: {
verts: [
[customFace(9,4,17, 7,4,17, 7,3,15, 9,3,15, 7,14,2,2)],
[customFace(9,13,11, 7,13,11, 7,14,13, 9,14,13, 7,6,2,2)],
[customFace(9,14,13, 7,14,13, 7,4,17, 9,4,17, 7,6,2,10)], //north
[customFace(7,13,11, 9,13,11, 9,3,15, 7,3,15, 7,6,2,10)], //south
[customFace(9,13,11, 9,14,13, 9,4,17, 9,3,15, 7,6,2,10)], //east
[customFace(7,14,13, 7,13,11, 7,3,15, 7,4,17, 7,6,2,10)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
lantern: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
lanternHang: {
verts: [
[objectify(5,  0, 5, 6, 6, 0, 9)], //bottom
[objectify(6, 9, 10, 4, 4, 1, 10),objectify(5, 7, 11, 6, 6, 0, 9)], //top
[objectify(10, 9, 10, 4, 2, 1, 0),objectify(11, 7, 11, 6, 7, 0, 2),objectify(9.5, 11, 8, 3, 2, 11, 10),objectify(9.5, 16, 8, 3, 3, 11, 2)], //north
[objectify(6, 9, 6, 4, 2, 1, 0),objectify(5, 7, 5, 6, 7, 0, 2),objectify(6.5, 11, 8, 3, 2, 11, 10),objectify(6.5, 16, 8, 3, 3, 11, 2)], //south
[objectify(10, 9, 6, 4, 2, 1, 0),objectify(11, 7, 5, 6, 7, 0, 2),objectify(8, 14, 6.5, 3, 4, 11, 1)], //east
[objectify(6, 9, 10, 4, 2, 1, 0),objectify(5, 7, 11, 6, 7, 0, 2),objectify(8, 14, 9.5, 3, 4, 11, 1)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
beacon: {
verts: [
[objectify( 0, 0,  0, 16, 16, 16, -96),objectify( 2, 0.001, 2, 12, 12, -32, 0)], //bottom
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify( 2, 3, 14, 12, 12, -16, 3)], //top
[objectify(13, 13, 13, 10, 10, 3, 3),objectify( 16, 16,  16, 16, 16, -32, 0),objectify(14, 3, 14, 12, 3,  -16, 3)], //north
[objectify( 3, 13,  3, 10, 10, 3, 3),objectify( 0,  16,  0,  16, 16, -32, 0),objectify(2,  3, 2,  12, 3,  -16, 3)], //south
[objectify(13, 13,  3, 10, 10, 3, 3),objectify( 16, 16,  0,  16, 16, -32, 0),objectify(14, 3, 2,  12, 3,  -16, 3)], //east
[objectify( 3, 13, 13, 10, 10, 3, 3),objectify( 0,  16,  16, 16, 16, -32, 0),objectify(2,  3, 14, 12, 3,  -16, 3)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
cactus: {
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 15, 16, 16, 0, 0)], //north
[objectify( 0, 16,  1, 16, 16, 0, 0)], //south
[objectify(15, 16,  0, 16, 16, 0, 0)], //east
[objectify( 1, 16, 16, 16, 16, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
hitbox: "cube"
},
pane: {
verts: [
[objectify( 0,  0,  7, 16, 2, 0, 7)], //bottom
[objectify( 0, 16, 9, 16, 2, 0, 7)], //top
[objectify(16, 16, 9, 16, 16, 0, 0)], //north
[objectify( 0, 16,  7, 16, 16, 0, 0)], //south
[objectify(16, 16, 7, 2, 16, 7, 0)], //east
[objectify(0, 16, 9, 2, 16, 7, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
portal: {
verts: [
[objectify(0, 0, 7, 16, 2, 0, 0)],
[objectify(0, 16, 9, 16, 2, 0, 0)],
[objectify(16, 16, 9, 16, 16, 0, 0)],
[objectify(0, 16, 7, 16, 16, 0, 0)],
[objectify(16, 16, 7, 2, 16, 0, 0)],
[objectify(0, 16, 9, 2, 16, 0, 0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
trapdoor: {
verts: [
[objectify(0, 0, 0, 16, 16, 0, 0)], //bottom
[objectify(0, 3, 16, 16, 16, 0, 0)], //top
[objectify(16, 3, 16, 16, 3, 0, 0)], //north
[objectify(0, 3, 0, 16, 3, 0, 0)], //south
[objectify(16, 3, 0, 16, 3, 0, 0)], //east
[objectify(0, 3, 16, 16, 3, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true,
flip: true
},
trapdoorOpen: {
verts: [
[objectify(0, 0, 13, 16, 3, 0, 0)], //bottom
[objectify(0, 16, 16, 16, 3, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16, 13, 16, 16, 0, 0)], //south
[objectify(16, 16, 13, 3, 16, 0, 0)], //east
[objectify(0, 16, 16, 3, 16, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
wallFlat: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(0, 0, 0, 0, 0, 0, 0)], //bottom
[objectify(0, 16, 16, 0, 0, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify(0, 16,  15, 16, 16, 0, 0)], //south
[objectify(0, 0,  0, 0, 0, 0, 0)], //east
[objectify(0, 0, 16, 0, 0, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
fence: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1)], //top
[objectify(10, 16, 10, 4, 16, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
wallpost: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4)], //top
[objectify(12, 16, 12, 8, 16, 4, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
wall: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 16, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 16, 16, 6, 16, 5, 0)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 16, 12, 4, 16, 12, 0)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 16, 16, 4, 16, 12, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
wallu: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify(4, 0, 4, 8, 8, 4, 4),objectify(5, 0, 12, 6, 4, 5, 10)], //bottom
[objectify(4, 16, 12, 8, 8, 4, 4),objectify(5, 13, 16, 6, 4, 5, 10)], //top
[objectify(12, 16, 12, 8, 16, 4, 0),objectify(11, 13, 16, 6, 13, 5, 3)], //north
[objectify(4, 16, 4, 8, 16, 4, 0)], //south
[objectify(12, 16, 4, 8, 16, 4, 0),objectify(11, 13, 12, 4, 13, 12, 3)], //east
[objectify(4, 16, 12, 8, 16, 4, 0),objectify(5, 13, 16, 4, 13, 12, 3)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
rotate: true
},
fencq: {
verts: [
[objectify(6, 0, 6, 4, 4, 0, 1),objectify(10, 12, 7, 6, 2, 0, 2),objectify(10, 6, 7, 6, 2, 0, 2)], //bottom
[objectify(6, 16, 10, 4, 4, 0, 1),objectify(10, 15, 9, 6, 2, 0, 2),objectify(10, 9, 9, 6, 2, 0, 2)], //top
[objectify(10, 16, 10, 4, 16, 6, 0),objectify(16, 15, 9, 6, 3, 6, 0),objectify(16, 9, 9, 6, 3, 6, 0)], //north
[objectify(6, 16, 6, 4, 16, 6, 0),objectify(10, 15, 7, 6, 3, 6, 0),objectify(10, 9, 7, 6, 3, 6, 0)], //south
[objectify(10, 16, 6, 4, 16, 6, 0)], //east
[objectify(6, 16, 10, 4, 16, 6, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate: true
},
fench: {
verts:[
[objectify(6,0,6,4,4,0,1),objectify(10,12,7,6,2,0,2),objectify(10,6,7,6,2,0,2),objectify(0,12,7,6,2,0,0),objectify(0,6,7,6,2,0,0)],
[objectify(6,16,10,4,4,0,1),objectify(10,15,9,6,2,0,2),objectify(10,9,9,6,2,0,2),objectify(0,15,9,6,2,0,0),objectify(0,9,9,6,2,0,0)],
[objectify(10,16,10,4,16,6,0),objectify(16,15,9,6,3,6,0),objectify(16,9,9,6,3,6,0),objectify(6,15,9,6,3,0,0),objectify(6,9,9,6,3,0,0)],
[objectify(6,16,6,4,16,6,0),objectify(10,15,7,6,3,6,0),objectify(10,9,7,6,3,6,0),objectify(0,15,7,6,3,0,0),objectify(0,9,7,6,3,0,0)],
[objectify(10,16,6,4,16,6,0)],
[objectify(6,16,10,4,16,6,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate: true
},
button: {
verts: [
[objectify(5, 6, 14, 6, 2, 5, 6)], //bottom
[objectify(5, 10, 16, 6, 2, 5, 6)], //top
[objectify(11, 10, 16, 6, 4, 5, 6)], //north
[objectify(5, 10, 14, 6, 4, 5, 6)], //south
[objectify(11, 10, 14, 2, 4, 5, 6)], //east
[objectify(5, 10, 16, 2, 4, 5, 6)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
buffer: null,
size: 6,
varients: [],
flip: true,
rotate: true
},
chain: {
verts: [
[objectify(8, 0, 8, 0.5, 0.5, 0, 0)], //bottom
[objectify(8, 16, 8, 0.5, 0.5, 0, 0)], //top
[objectify(9.5, 16, 8, 3, 16, 3, 0)], //north
[objectify(6.5, 16, 8, 3, 16, 3, 0)], //south
[objectify(8, 16, 6.5, 3, 16, 0, 0)], //east
[objectify(8, 16, 9.5, 3, 16, 0, 0)] //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
pot: {
verts: [
[objectify(5, 0, 5, 6, 6, 5, 10)], //bottom
[objectify(5, 6, 11, 6, 6, 5, 5), objectify(6, 4, 10, 4, 4, -16, 0)], //top
[objectify(11, 6, 11, 6, 6, 5, 10), objectify(11, 6, 6, 6, 6, 5, 10)], //north
[objectify(5, 6, 5, 6, 6, 5, 10), objectify(5, 6, 10, 6, 6, 5, 10)], //south
[objectify(11, 6, 5, 6, 6, 5, 10), objectify(6, 6, 5, 6, 6, 5, 10)], //east
[objectify(5, 6, 11, 6, 6, 5, 10), objectify(10, 6, 11, 6, 6, 5, 10)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6,
},
potCross: {
verts: [
[], //bottom
[], //top
[customFace(2,4,2, 14,4,14, 14,-12,14, 2,-12,2, 0,0)], //north
[customFace(14,4,2, 2,4,14, 2,-12,14, 14,-12,2, 0,0)], //south
[customFace(14,4,14, 2,4,2, 2,-12,2, 14,-12,14, 0,0)], //east
[customFace(2,4,14, 14,4,2, 14,-12,2, 2,-12,14, 0,0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
carpet: {
verts: [
[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 1, 16, 16, 16, 0, 0)], //top
[objectify(16, 1, 16, 16, 1, 0, 0)], //north
[objectify( 0, 1,  0, 16, 1, 0, 0)], //south
[objectify(16, 1,  0, 16, 1, 0, 0)], //east
[objectify( 0, 1, 16, 16, 1, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 1,
south: 1,
east: 1,
west: 1
},
texVerts: [],
buffer: null,
size: 6,
varients: []
},
bed: {
verts: [
[objectify( 0, 3,  0, 16, 16, -16, 0),objectify( 0, 3,  16, 16, 16, -16, 0),
objectify(0, 0, 0, 3,3,  38,0),
objectify(13, 0, 29, 3,3,38,0),
objectify(0, 0, 29, 3,3, 38,0),
objectify(13, 0, 0, 3,3, 38,0)], //bottom
[objectify( 0, 9, 32, 16, 16, 16, 0),objectify( 0, 9, 16, 16, 16, 0, 0)], //top
[objectify(16, 9, 32, 16, 6, 80, 6),
objectify(3, 3, 3, 3,3,  38,3),
objectify(16, 3, 32, 3,3,32,3),
objectify(3, 3, 32, 3,3, 35,3),
objectify(16, 3, 3, 3,3, 41,3)], //north
[objectify( 0, 9,  0, 16, 6, 80, 0),
objectify(0, 3, 0, 3,3,  32,3),
objectify(13, 3, 29, 3,3,38,3),
objectify(0, 3, 29, 3,3, 41,3),
objectify(13, 3, 0, 3,3, 35,3)], //south
[objectify( 16, 9,  0, 16, 6, 48, 0),objectify( 16, 9,  16, 16, 6, 64, 0),
objectify(3, 3, 0, 3,3,  41,3),
objectify(16, 3, 29, 3,3,35,3),
objectify(3, 3, 29, 3,3, 38,3),
objectify(16, 3, 0, 3,3, 32,3)], //east
[objectify( 0, 9, 32, 16, 6, 64, 6),objectify( 0, 9, 16, 16, 6, 48, 6),
objectify(0, 3, 3, 3,3,  35,3),
objectify(13, 3, 32, 3,3,41,3),
objectify(0, 3, 32, 3,3, 32,3),
objectify(13, 3, 3, 3,3, 38,3)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
buffer: null,
size: 6,
varients: [],
rotate: true
},
cactusPot: {
verts: [
[], //bottom
[objectify( 6, 1, 10, 4,  4, 6, 6)], //top
[objectify(10, 1, 10, 4, 11, 6, 0)], //north
[objectify( 6, 1,  6, 4, 11, 6, 0)], //south
[objectify(10, 1,  6, 4, 11, 6, 0)], //east
[objectify( 6, 1, 10, 4, 11, 6, 0)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
crop: {
verts: [
[objectify(0,0,0,0,0,0,0)],
[objectify(0,0,0,0,0,0,0)],
[objectify(16,16,4,16,16,0,0),objectify(16,16,12,16,16,0,0)],
[objectify(0,16,12,16,16,0,0),objectify(0,16,4,16,16,0,0)],
[objectify(4,16,0,16,16,0,0),objectify(12,16,0,16,16,0,0)],
[objectify(12,16,16,16,16,0,0),objectify(4,16,16,16,16,0,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
varients: []
},
anvil: {
verts: [
[objectify(2,0,2,12,12,0,0),objectify(0,10,3,16,10,0,0)],
[objectify(2,4,14,12,12,0,0),objectify(3,5,12,10,8,0,0),objectify(0,16,13,16,10,-16,3)],
[objectify(14,4,14,12,4,0,0),objectify(16,16,13,16,6,0,0),objectify(13,5,12,10,1,0,0),objectify(12,10,11,8,5,0,0)],
[objectify(2,4,2,12,4,0,0),objectify(0,16,3,16,6,0,0),objectify(3,5,4,10,1,0,0),objectify(4,10,5,8,5,0,0)],
[objectify(14,4,2,12,4,0,0),objectify(16,16,3,10,6,0,0),objectify(13,5,4,8,1,0,0),objectify(12,10,5,6,5,0,0)],
[objectify(2,4,14,12,4,0,0),objectify(0,16,13,10,6,0,0),objectify(3,5,12,8,1,0,0),objectify(4,10,11,6,5,0,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
buffer: null,
size: 21,
varients: [],
rotate: true
},
liquidSurface: {
verts: [
[objectify( 0,    0,  0, 16,   16, 0, 0), objectify( 0, 14.5, 0, 16, 16, 0, 0)], //bottom
[objectify( 0, 14.5, 16, 16,   16, 0, 0)], //top
[objectify(16, 14.5, 16, 16, 14.5, 0, 0)], //north
[objectify( 0, 14.5,  0, 16, 14.5, 0, 0)], //south
[objectify(16, 14.5,  0, 16, 14.5, 0, 0)], //east
[objectify( 0, 14.5, 16, 16, 14.5, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
sporeBlossom: {
verts: [
[objectify( 1, 15.9, 1, 14, 14, -15, 1)], //bottom
[objectify( 1, 15.9, 15, 14, 14, -15, 1)], //top
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,-8, 0,11.1,-8, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,-8, 16,11.1,-8, 16,16,-16,-16)],
[customFace(0,15.9,8, 16,15.9,8, 16,11.1,24, 0,11.1,24, 16,16,-16,-16), customFace(16,15.9,8, 0,15.9,8, 0,11.1,24, 16,11.1,24, 16,16,-16,-16)], //southobjectify( 0, 16,  0, 16, 16, 0, 0)
[customFace(8,15.9,0, 8,15.9,16, -8,11.1,16, -8,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, -8,11.1,0, -8,11.1,16, 16,16,-16,-16)],
[customFace(8,15.9,0, 8,15.9,16, 24,11.1,16, 24,11.1,0, 16,16,-16,-16), customFace(8,15.9,16, 8,15.9,0, 24,11.1,0, 24,11.1,16, 16,16,-16,-16)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
},
azalea: {
verts: [
[objectify( 0,  8,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0),customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, -32,0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0),customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, -32,0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0),customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, -32,0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0),customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, -32,0)]  //west
],
cull: {
top: 3,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
}
},
azaleaPot: {
verts: [
[objectify( 4,  -7,  4, 8, 8, 4, 4)], //bottom
[objectify( 4, -1, 12, 8, 8, 4, 4)], //top
[objectify(12, -1, 12, 8, 11, 4, 5),customFace(4,-1,4, 12,-1,12, 12,-12,12, 4,-12,4, -12,5,8,11)], //north
[objectify( 4, -1,  4, 8, 11, 4, 5),customFace(12,-1,4, 4,-1,12, 4,-12,12, 12,-12,4, -12,5,8,11)], //south
[objectify(12, -1,  4, 8, 11, 4, 5),customFace(12,-1,12, 4,-1,4, 4,-12,4, 12,-12,12, -12,5,8,11)], //east
[objectify( 4, -1, 12, 8, 11, 4, 5),customFace(4,-1,12, 12,-1,4, 12,-12,4, 4,-12,12, -12,5,8,11)]  //west
],
cull: {
top: 3,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
sunflower: {
verts: [
[customFace(0,34,7, 16,34,7, 16,18,11, 0,18,11, 0,0)], //bottom
[customFace(16,34,7, 0,34,7, 0,18,11, 16,18,11, 0,0)], //top
[customFace(2,16,2, 14,16,14, 14,0,14, 2,0,2, -16,0),customFace(2,32,2, 14,32,14, 14,16,14, 2,16,2, 0,0)], //north
[customFace(14,16,2, 2,16,14, 2,0,14, 14,0,2, -16,0),customFace(14,32,2, 2,32,14, 2,16,14, 14,16,2, 0,0)], //south
[customFace(14,16,14, 2,16,2, 2,0,2, 14,0,14, -16,0),customFace(14,32,14, 2,32,2, 2,16,2, 14,16,14, 0,0)], //east
[customFace(2,16,14, 14,16,2, 14,0,2, 2,0,14, -16,0),customFace(2,32,14, 14,32,2, 14,16,2, 2,16,14, 0,0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
}
},
cake:{
verts: [
[objectify(1,0,1,14,14,1,1)],
[objectify(1,8,15,14,14,1,1)],
[objectify(15,8,15,14,8,1,8)],
[objectify(1,8,1,14,8,1,8)],
[objectify(15,8,1,14,8,1,8)],
[objectify(1,8,15,14,8,1,8)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
}
},
stonecutter:{
verts:[
[objectify(0,0,0,16,16,0,0)],
[objectify(0,9,16,16,16,0,0)],
[objectify(16,9,16,16,9,0,7),objectify(16,16,8,16,7,16,9)],
[objectify(0,9,0,16,9,0,7),objectify(0,16,8,16,7,16,9)],
[objectify(16,9,0,16,9,0,7)],
[objectify(0,9,16,16,9,0,7)]
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
}
},
itemFrame:{
verts: [
[objectify(2,2,15,12,1,-16,0),objectify(3,13,15,10,1,-16,0)],
[objectify(2,14,16,12,1,-16,0),objectify(3,3,16,10,1,-16,0)],
[objectify(14,14,16,12,12,-16,0)],
[objectify(3,13,15.5,10,10,3,3),objectify(2,14,15,11,1,-14,2),objectify(13,14,15,1,11,-3,2),objectify(3,3,15,11,1,-13,13),objectify(2,13,15,1,11,-14,3)],
[objectify(14,14,15,1,12,-16,0),objectify(3,13,15,1,10,-16,0)],
[objectify(2,14,16,1,12,-16,0),objectify(13,13,16,1,10,-16,0)]
],
cull: {
top: 0,
bottom: 0,
north: 3,
south: 0,
east: 0,
west: 0
},
rotate:true
},
endPortalFrame:{
verts: [
[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
[objectify( 0, 13, 16, 16, 16, 0, 0)], //top
[objectify(16, 13, 16, 16, 13, 0, 3)], //north
[objectify( 0, 13,  0, 16, 13, 0, 3)], //south
[objectify(16, 13,  0, 16, 13, 0, 3)], //east
[objectify( 0, 13, 16, 16, 13, 0, 3)]  //west
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate:true
},
eyeOfEnder: {
verts: [
[objectify( 4,  -3, 4, 8, 8, 4, 4)], //bottom
[objectify( 4, 0, 12, 8, 8, 4, 4)], //top
[objectify( 12, 0, 12, 8, 3, 4, 0)], //north
[objectify( 4, 0, 4, 8, 3, 4, 0)], //south
[objectify( 12, 0, 4, 8, 3, 4, 0)], //east
[objectify( 4, 0, 12, 8, 3, 4, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate: true
},
fire: {
verts: [
[], //bottom
[], //top
[objectify(16, 16, 16, 16, 16, 0, 0), customFace(0,16,16, 16,16,16, 16,0,0, 0,0,0, 0,0), customFace(16,16,16, 0,16,16, 0,0,0, 16,0,0, 0,0)], //north
[objectify( 0, 16,  0, 16, 16, 0, 0), customFace(16,16,0, 0,16,0, 0,0,16, 16,0,16, 0,0), customFace(0,16,0, 16,16,0, 16,0,16, 0,0,16, 0,0)], //south
[objectify(16, 16,  0, 16, 16, 0, 0), customFace(16,16,0, 16,16,16, 0,0,16, 0,0,0, 0,0), customFace(16,16,16, 16,16,0, 0,0,0, 0,0,16, 0,0)], //east
[objectify( 0, 16, 16, 16, 16, 0, 0), customFace(0,16,0, 0,16,16, 16,0,16, 16,0,0, 0,0), customFace(0,16,16, 0,16,0, 16,0,0, 16,0,16, 0,0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
hitbox:"cube"
},
endRod: {
verts: [
[objectify( 6, 0,  6, 4, 4, 2, 4)], //bottom
[objectify( 7, 16, 9, 2, 2, 2, 0),objectify(6, 1,  10, 4, 4, 2, 4)], //top
[objectify(9, 16, 9, 2, 15, 0, 0),objectify(10, 1, 10, 4, 1, 2, 2)], //north
[objectify(7, 16, 7, 2, 15, 0, 0),objectify(6, 1,  6, 4, 1, 2, 2)], //south
[objectify(9, 16, 7, 2, 15, 0, 0),objectify(10, 1, 6, 4, 1, 2, 2)], //east
[objectify(7, 16, 9, 2, 15, 0, 0),objectify(6, 1, 10, 4, 1, 2, 2)]  //west
],
cull: {
top: 0,
bottom: 1,
north: 0,
south: 0,
east: 0,
west: 0
},
flip: true,
},
endRodSW: {
verts: [
[objectify(7, 7, 0, 2, 15, 0, 0),objectify(6, 6,  15, 4, 1, 2, 4)], //bottom
[objectify(7, 9, 15, 2, 15, 0, 0),objectify(6, 10, 16, 4, 1, 2, 4)], //top
[objectify(10, 10, 16, 4, 4, 2, 4)], //north
[objectify( 7, 9, 0, 2, 2, 2, 0),objectify(6, 10,  15, 4, 4, 2, 2)], //south
[objectify(9, 9, 0, 15, 2, 16, 14),objectify(10, 10, 15, 1, 4, 2, 2)], //east
[objectify(7, 9, 15, 15, 2, 16, 14),objectify(6, 10, 16, 1, 4, 2, 2)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 1,
south: 0,
east: 0,
west: 0
},
rotate: true,
},
door2: {
verts: [
[objectify(0,0,13,16,3,0,0, false,false,false,null,2)],
[objectify(0,32,16,16,3,0,0, false,false,false,null,2)],
[objectify(16,32,16,16,16,-16,0),objectify(16,16,16,16,16,0,0)],
[objectify(0,32,13,16,16,-16,0, true),objectify(0,16,13,16,16,0,0, true)],
[objectify(16,32,13,3,16,-3,0, false,false,false,2),objectify(16,16,13,3,16,13,0, false,false,false,2)],
[objectify(0,32,16,3,16,-16,0, false,false,false,2),objectify(0,16,16,3,16,0,0, false,false,false,2)]
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate: true
},
fenceGate: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(2,12,7,12,2,0,2),objectify(2,6,7,12,2,0,2),objectify(14,5,7,2,2,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(2,15,9,12,2,0,2),objectify(2,9,9,12,2,0,2),objectify(14,16,9,2,2,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(14,15,9,12,3,2,1),objectify(14,9,9,12,3,2,7),objectify(16,16,9,2,11,14,0),objectify(10,12,9,4,3,6,4)],
[objectify(0,16,7,2,11,14,0),objectify(2,15,7,12,3,2,1),objectify(2,9,7,12,3,2,7),objectify(14,16,7,2,11,2,0),objectify(6,12,7,4,3,6,4)],
[objectify(2,16,7,2,11,6,0),objectify(10,12,7,2,3,0,0),objectify(16,16,7,2,11,0,0)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(6,12,9,2,3,0,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
flip: false,
rotate: true
},
fenceGateWall: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(2,9,7,12,2,0,2),objectify(2,3,7,12,2,0,2),objectify(14,2,7,2,2,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(2,12,9,12,2,0,2),objectify(2,6,9,12,2,0,2),objectify(14,13,9,2,2,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(14,12,9,12,3,2,1),objectify(14,6,9,12,3,2,7),objectify(16,13,9,2,11,14,0),objectify(10,9,9,4,3,6,4)],
[objectify(0,13,7,2,11,14,0),objectify(2,12,7,12,3,2,1),objectify(2,6,7,12,3,2,7),objectify(14,13,7,2,11,2,0),objectify(6,9,7,4,3,6,4)],
[objectify(2,13,7,2,11,6,0),objectify(10,9,7,2,3,0,0),objectify(16,13,7,2,11,0,0)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(6,9,9,2,3,0,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
flip: false,
rotate: true
},
fenceGateOpen: {
verts: [
[objectify(0,5,7,2,2,0,1),objectify(14,12,9,2,6,0,2),objectify(14,6,9,2,6,0,2),objectify(14,5,7,2,2,0,0),objectify(0,12,9,2,6,0,0),objectify(0,6,9,2,6,0,0)],
[objectify(0,16,9,2,2,0,1),objectify(14,15,15,2,6,0,2),objectify(14,9,15,2,6,0,2),objectify(14,16,9,2,2,0,0),objectify(0,15,15,2,6,0,0),objectify(0,9,15,2,6,0,0)],
[objectify(2,16,9,2,11,0,0),objectify(16,15,15,2,9,2,1),objectify(2,15,15,2,9,2,7),objectify(16,16,9,2,11,14,0)],
[objectify(0,16,7,2,11,14,0),objectify(14,12,13,2,3,2,1),objectify(0,12,13,2,3,2,7),objectify(14,16,7,2,11,2,0)],
[objectify(2,16,7,2,11,6,0),objectify(2,12,13,2,3,6,4),objectify(16,16,7,2,11,6,4),objectify(16,12,13,2,3,0,0),objectify(16,15,9,6,3,2,1),objectify(2,15,9,6,3,2,1),objectify(16,9,9,6,3,2,7),objectify(2,9,9,6,3,2,7)],
[objectify(0,16,9,2,11,6,0),objectify(14,16,9,2,11,0,0),objectify(14,12,15,2,3,6,4),objectify(0,12,15,2,3,6,4),objectify(0,15,15,6,3,0,1),objectify(0,9,15,6,3,2,7),objectify(14,15,15,6,3,2,1),objectify(14,9,15,6,3,2,7)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
flip: false,
rotate: true
},
fenceGateWallOpen: {
verts: [
[objectify(0,2,7,2,2,0,1),objectify(14,9,9,2,6,0,2),objectify(14,3,9,2,6,0,2),objectify(14,2,7,2,2,0,0),objectify(0,9,9,2,6,0,0),objectify(0,3,9,2,6,0,0)],
[objectify(0,13,9,2,2,0,1),objectify(14,12,15,2,6,0,2),objectify(14,6,15,2,6,0,2),objectify(14,13,9,2,2,0,0),objectify(0,12,15,2,6,0,0),objectify(0,6,15,2,6,0,0)],
[objectify(2,13,9,2,11,0,0),objectify(16,12,15,2,9,2,1),objectify(2,12,15,2,9,2,7),objectify(16,13,9,2,11,14,0)],
[objectify(0,13,7,2,11,14,0),objectify(14,9,13,2,3,2,1),objectify(0,9,13,2,3,2,7),objectify(14,13,7,2,11,2,0)],
[objectify(2,13,7,2,11,6,0),objectify(2,9,13,2,3,6,4),objectify(16,13,7,2,11,6,4),objectify(16,9,13,2,3,0,0),objectify(16,12,9,6,3,2,1),objectify(2,12,9,6,3,2,1),objectify(16,6,9,6,3,2,7),objectify(2,6,9,6,3,2,7)],
[objectify(0,13,9,2,11,6,0),objectify(14,13,9,2,11,0,0),objectify(14,9,15,2,3,6,4),objectify(0,9,15,2,3,6,4),objectify(0,12,15,6,3,0,1),objectify(0,6,15,6,3,2,7),objectify(14,12,15,6,3,2,1),objectify(14,6,15,6,3,2,7)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
flip: false,
rotate: true
},
tallCrop: {
verts: [
[],
[],
[objectify(16,32,4,16,16,0,0),objectify(16,32,12,16,16,0,0),objectify(16,16,4,16,16,-16,0),objectify(16,16,12,16,16,-16,0)],
[objectify(0,32,12,16,16,0,0),objectify(0,32,4,16,16,0,0),objectify(0,16,12,16,16,-16,0),objectify(0,16,4,16,16,-16,0)],
[objectify(4,32,0,16,16,0,0),objectify(12,32,0,16,16,0,0),objectify(4,16,0,16,16,-16,0),objectify(12,16,0,16,16,-16,0)],
[objectify(12,32,16,16,16,0,0),objectify(4,32,16,16,16,0,0),objectify(12,16,16,16,16,-16,0),objectify(4,16,16,16,16,-16,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
varients: []
},
chainSW: {
verts: [
[objectify(6.5,8,0,3,16,0,0)],
[objectify(6.5,8,16,3,16,0,0)],
[],
[],
[objectify(8,9.5,0,16,3,0,3)],
[objectify(8,9.5,16,16,3,0,3)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate:true
},
campfire:{
verts: [
[objectify(1,0,0,4,16,60,0),objectify(11,0,0,4,16,60,0),objectify(0,3,1,16,4,0,4),objectify(0,3,11,16,4,0,4),objectify(5,0,0,6,16,48,0)],
[objectify(1,4,16,4,16,60,0),objectify(11,4,16,4,16,60,0),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,64,0)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,0,0),objectify(16,7,15,16,4,0,0),objectify(11,1,16,6,1,0,15), customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 32,0)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,0,0),objectify(0,7,11,16,4,0,0),objectify(5,1,0,6,1,0,15), customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 32,0)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,0,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4), customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 32,0)],
[objectify(11,4,16,16,4,0,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4), customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 32,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
hitbox:"slab"
},
campfireUnlit:{
verts:[
[objectify(1,0,0,4,16,60,0),objectify(11,0,0,4,16,60,0),objectify(0,3,1,16,4,16,0),objectify(0,3,11,16,4,16,0),objectify(5,0,0,6,16,48,0)],
[objectify(1,4,16,4,16,60,0),objectify(11,4,16,4,16,60,0),objectify(0,7,5,16,4,16,0),objectify(0,7,15,16,4,16,0),objectify(5,1,16,6,16,48,0)],
[objectify(5,4,16,4,4,16,4),objectify(15,4,16,4,4,16,4),objectify(16,7,5,16,4,16,0),objectify(16,7,15,16,4,16,0),objectify(11,1,16,6,1,0,15)],
[objectify(1,4,0,4,4,16,4),objectify(11,4,0,4,4,16,4),objectify(0,7,1,16,4,16,0),objectify(0,7,11,16,4,16,0),objectify(5,1,0,6,1,0,15)],
[objectify(15,4,0,16,4,16,0),objectify(5,4,0,16,4,16,0),objectify(16,7,1,4,4,16,4),objectify(16,7,11,4,4,16,4)],
[objectify(11,4,16,16,4,16,0),objectify(1,4,16,16,4,16,0),objectify(0,7,5,4,4,16,4),objectify(0,7,15,4,4,16,4)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
hitbox:"slab"
},
bamboo:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0)],
[objectify(6.5,16,6.5,3,16,0,0)],
[objectify(9.5,16,6.5,3,16,0,0)],
[objectify(6.5,16,9.5,3,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
},
bambooSmallLeaf:{
verts: [
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,-64,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,-64,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,-64,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,-64,0)]
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
},
bambooBigLeaf:{
verts:[
[objectify(6.5,0,6.5,3,3,13,4)],
[objectify(6.5,16,9.5,3,3,13,0)],
[objectify(9.5,16,9.5,3,16,0,0),objectify(16,16,8,16,16,-48,0)],
[objectify(6.5,16,6.5,3,16,0,0),objectify(0,16,8,16,16,-48,0)],
[objectify(9.5,16,6.5,3,16,0,0),objectify(8,16,0,16,16,-48,0)],
[objectify(6.5,16,9.5,3,16,0,0),objectify(8,16,16,16,16,-48,0)]
],
cull: {
top: 3,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
},
bambooPot:{
verts:[
[],
[objectify(7,0,9,2,2,13,0)],
[objectify(9,0,9,2,16,0,0),objectify(16,0,8,16,16,-32,0)],
[objectify(7,0,7,2,16,0,0),objectify(0,0,8,16,16,-32,0, true)],
[objectify(9,0,7,2,16,0,0)],
[objectify(7,0,9,2,16,0,0)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
},
chest:{
verts:[
[objectify(1,0,1,14,14,32,0),objectify(7,7,0,2,1,-13,0)],
[objectify(1,14,15,14,14,32,0),objectify(7,11,1,2,1,-15,0)],
[objectify(15,14,15,14,4,16,0),objectify(15,10,15,14,10,16,5),objectify(9,11,1,2,4,-16,1)],
[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,-14,1)],
[objectify(15,14,1,14,4,16,0),objectify(15,10,1,14,10,16,5),objectify(9,11,0,1,4,-14,1)],
[objectify(1,14,15,14,4,16,0),objectify(1,10,15,14,10,16,5),objectify(7,11,1,1,4,-16,1)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate:true
},
christmasChest:{
verts:[
[objectify(1,0,1,14,14,32,0),objectify(7,7,0,2,1,-13,0)],
[objectify(1,14,15,14,14,16,0),objectify(7,11,1,2,1,-15,0)],
[objectify(15,14,15,14,4,0,0),objectify(15,10,15,14,10,0,5),objectify(9,11,1,2,4,-16,1)],
[objectify(1,14,1,14,4,0,0),objectify(1,10,1,14,10,0,5),objectify(7,11,0,2,4,-14,1)],
[objectify(15,14,1,14,4,0,0),objectify(15,10,1,14,10,0,5),objectify(9,11,0,1,4,-14,1)],
[objectify(1,14,15,14,4,0,0),objectify(1,10,15,14,10,0,5),objectify(7,11,1,1,4,-16,1)]
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate:true
},
pressurePlate:{
verts:[
[objectify(1,0,1,14,14,1,1)],
[objectify(1,1,15,14,14,1,1)],
[objectify(15,1,15,14,1,0,0)],
[objectify(1,1,1,14,1,0,0)],
[objectify(15,1,1,14,1,0,0)],
[objectify(1,1,15,14,1,0,0)]
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
},
redstoneDust:{
verts:[
[objectify(0,0.25,0,16,16,0,0)],
[objectify(0,0.25,16,16,16,0,0)],
[],
[],
[],
[]
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
},
redstoneDustRotate:{
verts:[
[objectify(0,0.25,0,16,16,0,0)],
[objectify(0,0.25,16,16,16,0,0)],
[],
[],
[],
[]
],
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
},
rotate:true
},
playerHand: {
verts: [
[objectify( 6,  6,  6, 4,  4, 0, 0)], //bottom
[objectify( 6, 18, 10, 4,  4, 0, 0)], //top
[objectify(10, 18, 10, 4, 12, 0, 0)], //north
[objectify( 6, 18,  6, 4, 12, 0, 0)], //south
[objectify(10, 18,  6, 4, 12, 0, 0)], //east
[objectify( 6, 18, 10, 4, 12, 0, 0)]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
texVerts: [],
varients: [],
buffer: null,
size: 6
},
playerBody:{
verts:[
[objectify(4,2,6,8,4,28,16),objectify(3.75,1.75,5.75,8.5,4.5,28,32,false,false,false,8,4)],
[objectify(4,14,10,8,4,20,16),objectify(3.75,14.25,10.25,8.5,4.5,20,32,false,false,false,8,4)],
[objectify(12,14,10,8,12,20,20),objectify(12.25,14.25,10.25,8.5,12.5,20,36,false,false,false,8,12)],
[objectify(4,14,6,8,12,32,20),objectify(3.75,14.25,5.75,8.5,12.5,32,36,false,false,false,8,12)],
[objectify(12,14,6,4,12,28,20),objectify(12.25,14.25,5.75,4.5,12.5,28,36,false,false,false,4,12)],
[objectify(4,14,10,4,12,16,20),objectify(3.75,14.25,10.25,4.5,12.5,16,36,false,false,false,4,12)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
playerHead:{
verts:[
[objectify(4,8,4,8,8,16,0),objectify(3.75,7.75,3.75,8.5,8.5,48,0,false,false,false,8,8)],
[objectify(4,16,12,8,8,8,0),objectify(3.75,16.25,12.25,8.5,8.5,40,0,false,false,false,8,8)],
[objectify(12,16,12,8,8,8,8),objectify(12.25,16.25,12.25,8.5,8.5,40,8,false,false,false,8,8)],
[objectify(4,16,4,8,8,24,8),objectify(3.75,16.25,3.75,8.5,8.5,56,8,false,false,false,8,8)],
[objectify(12,16,4,8,8,16,8),objectify(12.25,16.25,3.75,8.5,8.5,48,8,false,false,false,8,8)],
[objectify(4,16,12,8,8,0,8),objectify(3.75,16.25,12.25,8.5,8.5,32,8,false,false,false,8,8)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
playerLeftArm:{
verts:[
[objectify(6,-4,6,4,4,40,48),objectify(5.75,-4.25,5.75,4.5,4.5,56,48, false,false,false,4,4)],
[objectify(6,8,10,4,4,36,48),objectify(5.75,8.25,10.25,4.5,4.5,52,48, false,false,false,4,4)],
[objectify(10,8,10,4,12,36,53),objectify(10.25,8.25,10.25,4.5,12.5,52,52, false,false,false,4,12)],
[objectify(6,8,6,4,12,44,52),objectify(5.75,8.25,5.75,4.5,12.5,60,52, false,false,false,4,12)],
[objectify(10,8,6,4,12,32,52),objectify(10.25,8.25,5.75,4.5,12.5,48,52, false,false,false,4,12)],
[objectify(6,8,10,4,12,40,52),objectify(5.75,8.25,10.25,4.5,12.5,56,52, false,false,false,4,12)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
playerRightArm:{
verts:[
[objectify(6,-4,6,4,4,48,16),objectify(5.75,-4.25,5.75,4.5,4.5,48,32, false,false,false,4,4)],
[objectify(6,8,10,4,4,44,16),objectify(5.75,8.25,10.25,4.5,4.5,44,32, false,false,false,4,4)],
[objectify(10,8,10,4,12,44,20),objectify(10.25,8.25,10.25,4.5,12.5,44,36, false,false,false,4,12)],
[objectify(6,8,6,4,12,52,20),objectify(5.75,8.25,5.75,4.5,12.5,52,36, false,false,false,4,12)],
[objectify(10,8,6,4,12,40,20),objectify(10.25,8.25,5.75,4.5,12.5,40,36, false,false,false,4,12)],
[objectify(6,8,10,4,12,48,20),objectify(5.75,8.25,10.25,4.5,12.5,48,36, false,false,false,4,12)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
playerLeftLeg:{
verts:[
[objectify(6,-4,6,4,4,24,48),objectify(5.75,-4.25,5.75,4.5,4.5,8,48, false,false,false,4,4)],
[objectify(6,8,10,4,4,20,48),objectify(5.75,8.25,10.25,4.5,4.5,4,48, false,false,false,4,4)],
[objectify(10,8,10,4,12,20,52),objectify(10.25,8.25,10.25,4.5,12.5,4,52, false,false,false,4,12)],
[objectify(6,8,6,4,12,28,52),objectify(5.75,8.25,5.75,4.5,12.5,12,52, false,false,false,4,12)],
[objectify(10,8,6,4,12,24,52),objectify(10.25,8.25,5.75,4.5,12.5,0,52, false,false,false,4,12)],
[objectify(6,8,10,4,12,16,52),objectify(5.75,8.25,10.25,4.5,12.5,8,52, false,false,false,4,12)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
playerRightLeg:{
verts:[
[objectify(6,-4,6,4,4,8,16),objectify(5.75,-4.25,5.75,4.5,4.5,8,32, false,false,false,4,4)],
[objectify(6,8,10,4,4,4,16),objectify(5.75,8.25,10.25,4.5,4.5,4,32, false,false,false,4,4)],
[objectify(10,8,10,4,12,4,20),objectify(10.25,8.25,10.25,4.5,12.5,4,36, false,false,false,4,12)],
[objectify(6,8,6,4,12,12,20),objectify(5.75,8.25,5.75,4.5,12.5,12,36, false,false,false,4,12)],
[objectify(10,8,6,4,12,8,20),objectify(10.25,8.25,5.75,4.5,12.5,0,36, false,false,false,4,12)],
[objectify(6,8,10,4,12,0,20),objectify(5.75,8.25,10.25,4.5,12.5,8,36, false,false,false,4,12)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
item: {
verts: generateItemShape(),
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null
},
cube2: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube3: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
},
},
cube4: {
verts: [
[objectify(0,0,0,16,16,0,0),objectify(8,4,8,16,16,0,0),objectify(-8,8,-8,16,16,0,0),objectify(8,-4,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)],
[objectify(16,16,16,16,16,0,0),objectify(24,20,24,16,16,0,0),objectify(8,24,8,16,16,0,0),objectify(24,12,8,16,16,0,0)],
[objectify(0,16,0,16,16,0,0),objectify(8,20,8,16,16,0,0),objectify(-8,24,-8,16,16,0,0),objectify(8,12,-8,16,16,0,0)],
[objectify(16,16,0,16,16,0,0),objectify(24,20,8,16,16,0,0),objectify(8,24,-8,16,16,0,0),objectify(24,12,-8,16,16,0,0)],
[objectify(0,16,16,16,16,0,0),objectify(8,20,24,16,16,0,0),objectify(-8,24,8,16,16,0,0),objectify(8,12,8,16,16,0,0)]
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
entityFire: {
verts: [
[], //bottom
[], //top
[customFace(0,16,0, 16,16,16, 16,0,16, 0,0,0, 0,0), objectify(16, 16,  8, 16, 16, 0, 0)], //north
[customFace(16,16,0, 0,16,16, 0,0,16, 16,0,0, 0,0), objectify(0,  16,  8, 16, 16, 0, 0)], //south
[customFace(16,16,16, 0,16,0, 0,0,0, 16,0,16, 0,0), objectify(8,  16,  0, 16, 16, 0, 0)], //east
[customFace(0,16,16, 16,16,0, 16,0,0, 0,0,16, 0,0), objectify(8,  16, 16, 16, 16, 0, 0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
},
cow: {
verts: [
// x, y, z, width, height, textureX, textureY
// 0, 0, 0 is the corner on the top left of the texture
[objectify( 0,  0,  0, 16, 16, 0, 0), objectify(16,  8,  4,  8,  8,  0,  0)], //bottom
[objectify( 0, 12, 16, 16, 16, 0, 0), objectify(16, 16, 12,  8,  8,  0,  0)], //top
[objectify(16, 12, 16, 16, 12, 0, 4), objectify(24, 16, 12,  8,  8, 16,  0)], //north
[objectify( 0, 12,  0, 16, 12, 0, 4), objectify(16, 16,  4,  8,  8, 16,  0)], //south
[objectify(16, 12,  0, 16, 12, 0, 4), objectify(24, 16,  4,  8,  8, 16,  0)], //east
[objectify( 0, 12, 16, 16, 12, 0, 4), objectify(16, 16, 12,  8,  8, 16,  0)]  //west
],
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
},
texVerts: [],
varients: [],
buffer: null,
size: 12,
},
blockParticle: {
verts: [
[], //bottom
[], //top
[objectify( 16, 16, 8, 16, 16, 0, 0)], //north
[objectify(  0, 16, 8, 16, 16, 0, 0)], //south
[], //east
[]  //west
],
cull: {
top: 3,
bottom: 3,
north: 3,
south: 3,
east: 3,
west: 3
}
},
panorama:{
verts: //*
(function(){
var arr = [[],[],[],[],[],[]]
var data = arr[2]
var rt = Math.PId/360
var s = (sin(0)+1)*8, c = (cos(0)+1)*8
var w = -rt/Math.PId*16
for(var deg=0; deg<Math.PId; deg+=rt){
var s2 = (sin(deg+rt)+1)*8, c2 = (cos(deg+rt)+1)*8
var a = (deg+rt) / Math.PId
data.push(customFace(s,16,c, s2,16,c2, s2,0,c2, s,0,c, a*16,0,w,16))
s = s2, c = c2
}
return arr
})()/*/[
[objectify( 0,  0,  0, 16, 16, 6, 0)], //bottom
[objectify( 0, 16, 16, 16, 16, 4, 0)], //top
[objectify(16, 16, 16, 16, 16, 0, 0)], //north
[objectify( 0, 16,  0, 16, 16, 2, 0)], //south
[objectify(16, 16,  0, 16, 16, 8, 0)], //east
[objectify( 0, 16, 16, 16, 16, 10, 0)]  //west
]//*/
,
cull: {
top: 0,
bottom: 0,
north: 0,
south: 0,
east: 0,
west: 0
}
},
}
win.shapes = shapes
for(var shape = 0; shape < 8; shape ++){
shapes["layer"+(shape+1)] = {
verts: layerShape((shape+1)*2),
cull: {
top: 0,
bottom: 3,
north: 0,
south: 0,
east: 0,
west: 0
}
}
}
//automatically set size
for(var shape in shapes){
shape = shapes[shape]
let v = shape.verts
let s = v[0].length + v[1].length + v[2].length + v[3].length + v[4].length + v[5].length
shape.size = s
shape.texVerts = []
shape.varients = []
shape.buffer = null
if(typeof shape.hitbox === "string"){
shape.hitbox = shapes[shape.hitbox]
}
}
function compareArr(arr, out) {
let minX = 1000
let maxX = -1000
let minY = 1000
let maxY = -1000
let minZ = 1000
let maxZ = -1000
let num = 0
for (let i = 0; i < arr.length; i += 3) {
num = arr[i]
minX = minX > num ? num : minX
maxX = maxX < num ? num : maxX
num = arr[i + 1]
minY = minY > num ? num : minY
maxY = maxY < num ? num : maxY
num = arr[i + 2]
minZ = minZ > num ? num : minZ
maxZ = maxZ < num ? num : maxZ
}
out[0] = minX
out[1] = minY
out[2] = minZ
out[3] = maxX
out[4] = maxY
out[5] = maxZ
return out
}
function arrayValues(a1,a2){
if(a1.length !== a2.length) return false
let minLen = a1.length
for(var i=0; i<minLen; i++){
if(a1[i] !== a2[i]){
return false
}
}
return true
}
function initShapes() {
function mapCoords(rect, face) {
if(rect.custom) return mapCustomCoords(rect)
let x = rect.x
let y = rect.y
let z = rect.z
let w = rect.w
let h = rect.h
let tx = rect.tx
let ty = rect.ty
let tw = rect.tw
let th = rect.th
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
if(rect.txf){
tex[0] = tx
tex[2] = tx+w
tex[4] = tx+w
tex[6] = tx
}
if(rect.rt){//doesn't work
tex.push(...tex.splice(0,2))
}
let pos = null
switch(face) {
case 0: // Bottom
pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
break
case 1: // Top
pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
break
case 2: // North
pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
break
case 3: // South
pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
break
case 4: // East
pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
break
case 5: // West
pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
break
}
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
return {
pos: pos,
tex: tex
}
}
function mapCustomCoords(coords){
let {x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4, tx,ty,tw,th} = coords
let tex = [tx+tw,ty, tx,ty, tx,ty+th, tx+tw,ty+th]
let pos = [x,y,z,x2,y2,z2,x3,y3,z3,x4,y4,z4]
pos = pos.map(c => c / 16 - 0.5)
let minmax = compareArr(pos, [])
pos.max = minmax.splice(3, 3)
pos.min = minmax
tex = tex.map(c => c / 16 / 16)
return {pos,tex}
}
// 90 degree clockwise rotation; returns a new shape object
function rotate(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let cull = shape.cull
let pos = []
tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j]
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = face[k + 1]
c[k + 2] = -face[k]
}
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
if (i === 0) {
// Bottom
c.push(...c.splice(0, 3))
tex[i][j].push(...tex[i][j].splice(0, 2))
}
if (i === 1) {
// Top
c.unshift(...c.splice(-3, 3))
tex[i][j].unshift(...tex[i][j].splice(-2, 2))
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
}
}
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
temp = pos[2] // North
pos[2] = pos[5] // North = West
pos[5] = pos[3] // West = South
pos[3] = pos[4] // South = East
pos[4] = temp // East = North
let cull2 = {
top: cull.top,
bottom: cull.bottom,
north: cull.west,
west: cull.south,
south: cull.east,
east: cull.north
}
let buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)
return {
verts: pos,
texVerts: tex,
cull: cull2,
rotate: true,
flip: shape.flip,
buffer: buffer,
size: shape.size,
varients: shape.varients,
bit: bit,
rotated: true,
rotateTimes: (shape.rotateTimes || 0) + 1
}
}
// Reflect over the y plane; returns a new shape object
function flip(shape, bit) {
let verts = shape.verts
let texVerts = shape.texVerts
let cull = shape.cull
let pos = []
tex = []
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
pos[i] = []
tex[i] = []
for (let j = 0; j < side.length; j++) {
let face = side[j].slice().reverse()
let c = []
pos[i][j] = c
for (let k = 0; k < face.length; k += 3) {
c[k] = face[k + 2]
c[k + 1] = -face[k + 1]
c[k + 2] = face[k]
}
let minmax = compareArr(c, [])
c.max = minmax.splice(3, 3)
c.min = minmax
tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
}
}
let temp = pos[0] // Bottom
pos[0] = pos[1] // Bottom = Top
pos[1] = temp // Top = Bottom
temp = tex[0] // Bottom
tex[0] = tex[1] // Bottom = Top
tex[1] = temp // Top = Bottom
let cull2 = {
top: cull.bottom,
bottom: cull.top,
north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
}
let buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)
return {
verts: pos,
texVerts: tex,
cull: cull2,
rotate: shape.rotate,
flip: shape.flip,
buffer: buffer,
size: shape.size,
varients: shape.varients,
bit: bit
}
}
for (let shape in shapes) {
let obj = shapes[shape]
let verts = obj.verts
// Populate the vertex coordinates
for (let i = 0; i < verts.length; i++) {
let side = verts[i]
let texArr = []
obj.texVerts.push(texArr)
for (let j = 0; j < side.length; j++) {
let face = side[j]
let mapped = mapCoords(face, i)
side[j] = mapped.pos
texArr.push(mapped.tex)
}
}
if (obj.rotate) {
let v = obj.varients
let east = rotate(obj, 4<<10)
let south = rotate(east, 2<<10)
let west = rotate(south, 6<<10)
v[0] = obj
v[2] = south
v[4] = east
v[6] = west
}
if (obj.flip) {
let v = obj.varients
v[1] = flip(obj,1<<10)
if (obj.rotate) {
v[3] = flip(v[2], 3<<10)
v[5] = flip(v[4], 5<<10)
v[7] = flip(v[6], 7<<10)
}
}
obj.buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(2)), gl.STATIC_DRAW)
}
function makeBlock(tex,shape,Block, base){
Block.textures = tex
Block.shape = shape
Block.shadow = base ? base.shadow : true
Block.transparent = base ? base.transparent : false
Block.solid = base ? base.solid : true
}
function rotTex(tex,n){
tex = tex.slice()
if(n){
for(var i=0; i<n; i++){
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
}else{
let temp = tex[2] // North
tex[2] = tex[5] // North = West
tex[5] = tex[3] // West = South
tex[3] = tex[4] // South = East
tex[4] = temp // East = North
}
return tex
}
win.initBlockData = function(){
for (let i = 0; i < BLOCK_COUNT; i++) {
let baseBlock = blockData[i]
for(var t=0; t<baseBlock.textures.length; t++){
if(semiTransTextures.includes(baseBlock.textures[t])){
baseBlock.semiTrans = true
break
}
}
var drop = baseBlock.drop || i
var d = baseBlock.drop
let slabBlock = Object.create(baseBlock)
let stairBlock = Object.create(baseBlock)
let crossBlock = Object.create(baseBlock)
let tallcrossBlock = Object.create(baseBlock)
let doorBlock = Object.create(baseBlock)
let torchBlock = Object.create(baseBlock)
let lanternBlock = Object.create(baseBlock)
let lanternHangBlock = Object.create(baseBlock)
let beaconBlock = Object.create(baseBlock)
let cactusBlock = Object.create(baseBlock)
let paneBlock = Object.create(baseBlock)
let portalBlock = Object.create(baseBlock)
let trapdoorBlock = Object.create(baseBlock)
let openTrapdoor = Object.create(baseBlock)
let wallFlatBlock = Object.create(baseBlock)
let fenceBlock = Object.create(baseBlock)
let wallPostBlock = Object.create(baseBlock)
let wallBlock = Object.create(baseBlock)
let walluBlock = Object.create(baseBlock)
let fencqBlock = Object.create(baseBlock)
let buttonBlock = Object.create(baseBlock)
let chainBlock = Object.create(baseBlock)
let potBlock = Object.create(baseBlock)
let potCrossBlock = Object.create(baseBlock)
let carpetBlock = Object.create(baseBlock)
baseBlock.shape = shapes.cube
slabBlock.shape = shapes.slab
slabBlock.transparent = true
slabBlock.drop = d || (i | SLAB)
slabBlock.Name += " Slab"
stairBlock.shape = shapes.stair
stairBlock.transparent = true
stairBlock.drop = d || (i | STAIR)
stairBlock.Name += " Stair"
crossBlock.shape = shapes.cross
crossBlock.drop = drop
tallcrossBlock.shape = shapes.tallCross
tallcrossBlock.drop = drop
doorBlock.shape = shapes.door
doorBlock.drop = drop
torchBlock.shape = shapes.torch
torchBlock.drop = drop
lanternBlock.shape = shapes.lantern
lanternHangBlock.shape = shapes.lanternHang
beaconBlock.shape = shapes.beacon
beaconBlock.drop = drop
cactusBlock.shape = shapes.cactus
cactusBlock.drop = drop
paneBlock.shape = shapes.pane
paneBlock.drop = drop
portalBlock.shape = shapes.portal
wallFlatBlock.shape = shapes.wallFlat
wallFlatBlock.drop = drop
trapdoorBlock.shape = shapes.trapdoor
trapdoorBlock.drop = drop
openTrapdoor.shape = shapes.trapdoorOpen
openTrapdoor.drop = drop
fenceBlock.shape = shapes.fence
fenceBlock.transparent = true
fenceBlock.drop = drop
wallPostBlock.shape = shapes.wallpost
wallPostBlock.transparent = true
wallPostBlock.drop = drop
wallBlock.shape = shapes.wall
wallBlock.drop = drop
walluBlock.shape = shapes.wallu
walluBlock.drop = drop
fencqBlock.shape = shapes.fencq
fencqBlock.drop = drop
buttonBlock.shape = shapes.button
buttonBlock.drop = drop
chainBlock.shape = shapes.chain
chainBlock.drop = drop
potBlock.shape = shapes.pot
potBlock.drop = drop
potCrossBlock.shape = shapes.potCross
potCrossBlock.drop = drop
carpetBlock.shape = shapes.carpet
carpetBlock.shadow = false
carpetBlock.transparent = true
carpetBlock.drop = i
if(baseBlock.torch || baseBlock.chain){
slabBlock.drop = i
}
if(baseBlock.door){//doesn't work: open and close weirdly
var doorType = baseBlock.id
var func = function(x,y,z){
var o = world.getTagByName(x,y,z,"open")
var b = world.getBlock(x,y,z)
var door2 = (b & SLAB) === SLAB
var shapeId = door2 ? (this.doorType | SLAB) : (this.doorType | DOOR)
var setId = door2 ? (this.doorType | SLAB) : (this.doorType | DOOR)
var set
if(door2 ? !o : o){
if((shapeId | NORTH) === b){
set = setId | WEST
}else if((shapeId | WEST) === b){
set = setId | SOUTH
}else if((shapeId | SOUTH) === b){
set = setId | EAST
}else if((shapeId | EAST)){
set = setId | NORTH
}
}else{
if((shapeId | NORTH) === b){
set = setId | EAST
}else if((shapeId | WEST) === b){
set = setId | NORTH
}else if((shapeId | SOUTH) === b){
set = setId | WEST
}else if((shapeId | EAST)){
set = setId | SOUTH
}
}
world.setBlock(x,y,z,set)
world.setTagByName(x,y,z,"open",!o)
}
baseBlock.onclick = func.bind({doorType:doorType})
slabBlock.shape = shapes.door2
slabBlock.drop = i
}
if(baseBlock.bed) baseBlock.shape = shapes.bed
if(baseBlock.rotate) baseBlock.shape = shapes.rotate
if(baseBlock.cactus) potCrossBlock.shape = shapes.cactusPot
if(baseBlock.crop) baseBlock.shape = shapes.crop
if(baseBlock.tallCrop)baseBlock.shape = shapes.tallCrop
if(baseBlock.anvil) baseBlock.shape = shapes.anvil
if(baseBlock.liquid) slabBlock.shape = shapes.liquidSurface
if(baseBlock._1PixLower){baseBlock.shape = shapes._1PixLower; baseBlock.transparent = true}
if(baseBlock.item) baseBlock.shape = shapes.item
if(baseBlock.torch) slabBlock.shape = shapes.wallTorch
if(baseBlock.sporeBlossom) baseBlock.shape = shapes.sporeBlossom
if(baseBlock.azalea){
baseBlock.shape = shapes.azalea
potCrossBlock.shape = shapes.azaleaPot
var t = baseBlock.potTex
potCrossBlock.textures = [t[0],t[0],t[1],t[1],t[1],t[1]]
}
if(baseBlock.sunflower) baseBlock.shape = shapes.sunflower
if(baseBlock.sideCross){baseBlock.shape = shapes.sideCross; slabBlock.shape = shapes.bottomCross}
if(baseBlock.layers){
torchBlock.shape = shapes.layer1
torchBlock.solid = true
torchBlock.shadow = false
torchBlock.dropAmount = 1
slabBlock.shape = shapes.layer2
slabBlock.solid = true
slabBlock.shadow = false
slabBlock.dropAmount = 2
stairBlock.shape = shapes.layer3
stairBlock.solid = true
stairBlock.shadow = false
stairBlock.dropAmount = 3
crossBlock.shape = shapes.layer4
crossBlock.solid = true
crossBlock.shadow = false
crossBlock.dropAmount = 4
tallcrossBlock.shape = shapes.layer5
tallcrossBlock.solid = true
tallcrossBlock.shadow = false
tallcrossBlock.dropAmount = 5
lanternBlock.shape = shapes.layer6
lanternBlock.solid = true
lanternBlock.shadow = false
lanternBlock.dropAmount = 6
lanternHangBlock.shape = shapes.layer7
lanternHangBlock.solid = true
lanternHangBlock.shadow = false
lanternHangBlock.dropAmount = 7
doorBlock.shape = shapes.layer8
doorBlock.solid = true
doorBlock.shadow = false
doorBlock.dropAmount = 8
}
if(baseBlock.name === "grass"){
crossBlock.shape = shapes.cube
crossBlock.textures = ["dirt","grassTop","snowGrass","snowGrass","snowGrass","snowGrass"]
crossBlock.solid = true
crossBlock.transparent = false
crossBlock.shadow = true
tallcrossBlock.shape = shapes._1PixLower
tallcrossBlock.textures = ["dirt","dirtPathTop","dirtPathSide","dirtPathSide","dirtPathSide","dirtPathSide"]
tallcrossBlock.solid = true
tallcrossBlock.transparent = true
tallcrossBlock.shadow = true
}
if(baseBlock.name === "farmland"){
slabBlock.textures = []
copyArr(baseBlock.textures, slabBlock.textures)
slabBlock.textures[1] = "farmlandMoist"
slabBlock.shape = shapes._1PixLower
}
if(baseBlock.mushroomBlock){
var cap = baseBlock.name
var pore = "mushroomBlockInside"
makeBlock(new Array(6).fill(pore), shapes.cube, slabBlock)
makeBlock([pore,cap,pore,pore,pore,pore], shapes.cube, stairBlock)
makeBlock([cap,pore,pore,pore,pore,pore], shapes.cube, crossBlock)
makeBlock([cap,cap,pore,pore,pore,pore], shapes.cube, tallcrossBlock)
makeBlock([pore,pore,cap,pore,pore,pore], shapes.rotate, doorBlock)
makeBlock([pore,cap,cap,pore,pore,pore], shapes.rotate, paneBlock)
makeBlock([cap,pore,cap,pore,pore,pore], shapes.rotate, portalBlock)
makeBlock([cap,cap,cap,pore,pore,pore], shapes.rotate, wallFlatBlock)
}
if(baseBlock.cake) baseBlock.shape = shapes.cake
if(baseBlock.stonecutter) baseBlock.shape = shapes.stonecutter
if(baseBlock.itemFrame) baseBlock.shape = shapes.itemFrame
if(baseBlock.name === "redstoneLamp"){
makeBlock(new Array(6).fill("redstoneLampOn"), shapes.cube, slabBlock)
slabBlock.lightLevel = 15
}
if(baseBlock.name === "endPortalFrame"){
baseBlock.shape = shapes.endPortalFrame
}
if(baseBlock.eyeOfEnder){
slabBlock.shape = shapes.eyeOfEnder
}
if(baseBlock.name === "furnace"){
var arr = baseBlock.textures.slice()
arr[3] = "furnaceFrontOn"
makeBlock(arr, shapes.rotate, slabBlock)
slabBlock.textures = arr
}
if(baseBlock.name === "jungleLeaves"){
makeBlock(new Array(6).fill("floweringJungleLeaves"), shapes.cube, slabBlock)
slabBlock.transparent = true
}
if(baseBlock.fire){
baseBlock.shape = shapes.fire
slabBlock.shape = shapes.cube
}
if(baseBlock.name === "endRod"){
baseBlock.shape = shapes.endRod
slabBlock.shape = shapes.endRodSW
}
if(baseBlock.fenceGate){
baseBlock.shape = shapes.fenceGate
baseBlock.transparent = true
slabBlock.shape = shapes.fenceGateWall
stairBlock.shape = shapes.fenceGateOpen
crossBlock.shape = shapes.fenceGateWallOpen
crossBlock.transparent = true
baseBlock.onclick = slabBlock.onclick = stairBlock.onclick = crossBlock.onclick = (function(x,y,z){
var b = world.getBlock(x,y,z)
var set
var id = this.id
if((id | CUBE) === b){
set = id | STAIR
}else if((id | SLAB) === b){
set = id | CROSS
}else if((id | STAIR) === b){
set = id | CUBE
}else if((id | CROSS) === b){
set = id | SLAB
}
console.log(set, id, b)
if(set)world.setBlock(x,y,z,set)
//doesn't work: if facing deriction other than north, it won't work
}).bind({id:baseBlock.id})
}
if(baseBlock.barrel){
makeBlock(baseBlock.texturesSW, shapes.rotate, slabBlock)
makeBlock(baseBlock.texturesDown, shapes.cube, stairBlock)
makeBlock(baseBlock.texturesOpen, shapes.cube, crossBlock)
makeBlock(baseBlock.texturesSWOpen, shapes.rotate, doorBlock)
makeBlock(baseBlock.texturesDownOpen, shapes.cube, tallcrossBlock)
}
if(baseBlock.chain){
slabBlock.shape = shapes.chainSW
slabBlock.textures = slabBlock.textures.slice()
slabBlock.textures[4] = slabBlock.textures[5] = "chainSW"
}
if(baseBlock.name === "beeNest" || baseBlock.name === "beehive"){
makeBlock(baseBlock.texturesHoney, shapes.rotate, slabBlock)
}
if(baseBlock.name === "sponge"){
makeBlock(baseBlock.wetTexture, shapes.cube, slabBlock)
}
if(baseBlock.campfire){
baseBlock.shape = shapes.campfire
slabBlock.shape = shapes.campfireUnlit
slabBlock.transparent = baseBlock.transparent
slabBlock.shadow = baseBlock.shadow
slabBlock.lightLevel = 0
}
if(baseBlock.bamboo){
baseBlock.shape = shapes.bamboo
makeBlock(baseBlock.textures, shapes.bambooSmallLeaf, slabBlock)
slabBlock.shadow = false
slabBlock.transparent = true
makeBlock(baseBlock.textures, shapes.bambooBigLeaf, stairBlock)
stairBlock.shadow = false
stairBlock.transparent = true
potCrossBlock.shape = shapes.bambooPot
}
if(baseBlock.chest) baseBlock.shape = /*shapes.christmasChest//*/shapes.chest//christmas
if(baseBlock.pressurePlate){
baseBlock.shape = shapes.pressurePlate
baseBlock.transparent = true
baseBlock.shadow = false
}
if(baseBlock.name === "tomatoPlant"){
baseBlock.shape = shapes.cross
makeBlock(baseBlock.textures1, shapes.cross, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.cross, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.cross, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.cross, tallcrossBlock, baseBlock)
crossBlock.drop = "tomato"
crossBlock.dropAmount = [4,8]
tallcrossBlock.drop = "tomato"
tallcrossBlock.dropAmount = [8,16]
}
if(baseBlock.name === "wheat"){
makeBlock(baseBlock.textures1, shapes.crop, slabBlock, baseBlock)
makeBlock(baseBlock.textures2, shapes.crop, stairBlock, baseBlock)
makeBlock(baseBlock.textures3, shapes.crop, crossBlock, baseBlock)
makeBlock(baseBlock.textures4, shapes.crop, tallcrossBlock, baseBlock)
makeBlock(baseBlock.textures5, shapes.crop, doorBlock, baseBlock)
makeBlock(baseBlock.textures6, shapes.crop, torchBlock, baseBlock)
makeBlock(baseBlock.textures7, shapes.crop, lanternBlock, baseBlock)
lanternBlock.drop = baseBlock.fullDrop
}
if(baseBlock.name === "redstoneDust"){
baseBlock.shape = shapes.redstoneDust
makeBlock(new Array(6).fill("redstoneDustLine"), shapes.redstoneDustRotate, slabBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustL"), shapes.redstoneDustRotate, stairBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDustT"), shapes.redstoneDustRotate, doorBlock, baseBlock)
makeBlock(new Array(6).fill("redstoneDust+"), shapes.redstoneDust, paneBlock, baseBlock)
}
blockData[i | SLAB] = slabBlock
blockData[i | STAIR] = stairBlock
blockData[i | CROSS] = crossBlock
blockData[i | TALLCROSS] = tallcrossBlock
blockData[i | DOOR] = doorBlock
blockData[i | TORCH] = torchBlock
blockData[i | LANTERN] = lanternBlock
blockData[i | LANTERNHANG] = lanternHangBlock
if(baseBlock.beacon) blockData[i | BEACON] = beaconBlock
if(baseBlock.cactus) blockData[i | CACTUS] = cactusBlock
blockData[i | PANE] = paneBlock
blockData[i | PORTAL] = portalBlock
blockData[i | WALLFLAT] = wallFlatBlock
blockData[i | TRAPDOOR] = trapdoorBlock
blockData[i | TRAPDOOROPEN] = openTrapdoor
blockData[i | FENCE] = fenceBlock
blockData[i | WALLPOST] = wallPostBlock
blockData[i | WALL] = wallBlock
blockData[i | WALLU] = walluBlock
blockData[i | FENCQ] = fencqBlock
if(baseBlock.button) blockData[i | BUTTON] = buttonBlock
if(baseBlock.chain) blockData[i | CHAIN] = chainBlock
if(baseBlock.pot) blockData[i | POT] = potBlock
blockData[i | POTCROSS] = potCrossBlock
if(baseBlock.carpet) blockData[i | CARPET] = carpetBlock
let v
if(baseBlock.shape.rotate || baseBlock.shape.flip){
let t = baseBlock.textures
v = baseBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(baseBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | v[j].bit] = block
}
}
}
v = slabBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = slabBlock.textures
if (v[j]) {
let block = Object.create(slabBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | SLAB | v[j].bit] = block
}
}
v = stairBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(stairBlock)
block.shape = v[j]
blockData[i | STAIR | v[j].bit] = block
}
}
v = doorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = doorBlock.textures
if (v[j]) {
let block = Object.create(doorBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | DOOR | v[j].bit] = block
}
}
v = paneBlock.shape.varients
for (let j = 0; j < v.length; j++) {
let t = baseBlock.textures
if (v[j]) {
let block = Object.create(paneBlock)
block.shape = v[j]
if(v[j].rotated) block.textures = rotTex(t, v[j].rotateTimes) //rotate textures around
blockData[i | PANE | v[j].bit] = block
}
}
v = portalBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(baseBlock)
block.shape = v[j]
blockData[i | PORTAL | v[j].bit] = block
}
}
v = wallFlatBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(wallFlatBlock)
block.shape = v[j]
blockData[i | WALLFLAT | v[j].bit] = block
}
}
v = trapdoorBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(trapdoorBlock)
block.shape = v[j]
blockData[i | TRAPDOOR | v[j].bit] = block
}
}
v = openTrapdoor.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(openTrapdoor)
block.shape = v[j]
blockData[i | TRAPDOOROPEN | v[j].bit] = block
}
}
v = wallBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(wallBlock)
block.shape = v[j]
blockData[i | WALL | v[j].bit] = block
}
}
v = walluBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(walluBlock)
block.shape = v[j]
blockData[i | WALLU | v[j].bit] = block
}
}
v = fencqBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j]) {
let block = Object.create(fencqBlock)
block.shape = v[j]
blockData[i | FENCQ | v[j].bit] = block
}
}
v = buttonBlock.shape.varients
for (let j = 0; j < v.length; j++) {
if (v[j] && blockData[i].button) {
let block = Object.create(buttonBlock)
block.shape = v[j]
blockData[i | BUTTON | v[j].bit] = block
}
}
}
}
}
let indexOrder;
(function() {
let arr = []
for (let i = 0; i < 100000; i++) {
arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4)
}
indexOrder = new Uint32Array(arr)
})()
let hexagonVerts
let slabIconVerts
let stairIconVerts
let _2dIconVerts
let fenceIconVerts
let wallPostIconVerts
let walluIconVerts
let wallIconVerts
let fencqIconVerts
let buttonIconVerts
let carpetIconVerts
let trapdoorIconVerts
let azaleaIconVerts
let cactusIconVerts
let snowIconVerts
let blockIcons
let blockIconError
{
let side = Math.sqrt(3) / 2
let s = side
let q = s / 2
let p = s / 16
hexagonVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
slabIconVerts = new Float32Array([
0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
])
stairIconVerts = [
-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
]
_2dIconVerts = [
//-1,-1,0,0,1,          1,-1,1,0,1,        1,1,1,1,1          -1,1,0,1,1 //x, y, tx, ty, useless
1,1,1,0,1,         1,-1,1,1,1,         -1,-1,0,1,1,    -1,1,0,0,1
]
fenceIconVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
wallPostIconVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
wallIconVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
walluIconVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
fencqIconVerts = new Float32Array([
0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
])
buttonIconVerts = new Float32Array([
0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
])
carpetIconVerts = new Float32Array([
0, 1-(p*17), 1, side, 0.5-(p*17), 1, 0, -(p*17), 1, -side, 0.5-(p*17), 1,
0, -(p*17), 1, side, 0.5-(p*17), 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5-(p*17), 1, 0, -(p*17), 1, 0, -1, 1, -side, -0.5, 1,
])
trapdoorIconVerts = new Float32Array([
0, 1-(p*15), 1, side, 0.5-(p*15), 1, 0, -(p*15), 1, -side, 0.5-(p*15), 1,
0, -(p*15), 1, side, 0.5-(p*15), 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5-(p*15), 1, 0, -(p*15), 1, 0, -1, 1, -side, -0.5, 1,
])
snowIconVerts = new Float32Array([
0, 1-(p*16), 1, side, 0.5-(p*16), 1, 0, -(p*16), 1, -side, 0.5-(p*16), 1,
0, -(p*16), 1, side, 0.5-(p*16), 1, side, -0.5, 1, 0, -1, 1,
-side, 0.5-(p*15), 1, 0, -(p*16), 1, 0, -1, 1, -side, -0.5, 1,
])
cactusIconVerts = new Float32Array([
0, 1-p, 1, side, 0.5-p, 1, 0, -p, 1, -side, 0.5-p, 1,
-p, 0, 1, side-p, 0.5, 1, side-p, -0.5, 1, -p, -1, 1,
-side+p, 0.5, 1, p, 0, 1, p, -1, 1, -side+p, -0.5, 1,
])
}
function genIcons() {
blockIcons = [null]
blockIcons.lengths = []
let texOrder = [ 1, 4, 3 ]
let shadows = [ 1, 0.4, 0.7 ]
let scale = 0.16 / height * inventory.size
let prevTexture
let data = []
for (let j = 11; j >= 0; j--) {
data.push(-hexagonVerts[j * 3 + 0] * scale)
data.push(hexagonVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(textureCoords[textureMap.error][(j * 2 + 0) % 8])
data.push(textureCoords[textureMap.error][(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
let buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIconError = buffer
blockIconError.length = 6 * 3
for (let i = 1; i < BLOCK_COUNT; i++) {
let data = []
let v, buffer
let block = blockData[i]
win.b = block.name
if(block.icon){
block = blockData[blockIds[block.icon]]
}
if(block.iconTexture){
prevTexture = block.textures
block.textures = new Array(6).fill(block.iconTexture)
}
if(block.flatIcon){
v = _2dIconVerts
for (let j = 3; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[2]]]
let tx = tex[0]
let ty = tex[1]
data.push(-v[j * 5 + 0] * scale)
data.push(v[j * 5 + 1] * scale)
data.push(0.1666666)
data.push(tx + v[j * 5 + 2] / 16)
data.push(ty + v[j * 5 + 3] / 16)
data.push(1)
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6
blockIcons[i | CROSS] = buffer
blockIcons.lengths[i | CROSS] = 6
blockIcons[i | TALLCROSS] = buffer
blockIcons.lengths[i | TALLCROSS] = 6
blockIcons[i | WALLFLAT] = buffer
blockIcons.lengths[i | WALLFLAT] = 6
blockIcons[i | TORCH] = buffer
blockIcons.lengths[i | TORCH] = 6
blockIcons[i | PANE] = buffer
blockIcons.lengths[i | PANE] = 6
}else if(block.carpet){
v = carpetIconVerts
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
data.push(-v[j * 3 + 0] * scale)
data.push(v[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6 * 3
blockIcons[i | CARPET] = buffer
blockIcons.lengths[i | CARPET] = 6 * 3
}else if(block.trapdoor){
v = trapdoorIconVerts
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
data.push(-v[j * 3 + 0] * scale)
data.push(v[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6 * 3
blockIcons[i | TRAPDOOR] = buffer
blockIcons.lengths[i | TRAPDOOR] = 6 * 3
blockIcons[i | TRAPDOOROPEN] = buffer
blockIcons.lengths[i | TRAPDOOROPEN] = 6 * 3
}else if(block.layers){
v = snowIconVerts
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
data.push(-v[j * 3 + 0] * scale)
data.push(v[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6 * 3
blockIcons[i | LAYER1] = buffer
blockIcons.lengths[i | LAYER1] = 6 * 3
blockIcons[i | LAYER2] = buffer
blockIcons.lengths[i | LAYER2] = 6 * 3
blockIcons[i | LAYER3] = buffer
blockIcons.lengths[i | LAYER3] = 6 * 3
blockIcons[i | LAYER4] = buffer
blockIcons.lengths[i | LAYER4] = 6 * 3
blockIcons[i | LAYER5] = buffer
blockIcons.lengths[i | LAYER5] = 6 * 3
blockIcons[i | LAYER6] = buffer
blockIcons.lengths[i | LAYER6] = 6 * 3
blockIcons[i | LAYER7] = buffer
blockIcons.lengths[i | LAYER7] = 6 * 3
blockIcons[i | LAYER8] = buffer
blockIcons.lengths[i | LAYER8] = 6 * 3
}else if(block.cactus){
v = cactusIconVerts
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
data.push(-v[j * 3 + 0] * scale)
data.push(v[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6 * 3
blockIcons[i | CACTUS] = buffer
blockIcons.lengths[i | CACTUS] = 6 * 3
}else{
for (let j = 11; j >= 0; j--) {
data.push(-hexagonVerts[j * 3 + 0] * scale)
data.push(hexagonVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
data.push(textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i] = buffer
blockIcons.lengths[i] = 6 * 3
}
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[floor(j / 4)]]]]
data.push(-slabIconVerts[j * 3 + 0] * scale)
data.push(slabIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[floor(j / 4)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | SLAB] = buffer
blockIcons.lengths[i | SLAB] = 6 * 3
data = []
v = stairIconVerts
for (let j = 23; j >= 0; j--) {
let num = floor(j / 8)
let tex = textureCoords[textureMap[block.textures[texOrder[num]]]]
let tx = tex[0]
let ty = tex[1]
data.push(-v[j * 5 + 0] * scale)
data.push(v[j * 5 + 1] * scale)
data.push(0.1666666)
data.push(tx + v[j * 5 + 2] / 16)
data.push(ty + v[j * 5 + 3] / 16)
data.push(shadows[num])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | STAIR] = buffer
blockIcons.lengths[i | STAIR] = 6 * 6
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-fenceIconVerts[j * 3 + 0] * scale)
data.push(fenceIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | FENCE] = buffer
blockIcons.lengths[i | FENCE] = 6 * 1
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-wallPostIconVerts[j * 3 + 0] * scale)
data.push(wallPostIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | WALLPOST] = buffer
blockIcons.lengths[i | WALLPOST] = 6 * 1
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-wallIconVerts[j * 3 + 0] * scale)
data.push(wallIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | WALL] = buffer
blockIcons.lengths[i | WALL] = 6 * 1
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-walluIconVerts[j * 3 + 0] * scale)
data.push(walluIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | WALLU] = buffer
blockIcons.lengths[i | WALLU] = 6 * 1
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-fencqIconVerts[j * 3 + 0] * scale)
data.push(fencqIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | FENCQ] = buffer
blockIcons.lengths[i | FENCQ] = 6 * 1
data = []
for (let j = 11; j >= 0; j--) {
let tex = textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]]
data.push(-buttonIconVerts[j * 3 + 0] * scale)
data.push(buttonIconVerts[j * 3 + 1] * scale)
data.push(0.1666666)
data.push(tex[(j * 2 + 0) % 8])
data.push(tex[(j * 2 + 1) % 8])
data.push(shadows[Math.floor(j / 16)])
}
buffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
blockIcons[i | BUTTON] = buffer
blockIcons.lengths[i | BUTTON] = 6 * 1
if(block.iconTexture){
block.textures = prevTexture
}
}
}
function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
let vrLocation = glCache[cacheId]
if(vrLocation === undefined) {
vrLocation = gl.getUniformLocation(programObj, vrName)
glCache[cacheId] = vrLocation
}
gl.uniformMatrix4fv(vrLocation, transpose, matrix)
}
function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
let vrLocation = glCache[cacheId]
if(vrLocation === undefined) {
vrLocation = gl.getAttribLocation(programObj, vrName)
glCache[cacheId] = vrLocation
}
if (vrLocation !== -1) {
gl.enableVertexAttribArray(vrLocation)
gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)
}
}
//panorama buffer
let panoramaVertBuffer
let panoramaTexBuffer
let panoramaSize
//Generate buffers for every block face and store them
let sideEdgeBuffers
let indexBuffer
function cross(v1, v2, result) {
let x = v1.x,
y = v1.y,
z = v1.z,
x2 = v2.x,
y2 = v2.y,
z2 = v2.z
result.x = y * z2 - y2 * z
result.y = z * x2 - z2 * x
result.z = x * y2 - x2 * y
}
let matrix = new Float32Array(16); // A temperary matrix that may store random data.
let projection = new Float32Array(16)
let defaultModelView = new Float32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
class Matrix {
constructor(arr) {
this.elements = new Float32Array(arr || 16)
}
translate(x, y, z) {
let a = this.elements
a[3] += a[0] * x + a[1] * y + a[2] * z
a[7] += a[4] * x + a[5] * y + a[6] * z
a[11] += a[8] * x + a[9] * y + a[10] * z
a[15] += a[12] * x + a[13] * y + a[14] * z
}
rotX(angle) {
let elems = this.elements
let c = cos(angle)
let s = sin(angle)
let t = elems[1]
elems[1] = t * c + elems[2] * s
elems[2] = t * -s + elems[2] * c
t = elems[5]
elems[5] = t * c + elems[6] * s
elems[6] = t * -s + elems[6] * c
t = elems[9]
elems[9] = t * c + elems[10] * s
elems[10] = t * -s + elems[10] * c
t = elems[13]
elems[13] = t * c + elems[14] * s
elems[14] = t * -s + elems[14] * c
}
rotY(angle) {
let c = cos(angle)
let s = sin(angle)
let elems = this.elements
let t = elems[0]
elems[0] = t * c + elems[2] * -s
elems[2] = t * s + elems[2] * c
t = elems[4]
elems[4] = t * c + elems[6] * -s
elems[6] = t * s + elems[6] * c
t = elems[8]
elems[8] = t * c + elems[10] * -s
elems[10] = t * s + elems[10] * c
t = elems[12]
elems[12] = t * c + elems[14] * -s
elems[14] = t * s + elems[14] * c
}
rotZ(angle) {
let c = cos(angle)
let s = sin(angle)
let elems = this.elements
let t = elems[0]
elems[0] = t * c + elems[1] * s
elems[1] = t * -s + elems[1] * c
t = elems[4]
elems[4] = t * c + elems[5] * s
elems[5] = t * -s + elems[5] * c
t = elems[8]
elems[8] = t * c + elems[9] * s
elems[9] = t * -s + elems[9] * c
t = elems[12]
elems[12] = t * c + elems[13] * s
elems[13] = t * -s + elems[13] * c
}
scale(x, y, z) {
let a = this.elements
a[0] *= x;
a[1] *= y;
a[2] *= z;
a[4] *= x;
a[5] *= y;
a[6] *= z;
a[8] *= x;
a[9] *= y;
a[10] *= z;
a[12] *= x;
a[13] *= y;
a[14] *= z;
}
unscale(x,y,z){
let a = this.elements
a[0] /= x;
a[1] /= y;
a[2] /= z;
a[4] /= x;
a[5] /= y;
a[6] /= z;
a[8] /= x;
a[9] /= y;
a[10] /= z;
a[12] /= x;
a[13] /= y;
a[14] /= z;
}
identity() {
let a = this.elements
a[0] = 1
a[1] = 0
a[2] = 0
a[3] = 0
a[4] = 0
a[5] = 1
a[6] = 0
a[7] = 0
a[8] = 0
a[9] = 0
a[10] = 1
a[11] = 0
a[12] = 0
a[13] = 0
a[14] = 0
a[15] = 1
}
// somebody optimize this
// you just have to expand it
mult(b) {
const a = this.elements.slice()
const out = this.elements
let e = 0
for (let row = 0; row < 4; row++) {
for (let col = 0; col < 4; col++) {
out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
}
}
}
// same here
postMult(a) {
const b = this.elements.slice()
const out = this.elements
let e = 0
for (let row = 0; row < 4; row++) {
for (let col = 0; col < 4; col++) {
out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
}
}
}
transpose() {
let matrix = this.elements
let temp = matrix[4]
matrix[4] = matrix[1]
matrix[1] = temp
temp = matrix[8]
matrix[8] = matrix[2]
matrix[2] = temp
temp = matrix[6]
matrix[6] = matrix[9]
matrix[9] = temp
temp = matrix[3]
matrix[3] = matrix[12]
matrix[12] = temp
temp = matrix[7]
matrix[7] = matrix[13]
matrix[13] = temp
temp = matrix[11]
matrix[11] = matrix[14]
matrix[14] = temp
}
copyArray(from) {
let to = this.elements
for (let i = 0; i < from.length; i++) {
to[i] = from[i]
}
}
copyMatrix(from) {
let to = this.elements
from = from.elements
for (let i = 0; i < from.length; i++) {
to[i] = from[i]
}
}
set(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) {
let to = this.elements
let from = arguments
for (let i = 0; i < from.length; i++) {
to[i] = from[i]
}
}
}
class Plane {
constructor(nx, ny, nz) {
this.set(nx, ny, nz)
}
set(nx, ny, nz) {
// Pre-computed chunk offsets to reduce branching during culling
this.dx = nx > 0 ? 16 : 0
this.dy = ny > 0
this.dz = nz > 0 ? 16 : 0
// Normal vector for the plane
this.nx = nx
this.ny = ny
this.nz = nz
}
}
let defaultTransformation = new Matrix([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ])
class Camera {
constructor() {
this.x = 0
this.y = 0
this.z = 0
this.previousX = 0
this.previousY = 0
this.previousZ = 0
this.rx = 0; // Pitch
this.ry = 0; // Yaw
this.rz = 0;
this.currentFov = 0
this.defaultFov = settings.fov
this.targetFov = settings.fov
this.step = 0
this.lastStep = 0
this.projection = new Float32Array(5)
this.transformation = new Matrix()
this.direction = { x: 1, y: 0, z: 0 }; // Normalized direction vector
this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
for (let i = 0; i < 5; i++) {
this.frustum.push(new Plane(1, 0, 0))
}
}
FOV(fov, time) {
if (fov === this.currentFov) return
if (!fov) {
let now = Date.now()
fov = this.currentFov + this.step * (now - this.lastStep)
this.lastStep = now
if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
fov = this.targetFov
}
}
else if (time) {
this.targetFov = fov
this.step = (fov - this.currentFov) / time
this.lastStep = Date.now()
return
} else {
this.targetFov = fov
}
const tang = Math.tan(fov * Math.PI / 360)
const scale = 1 / tang
const near = 1
const far = 1000000
this.currentFov = fov; // Store the state of the projection matrix
this.nearH = near * tang; // This is needed for frustum culling
this.projection[0] = scale / width * height
this.projection[1] = scale
this.projection[2] = -far / (far - near)
this.projection[3] = -1
this.projection[4] = -far * near / (far - near)
}
transform() {
let diff = (performance.now() - this.lastUpdate) / tickTime
if (diff > 1) diff = 1
let x = (this.x - this.previousX) * diff + this.previousX
let y = (this.y - this.previousY) * diff + this.previousY
let z = (this.z - this.previousZ) * diff + this.previousZ
this.transformation.copyMatrix(defaultTransformation)
this.transformation.rotZ(this.rz)
this.transformation.rotX(this.rx)
this.transformation.rotY(this.ry)
this.transformation.translate(-x, -y, -z)
}
resetMatrix() {
this.transformation.copyMatrix(defaultTransformation)
}
getMatrix() {
let proj = this.projection
let view = this.transformation.elements
matrix[0]  = proj[0] * view[0]
matrix[1]  = proj[1] * view[4]
matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
matrix[3]  = proj[4] * view[8]
matrix[4]  = proj[0] * view[1]
matrix[5]  = proj[1] * view[5]
matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
matrix[7]  = proj[4] * view[9]
matrix[8]  = proj[0] * view[2]
matrix[9]  = proj[1] * view[6]
matrix[10] = proj[2] * view[10] + proj[3] * view[14]
matrix[11] = proj[4] * view[10]
matrix[12] = proj[0] * view[3]
matrix[13] = proj[1] * view[7]
matrix[14] = proj[2] * view[11] + proj[3] * view[15]
matrix[15] = proj[4] * view[11]
return matrix
}
setDirection() {
if (this.targetFov !== this.currentFov) {
this.FOV()
}
this.direction.x = -sin(this.ry) * cos(this.rx)
this.direction.y = sin(this.rx)
this.direction.z = cos(this.ry) * cos(this.rx)
this.computeFrustum()
}
computeFrustum() {
let X = vec1
let dir = this.direction
X.x = dir.z
X.y = 0
X.z = -dir.x
X.normalize()
let Y = vec2
Y.set(dir)
Y.mult(-1)
cross(Y, X, Y)
//Near plane
this.frustum[0].set(dir.x, dir.y, dir.z)
let aux = vec3
aux.set(Y)
aux.mult(this.nearH)
aux.add(dir)
aux.normalize()
cross(aux, X, aux)
this.frustum[1].set(aux.x, aux.y, aux.z)
aux.set(Y)
aux.mult(-this.nearH)
aux.add(dir)
aux.normalize()
cross(X, aux, aux)
this.frustum[2].set(aux.x, aux.y, aux.z)
aux.set(X)
aux.mult(-this.nearH * width / height)
aux.add(dir)
aux.normalize()
cross(aux, Y, aux)
this.frustum[3].set(aux.x, aux.y, aux.z)
aux.set(X)
aux.mult(this.nearH * width / height)
aux.add(dir)
aux.normalize()
cross(Y, aux, aux)
this.frustum[4].set(aux.x, aux.y, aux.z)
}
canSee(x, y, z, maxY) {
x -= 0.5
y -= 0.5
z -= 0.5
maxY += 0.5
let px = 0, py = 0, pz = 0, plane = null
let cx = p.x, cy = p.y, cz = p.z
for (let i = 0; i < 5; i++) {
plane = this.frustum[i]
px = x + plane.dx
py = plane.dy ? maxY : y
pz = z + plane.dz
if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
return false
}
}
return true
}
}
function trans(matrix, x, y, z) {
let a = matrix
a[3] += a[0] * x + a[1] * y + a[2] * z
a[7] += a[4] * x + a[5] * y + a[6] * z
a[11] += a[8] * x + a[9] * y + a[10] * z
a[15] += a[12] * x + a[13] * y + a[14] * z
}
function rotX(matrix, angle) {
// This function is basically multiplying 2 4x4 matrices together,
// but 1 of them has a bunch of 0's and 1's in it,
// so I removed all terms that multiplied by 0, and just left off the 1's.
// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
let elems = matrix
let c = cos(angle)
let s = sin(angle)
let t = elems[1]
elems[1] = t * c + elems[2] * s
elems[2] = t * -s + elems[2] * c
t = elems[5]
elems[5] = t * c + elems[6] * s
elems[6] = t * -s + elems[6] * c
t = elems[9]
elems[9] = t * c + elems[10] * s
elems[10] = t * -s + elems[10] * c
t = elems[13]
elems[13] = t * c + elems[14] * s
elems[14] = t * -s + elems[14] * c
}
function rotY(matrix, angle) {
//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
let c = cos(angle)
let s = sin(angle)
let elems = matrix
let t = elems[0]
elems[0] = t * c + elems[2] * -s
elems[2] = t * s + elems[2] * c
t = elems[4]
elems[4] = t * c + elems[6] * -s
elems[6] = t * s + elems[6] * c
t = elems[8]
elems[8] = t * c + elems[10] * -s
elems[10] = t * s + elems[10] * c
t = elems[12]
elems[12] = t * c + elems[14] * -s
elems[14] = t * s + elems[14] * c
}
function scale(a,x,y,z){
a[0] *= x;
a[1] *= y;
a[2] *= z;
a[4] *= x;
a[5] *= y;
a[6] *= z;
a[8] *= x;
a[9] *= y;
a[10] *= z;
a[12] *= x;
a[13] *= y;
a[14] *= z;
}
function transpose(matrix) {
let temp = matrix[4]
matrix[4] = matrix[1]
matrix[1] = temp
temp = matrix[8]
matrix[8] = matrix[2]
matrix[2] = temp
temp = matrix[6]
matrix[6] = matrix[9]
matrix[9] = temp
temp = matrix[3]
matrix[3] = matrix[12]
matrix[12] = temp
temp = matrix[7]
matrix[7] = matrix[13]
matrix[13] = temp
temp = matrix[11]
matrix[11] = matrix[14]
matrix[14] = temp
}
function matMult() {
//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
let proj = projection
let view = modelView
matrix[0] = proj[0] * view[0]
matrix[1] = proj[0] * view[1]
matrix[2] = proj[0] * view[2]
matrix[3] = proj[0] * view[3]
matrix[4] = proj[5] * view[4]
matrix[5] = proj[5] * view[5]
matrix[6] = proj[5] * view[6]
matrix[7] = proj[5] * view[7]
matrix[8] = proj[10] * view[8] + proj[11] * view[12]
matrix[9] = proj[10] * view[9] + proj[11] * view[13]
matrix[10] = proj[10] * view[10] + proj[11] * view[14]
matrix[11] = proj[10] * view[11] + proj[11] * view[15]
matrix[12] = proj[14] * view[8]
matrix[13] = proj[14] * view[9]
matrix[14] = proj[14] * view[10]
matrix[15] = proj[14] * view[11]
}
function copyArr(a, b) {
for (let i = 0; i < a.length; i++) {
b[i] = a[i]
}
}
function FOV(fov) {
let tang = Math.tan(fov * 0.5 * Math.PI / 180)
let scale = 1 / tang
let near = 1
let far = 1000000
currentFov = fov
projection[0] = scale / width * height
projection[5] = scale
projection[10] = -far / (far - near)
projection[11] = -1
projection[14] = -far * near / (far - near)
}
function initModelView(camera, x, y, z, rx, ry, sx, sy) {
if (camera) {
camera.transform()
uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
} else {
copyArr(defaultModelView, modelView)
rotX(modelView, rx)
rotY(modelView, ry)
trans(modelView, -x, -y, -z)
if(sy){
scale(modelView,sx,sy,1)
}else{
scale(modelView, sx,sx,1)
}
matMult()
transpose(matrix)
uniformMatrix("view3d", program3D, "uView", false, matrix)
}
}
win.initModelView = initModelView
function timeString(millis) {
if (millis > 300000000000 || !millis) {
return "never"
}
const SECOND = 1000
const MINUTE = SECOND * 60
const HOUR = MINUTE * 60
const DAY = HOUR * 24
const YEAR = DAY * 365
if (millis < MINUTE) {
return "just now"
}
let years = floor(millis / YEAR)
millis -= years * YEAR
let days = floor(millis / DAY)
millis -= days * DAY
let hours = floor(millis / HOUR)
millis -= hours * HOUR
let minutes = floor(millis / MINUTE)
if (years) {
return `${years} year${years > 1 ? "s" : ""} and ${days} day${day !== 1 ? "s" : ""} ago`
}
if (days) {
return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
}
if (hours) {
return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
}
return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
}
function roundBits(number) {
return ((number * 1000000 + 0.5) | 0) / 1000000
}
function rayTrace(x, y, z, shape) {
let cf, cd = 1e9; //Closest face and distance
let m; //Absolute distance to intersection point
let ix, iy, iz; //Intersection coords
let minX, minY, minZ, maxX, maxY, maxZ, min, max; //Bounds of face coordinates
let east = p.direction.x < 0
let top = p.direction.y < 0
let north = p.direction.z < 0
let verts = shape.verts
let faces = verts[0]
//Top and bottom faces
if (top) {
faces = verts[1]
}
if (p.direction.y) {
for (let face of faces) {
min = face.min
minX = min[0]
minZ = min[2]
max = face.max
maxX = max[0]
maxZ = max[2]
m = (y + face[1] - p.y) / p.direction.y
ix = m * p.direction.x + p.x
iz = m * p.direction.z + p.z
if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
cd = m; //Ray crosses bottom face
cf = top ? "top" : "bottom"
}
}
}
//West and East faces
if (east) {
faces = verts[4]
} else {
faces = verts[5]
}
if (p.direction.x) {
for (let face of faces) {
min = face.min
minY = min[1]
minZ = min[2]
max = face.max
maxY = max[1]
maxZ = max[2]
m = (x + face[0] - p.x) / p.direction.x
iy = m * p.direction.y + p.y
iz = m * p.direction.z + p.z
if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
cd = m
cf = east ? "east" : "west"
}
}
}
//South and North faces
if (north) {
faces = verts[2]
} else {
faces = verts[3]
}
if (p.direction.z) {
for (let face of faces) {
min = face.min
minX = min[0]
minY = min[1]
max = face.max
maxX = max[0]
maxY = max[1]
m = (z + face[2] - p.z) / p.direction.z
ix = m * p.direction.x + p.x
iy = m * p.direction.y + p.y
if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
cd = m
cf = north ? "north" : "south"
}
}
}
return [ cd, cf ]
}
let entPlayerCollided
let collidedWithMe
function entityRayTrace(x,y,z,returnIt){
entPlayerCollided = false
for(var i=0; i<world.entities.length; i++){
var ent = world.entities[i]
var ex = ent.x, ey = ent.y, ez = ent.z
var w2=ent.width/2, h2=ent.height/2, d2=ent.depth/2
if(x>ex-w2 && x<ex+w2 && y>ey-h2 && y<ey+h2 && z>ez-d2 && z<ez+d2){
if(returnIt) return ent
else return entHitbox.ent = ent
}
}
if(multiplayer){
for(var i in players){
var ent = players[i]
var ex = ent.x, ey = ent.y, ez = ent.z
var w2=ent.width/2, h2=ent.height/2, d2=ent.depth/2
if(x>ex-w2 && x<ex+w2 && y>ey-h2 && y<ey+h2 && z>ez-d2 && z<ez+d2){
if(returnIt){
entPlayerCollided = true
return ent
}else{
entHitbox.player = true
return entHitbox.ent = ent
}
}
}
}
var px = p.x, py = p.y, pz = p.z
var w2 = p.w/2, th = p.topH, bh = p.bottomH
collidedWithMe = x>px-p.w && x<px+p.w && y>py-bh && y<py+th && z>pz-w2 && z<pz+w2
}
function runRayTrace(x, y, z) {
let block = world.getBlock(x, y, z)
if (block && !(blockData[block].noHitbox && !(holding && blockData[holding].allHitbox))) {
let shape = blockData[block].shape
if(shape.hitbox) shape = shape.hitbox
let rt = rayTrace(x, y, z, shape)
if (rt[1] && rt[0] < hitBox.closest) {
hitBox.closest = rt[0]
hitBox.face = rt[1]
hitBox.pos = [ x, y, z ]
hitBox.shape = shape
crack.pos = [x, y, z]
crack.shape = shape
}
}
}
function lookingAt() {
// Checks blocks in front of the player to see which one they're looking at
hitBox.pos = null
hitBox.closest = 1e9
entHitbox.ent = null
entHitbox.player = false
if (p.spectator) {
return
}
let blockState = world.getBlock(p2.x, p2.y, p2.z)
if (blockState && !(blockData[blockState].noHitbox && !(holding && blockData[holding].allHitbox))) {
hitBox.pos = [ p2.x, p2.y, p2.z ]
hitBox.closest = 0
hitBox.shape = blockData[blockState].shape
if(hitBox.shape.hitbox) hitBox.shape = hitBox.shape.hitbox
crack.pos = [p2.x, p2.y, p2.z]
crack.shape = blockData[blockState].shape
return
}
let pd = p.direction
// Target block
let tx = round(pd.x * reach + p.x)
let ty = round(pd.y * reach + p.y)
let tz = round(pd.z * reach + p.z)
let minX = p2.x
let maxX = 0
let minY = p2.y
let maxY = 0
let minZ = p2.z
let maxZ = 0
for (let i = 0; i < reach + 1; i++) {
if (i > reach) {
i = reach
}
maxX = round(p.x + pd.x * i)
maxY = round(p.y + pd.y * i)
maxZ = round(p.z + pd.z * i)
if (maxX === minX && maxY === minY && maxZ === minZ) {
continue
}
if (minX !== maxX) {
if (minY !== maxY) {
if (minZ !== maxZ) {
runRayTrace(maxX, maxY, maxZ)
}
runRayTrace(maxX, maxY, minZ)
}
if (minZ !== maxZ) {
runRayTrace(maxX, minY, maxZ)
}
runRayTrace(maxX, minY, minZ)
}
if (minY !== maxY) {
if (minZ !== maxZ) {
runRayTrace(minX, maxY, maxZ)
}
runRayTrace(minX, maxY, minZ)
}
if (minZ !== maxZ) {
runRayTrace(minX, minY, maxZ)
}
if (hitBox.pos) {
return; //The ray has collided; it can't possibly find a closer collision now
}
var ex=maxX, ey=maxY, ez=maxZ
for(var e=0; e<1; e+=0.1){
ex += pd.x*0.1, ey += pd.y*0.1, ez += pd.z*0.1
entityRayTrace(ex,ey,ez)
if(entHitbox.ent){
hitBox.pos = null
return
}
}
minZ = maxZ
minY = maxY
minX = maxX
}
}
let inBox = function(x, y, z, w, h, d) {
let iy = y - h/2 - p.topH
let ih = h + p.bottomH + p.topH
let ix = x - w/2 - p.w
let iw = w + p.w*2
let iz = z - d/2 - p.w
let id = d + p.w*2
return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
}
let onBox = function(x, y, z, w, h, d) {
let iy = roundBits(y - h/2 - p.topH)
let ih = roundBits(h + p.bottomH + p.topH)
let ix = roundBits(x - w/2 - p.w)
let iw = roundBits(w + p.w*2)
let iz = roundBits(z - d/2 - p.w)
let id = roundBits(d + p.w*2)
return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
}
let takeDamage
function collided(x, y, z, vx, vy, vz, block) {
if(p.spectator) {
return false
}
let shape = blockData[block].shape
if(shape.hitbox) shape = shape.hitbox
let verts = shape.verts
let blockObj = blockData[block]
let px = roundBits(p.x - p.w - x)
let py = roundBits(p.y - p.bottomH - y)
let pz = roundBits(p.z - p.w - z)
let pxx = roundBits(p.x + p.w - x)
let pyy = roundBits(p.y + p.topH - y)
let pzz = roundBits(p.z + p.w - z)
let minX, minY, minZ, maxX, maxY, maxZ, min, max
//Top and bottom faces
let faces = verts[0]
if (vy <= 0) {
faces = verts[1]
}
if (!vx && !vz) {
for (let face of faces) {
min = face.min
minX = min[0]
minZ = min[2]
max = face.max
maxX = max[0]
maxZ = max[2]
if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
if (vy <= 0) {
p.onGround = true
/*var target = round((face[1] + y + p.bottomH) * 10000) / 10000
if(target - p.y < 1) p.y = target*/
p.y = round((face[1] + y + p.bottomH) * 10000) / 10000
return false
} else {
//if(blockObj.damage > takeDamage){
//takeDamage = blockObj.damage
//}
return true
}
}
}
return false
}
//West and East faces
if (vx < 0) {
faces = verts[4]
} else if (vx > 0) {
faces = verts[5]
}
if (vx) {
let col = false
for (let face of faces) {
min = face.min
minZ = min[2]
minY = min[1]
max = face.max
maxZ = max[2]
maxY = max[1]
if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
if (maxY - py > 0.5) {
p.canStepX = false
}
col = true
//if(blockObj.damage > takeDamage){
//takeDamage = blockObj.damage
//}
}
}
return col
}
//South and North faces
if (vz < 0) {
faces = verts[2]
} else if (vz > 0) {
faces = verts[3]
}
if (vz) {
let col = false
for (let face of faces) {
min = face.min
minX = min[0]
minY = min[1]
max = face.max
maxX = max[0]
maxY = max[1]
if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
if (maxY - py > 0.5) {
p.canStepZ = false
}
col = true
//if(blockObj.damage > takeDamage){
//takeDamage = blockObj.damage
//}
}
}
return col
}
}
let contacts = {
array: [],
size: 0,
add: function(x, y, z, block) {
if (this.size === this.array.length) {
this.array.push([ x, y, z, block ])
} else {
this.array[this.size][0] = x
this.array[this.size][1] = y
this.array[this.size][2] = z
this.array[this.size][3] = block
}
this.size++
},
clear: function() {
this.size = 0
},
}
let blocks = []
let resolveContactsAndUpdatePosition = function(now) {
let pminX = p2.x - 1
let pmaxX = p2.x + 1
let pminY = p2.y - 2
let pmaxY = p2.y + 1
let pminZ = p2.z - 1
let pmaxZ = p2.z + 1
let block = null
let vel = p.velocity
let blocksSize = 0
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = world.getBlock(x, y, z)
if (block && blockData[block].solid && !blockData[block].liquid) {
contacts.add(x, y, z, block)
}
if (block) {
if(blocks[blocksSize]){
blocks[blocksSize][0] = x
blocks[blocksSize][1] = y
blocks[blocksSize][2] = z
blocks[blocksSize][3] = block
}else{
blocks.push([x,y,z,block])
}
blocksSize ++
}
}
}
}
p.previousX = p.x
p.previousY = p.y
p.previousZ = p.z
var ontouch
var x
var y
var z
var damageBlock
takeDamage = 0
liquid = false
wet = false
powder = false
//collisions for ontouch
for (let i = 0; i < blocksSize; i++) {
block = blocks[i]
x = block[0]
y = block[1]
z = block[2]
if(block[0] === p2.x && block[2] === p2.z && blockData[block[3]].ontouch){
ontouch = blockData[block[3]].ontouch
}
if(blockData[block[3]].liquid) {
liquid = true
}
if(blockData[block[3]].wet){
wet = true
}
if(!blockData[block[3]].solid && blockData[block[3]].powder){
powder = true
}
let d = blockData[block[3]].damage
if(d && d>takeDamage/* && collided(x,y,z,0,0,0,block[3])*/) {
takeDamage = d
damageBlock = blockData[block[3]]
}
}
//Check collisions in the Y direction
p.onGround = false
p.canStepX = false
p.canStepZ = false
p.y += vel.y
for (let i = 0; i < contacts.size; i++) {
block = contacts.array[i]
if (collided(block[0], block[1], block[2], 0, vel.y, 0, block[3])) {
p.y = p.previousY
vel.y = 0
break
}
}
if (p.y === p.previousY && !p.flying) {
p.canStepX = true
p.canStepZ = true
}
var sneakLock = false, sneakSafe = false
if (p.sneaking) {
for (let i = 0; i < contacts.size; i++) {
block = contacts.array[i]
if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
sneakLock = true
break
}
}
}
//Check collisions in the X direction
p.x += vel.x
for (let i = 0; i < contacts.size; i++) {
block = contacts.array[i]
if (collided(block[0], block[1], block[2], vel.x, 0, 0, block[3])) {
if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
continue
}
p.x = p.previousX
vel.x = 0
break
}
if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
sneakSafe = true
}
}
if (sneakLock && !sneakSafe) {
p.x = p.previousX
vel.x = 0
}
sneakSafe = false
//Check collisions in the Z direction
p.z += vel.z
for (let i = 0; i < contacts.size; i++) {
block = contacts.array[i]
if (collided(block[0], block[1], block[2], 0, 0, vel.z, block[3])) {
if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
continue
}
p.z = p.previousZ
vel.z = 0
break
}
if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
sneakSafe = true
}
}
if (sneakLock && !sneakSafe) {
p.z = p.previousZ
vel.z = 0
}
//Minimun height: -40
if(!survival && p.y <= -40){
p.y = -40
p.onGround = true
}
if (!p.flying) {
if (liquid){
//p.jumpSpeed = 0.135;
p.gravityStength = p.liquidGravityStength;
if (controlMap.jump.pressed){
p.velocity.y += 0.08
}
if (controlMap.sneak.pressed){
p.velocity.y -= 0.08
}
p.velocity.y *= 0.7
p.velocity.x *= 0.7
p.velocity.z *= 0.7
}else{
p.gravityStength = p.defaultGravityStength
}
if(powder){
p.velocity.y *= 0.4
p.velocity.x *= 0.4
p.velocity.z *= 0.4
if(controlMap.jump.pressed) p.velocity.y += 0.13
}
let drag = liquid ? 0.7 : (p.onGround ? 0.5 : 0.85)
if(blockData[standingOn].slide) drag = blockData[standingOn].slide
p.velocity.z += (p.velocity.z * drag - p.velocity.z)
p.velocity.x += (p.velocity.x * drag - p.velocity.x)
} else {
let drag = 0.85
p.velocity.z += (p.velocity.z * drag - p.velocity.z)
p.velocity.x += (p.velocity.x * drag - p.velocity.x)
p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y)
if (p.onGround && !p.spectator) {
p.flying = false
}
}
p.lastUpdate = performance.now()
contacts.clear()
lookingAt()
if(takeDamage > 0 && now - lastBlockHarm > 500 && survival){
lastBlockHarm = now
dieMessage = damageBlock.dieMessage ? damageBlock.dieMessage() : (username+" died because of "+damageBlock.name+". You should avoid it next time.")
damage(takeDamage, dieMessage)
}
p.touchingBurnBlock = damageBlock && damageBlock.burnPlayer && true
if(ontouch){
ontouch(x, y, z)
}
}
let runGravity = function() {
if (p.flying) {
return
}
if(p.onGround) {
let fall = p.lastY - p.y
p.lastY = p.y
var block = standingOn
if(fall > 3 && survival && !liquid) {
var fallType = fall > 6 ? "bigfall" : "smallfall"
damage(Math.floor(fall-3), username+" fell from a high place. You fell "+Math.round(fall)+" blocks.", false, fallType)//Math.floor( (p.velocity.y * p.velocity.y * 8));
}
if(p.velocity.y < -0.1 && block){
blockParticles(block, p.x,p.y-p.bottomH,p.z,10)
blockSound(block, "step", p.x,p.y,p.z, 1)
}
if(blockData[block].bounciness && p.velocity.y < -0.2){
p.velocity.y *= -blockData[block].bounciness
}else{
if(controlMap.jump.pressed) {
p.velocity.y = p.jumpSpeed
p.onGround = false
if(survival){
p.foodExhaustion += p.sprinting ? 0.2 : 0.05
}
} else {
p.velocity.y = 0
}
}
} else {
p.velocity.y += p.gravityStength
if(p.velocity.y < -p.maxYVelocity) {
p.velocity.y = -p.maxYVelocity
}
}
if(liquid !== lastLiquid){
lastLiquid = liquid
if(liquid && wet){
playSound("liquid.splash")
}else if(!wet){
//playSound("liquid.exit")
}
}
}
let defineWorld = function(tick) {
let tickStart = performance.now()
if(tick) world.tick()
analytics.totalTickTime += performance.now() - tickStart
let renderStart = performance.now()
p2.x = round(p.x)
p2.y = round(p.y)
p2.z = round(p.z)
p3.x = p.x
p3.y = p.y
p3.z = p.z
p3.ry = -p.ry
p3.rx = -p.rx
p3.sneaking = p.sneaking
p3.survival = survival
p3.username = username || ""
p3.time = worldTime
p3.harmEffect = harmEffect
p3.crackPos = crack.pos
p3.crack = crack.idx
p3.burning = p.burning
p3.holding = holding || 0
p3.walking = p.walking
p3.sprinting = p.sprinting
p3.punchEffect = p.punchEffect
updateTextures()
let prevX
let prevY
let prevZ
let prevRotX
let prevRotY
let prevPreviousX
let prevPreviousY
let prevPreviousZ
if(p.thirdPerson){
prevX = p.x
prevY = p.y
prevZ = p.z
prevRotX = p.rx
prevRotY = p.ry
prevPreviousX = p.previousX
prevPreviousY = p.previousY
prevPreviousZ = p.previousZ
var d = p.thirdPerson === "front" ? 4 : -4
p.x += p.direction.x*d
p.y += p.direction.y*d
p.z += p.direction.z*d
p.previousX += p.direction.x*d
p.previousY += p.direction.y*d
p.previousZ += p.direction.z*d
if(p.thirdPerson === "front"){
p.ry += Math.PI
p.rx = -p.rx
}
}
p.setDirection()
world.render()
if(p.thirdPerson){
p.x = prevX
p.y = prevY
p.z = prevZ
p.rx = prevRotX
p.ry = prevRotY
p.previousX = prevPreviousX
p.previousY = prevPreviousY
p.previousZ = prevPreviousZ
if(p.thirdPerson === "front") p.setDirection() // make it correct
}
analytics.totalRenderTime += performance.now() - renderStart
}
var ambientDist = 16 + (1*10)
function updateAmbient(){ //todo: some sounds have different attenuation thingies so update this with that
let pminX = p2.x - ambientDist
let pmaxX = p2.x + ambientDist
let pminY = p2.y - ambientDist
let pmaxY = p2.y + ambientDist
let pminZ = p2.z - ambientDist
let pmaxZ = p2.z + ambientDist
for(var i in currentAmbient) currentAmbientVolume[i] = 0
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = world.getBlock(x, y, z)
var blockObj = blockData[block]
if (block && blockObj.ambientSound) {
if(currentAmbientVolume[blockObj.name]){
var v = posSound(x,y,z)
if(v > currentAmbientVolume[blockObj.name]){
currentAmbientVolume[blockObj.name] = v
}
}else{
var v = posSound(x,y,z)
currentAmbientVolume[blockObj.name] = v
}
}
}
}
}
for(var i in currentAmbientVolume){
var v = currentAmbientVolume[i] * settings.volume
if(currentAmbient[i]){
currentAmbient[i].gain.value = v
if(v <= 0){
currentAmbient[i].source.stop()
delete currentAmbient[i]
}
}else{
var blockObj = blockData[blockIds[i]]
playSound(blockObj.ambientSound, 0, v, null, null, true, (source, gainNode) => {currentAmbient[i] = gainNode; currentAmbient[i].source = source})
}
}
}
let renderPlayer = function(){
if(p.thirdPerson){
p.character.render()
}else{
//p.hand.render()
}
}
let updtPlayer = function(){
p.character.setPos(p.x,p.y,p.z)
p.character.setRot(-p.rx,-p.ry)
p.character.burning = p.burning
p.character.sneaking = p.sneaking
p.character.walking = p.walking
p.character.sprinting = p.sprinting
if(p.thirdPerson) p.character.holding = holding || 0
p.character.punchEffect = p.punchEffect + 3
p.character.update()
//p.hand.update()
}
let controls = function() {
move.x = 0
move.z = 0
if(controlMap.forward.pressed) move.z += p.speed
if(controlMap.backward.pressed) move.z -= p.speed
if(controlMap.left.pressed) move.x += p.speed
if(controlMap.right.pressed) move.x -= p.speed
if (p.flying) {
if(controlMap.jump.pressed) p.velocity.y += 0.09
if(controlMap.sneak.pressed) p.velocity.y -= 0.09
}
if(Key.arrowleft) p.ry -= 0.1
if(Key.arrowright) p.ry += 0.1
if(Key.arrowup) p.rx += 0.1
if(Key.arrowdown) p.rx -= 0.1
if (!p.sprinting && controlMap.sprint.pressed && !p.sneaking && controlMap.forward.pressed) {
p.FOV(settings.fov + 10, 250)
p.sprinting = true
}
if(p.sprinting && p.food > 6) {
move.x *= p.sprintSpeed
move.z *= p.sprintSpeed
if(survival)p.foodExhaustion += (p.speed * p.sprintSpeed)*0.1
}
if(p.flying) {
move.x *= p.flySpeed
move.z *= p.flySpeed
}
if (!move.x && !move.z) {
if (p.sprinting) {
p.FOV(settings.fov, 100)
}
p.sprinting = false
} else if(abs(move.x) > 0 && abs(move.z) > 0) {
move.x *= move.ang
move.z *= move.ang
}
p.walking = (move.x || move.z) && true
//Update the velocity, rather than the position.
let co = cos(p.ry)
let si = sin(p.ry)
let speedFactor = blockData[standingOn].speedFactor
let friction = liquid ? 0.4 : (p.onGround ? 1 : 0.3)
if(speedFactor){
friction *= speedFactor
}
p.velocity.x += (co * move.x - si * move.z) * friction
p.velocity.z += (si * move.x + co * move.z) * friction
const TAU = Math.PI * 2
const PI1_2 = Math.PI / 2
while(p.ry > TAU) p.ry -= TAU
while(p.ry < 0)   p.ry += TAU
if(p.rx > PI1_2)  p.rx = PI1_2
if(p.rx < -PI1_2) p.rx = -PI1_2
}
function box2(sides, tex, shape) {
if (blockFill && !shape) {
let i = 0
for (let side in Block) {
if (sides & Block[side]) {
vertexAttribPointer("aVertex", program3D, "aVertex", 3, sideEdgeBuffers[Sides[side]])
vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
}
i++
}
}else if(shape){
for (let i = 0; i < shape.size; i++) {
vertexAttribPointer("aVertex", program3D, "aVertex", 3, shape.buffer)
vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]])
gl.drawArrays(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0) //doesn't work
}
}
if (blockOutlines) {
gl.disableVertexAttribArray(glCache.aSkylight)
gl.disableVertexAttribArray(glCache.aBlocklight)
gl.vertexAttrib1f(glCache.aSkylight, 1.0)
gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
vertexAttribPointer("aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
vertexAttribPointer("aTexture", program3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox])
for (let i = 0; i < hitBox.shape.size; i++) {
gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
}
}
}
function block2(x, y, z, t, camera) {
if (camera) {
camera.transformation.translate(x, y, z)
uniformMatrix("view3d", program3D, "uView", false, camera.getMatrix())
} else {
//copyArr(modelView, matrix)
trans(modelView, x, y, z)
matMult()
trans(modelView, -x, -y, -z)
transpose(matrix)
uniformMatrix("view3d", program3D, "uView", false, matrix)
}
box2(0xff, blockData[t].textures)
}
function changeWorldBlock(t, drop) {
p.punchEffect = 10 //easy to understand
let pos = hitBox.pos
if(pos && pos[1] >= 0 && pos[1] < maxHeight) {
let shape = t && blockData[t].shape
if (t && shape.rotate) {
let pi = Math.PI / 4
if (p.ry <= pi) {} // North; default
else if (p.ry < 3 * pi) {
t |= WEST
} else if (p.ry < 5 * pi) {
t |= SOUTH
} else if (p.ry < 7 * pi) {
t |= EAST
}
}
if (t && shape.flip && hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y) % 1 < 0.5)) {
t |= FLIP
}
var prevBlock = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
var prevTags = world.getTags(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t)
if(drop){
let block = prevBlock
let theDrop = blockData[prevBlock].drop
let amount = blockData[prevBlock].dropAmount
var canDrop = handBreakable.includes(blockData[prevBlock].type)
if(holding && breakTypes[blockData[prevBlock].type] && breakTypes[blockData[prevBlock].type].includes(blockData[holding].name)) canDrop = true
if(!blockData[prevBlock].type) canDrop = true
if(canDrop){
if(amount.length === 2){
amount = round(rand(amount[0], amount[1]))
}
if(holding && blockData[holding].shears && blockData[prevBlock].dropSelfWhenSheared){
if(blockData[prevBlock].shearDropAmount){
amount = blockData[prevBlock].shearDropAmount
}
}else{
if(typeof theDrop === "number") block = theDrop
else if(typeof theDrop === "function"){
block = blockIds[theDrop()]
}else if(Array.isArray(theDrop)){
block = theDrop
}else if(theDrop) block = blockIds[theDrop]
else if(blockData[prevBlock].noDrop) block = 0
}
if(block && pos){
if(Array.isArray(block)){//drop multiple items
for(var b=0; b<block.length; b++){
var bId = blockIds[block[b]]
for(var i=0; i<amount; i++){
world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, bId, true))
}
}
}else{
for(var i=0; i<amount; i++){
world.addEntity(new Item(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, 0, 0, block, true))
}
}
}
}
}
if (t) {
p.lastPlace = Date.now()
} else {
p.lastBreak = Date.now()
if(!prevBlock) return
blockParticles(prevBlock,hitBox.pos[0],hitBox.pos[1],hitBox.pos[2],30)
if(blockData[prevBlock].onbreak){
blockData[prevBlock].onbreak(hitBox.pos[0],hitBox.pos[1],hitBox.pos[2], prevBlock, prevTags)
}
blockSound(prevBlock, "dig", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
if(blockData[prevBlock].experience) world.addEntity(new ExperienceOrb(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], blockData[prevBlock].experience))
var breakType = blockData[prevBlock].type
if(survival && holding && blockData[holding].pickaxe) {
inventory.hotbar[inventory.hotbarSlot].durability --
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
if(survival && holding && blockData[holding].sword) {
inventory.hotbar[inventory.hotbarSlot].durability -= 2
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
if(survival && holding && blockData[holding].shovel) {
inventory.hotbar[inventory.hotbarSlot].durability -= 1
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
if(survival && holding && blockData[holding].axe) {
inventory.hotbar[inventory.hotbarSlot].durability -= 1
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
if(survival && holding && blockData[holding].hoe && breakType !== "plant2") {
inventory.hotbar[inventory.hotbarSlot].durability -= 1
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
}
}
}
function replaceItem(id){
inventory.hotbar[inventory.hotbarSlot] && (inventory.hotbar[inventory.hotbarSlot].id = id)
holding = inventory.hotbar[inventory.hotbarSlot].id
updateHUD = true
}
function getPosition(){
let pos = hitBox.pos, x = pos[0], y = pos[1], z = pos[2]
let side = false
switch(hitBox.face) {
case "top":
y += 1
break
case "bottom":
y -= 1
break
case "south":
z -= 1
side = true
break
case "north":
z += 1
side = true
break
case "west":
x -= 1
side = true
break
case "east":
x += 1
side = true
break
}
pos[0] = x
pos[1] = y
pos[2] = z
return pos
}
function useDurability(d){
if(survival && inventory.hotbar[inventory.hotbarSlot]){
inventory.hotbar[inventory.hotbarSlot].durability -= d
inventory.hotbar[inventory.hotbarSlot].animation = 1.5
updateHUD = true
}
}
function minusOne(){
inventory.hotbar[inventory.hotbarSlot].amount --
updateHUD = true
}
function newWorldBlock() {
let pos = hitBox.pos,x,y,z, face = hitBox.face
if(pos) x = pos[0], y = pos[1], z = pos[2]
let cblock = pos ? world.getBlock(x, y, z) : 0
var pholding = holding
if(holding && blockData[holding].useAs){
var useAs = blockData[holding].useAs
if(typeof useAs === "function"){
useAs = useAs(x,y,z,cblock,face)
if(blockIds[useAs]){
holding = blockIds[useAs]
}
}else{
holding = blockIds[useAs]
}
}
if(cblock){
if(hitBox.pos){
let onclick = blockData[cblock].onclick
if(onclick && !Key.shift){
if(!onclick(x, y, z)){p.lastPlace = Date.now(); return} //if it doesn't return true
}
}
if(holding && blockData[holding].shovel){
if(cblock === blockIds.grass || cblock === blockIds.dirt || cblock === blockIds.rootedDirt || cblock === blockIds.mycelium || cblock === blockIds.podzol){
world.setBlock(x,y,z,blockIds.grass | TALLCROSS)
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
return p.lastPlace = Date.now()
}
if(blockData[cblock].campfire){
world.setBlock(x,y,z,blockData[cblock].id | SLAB)
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
return p.lastPlace = Date.now()
}
}
if(holding && cblock && blockData[holding].axe){
var name = blockData[cblock].name
name = name[0].toUpperCase() + name.substring(1)
name = "stripped"+name
if(blockIds[name]){
world.setBlock(x,y,z,blockIds[name])
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
return p.lastPlace = Date.now()
}
}
if(holding && cblock && blockData[holding].hoe){
if((blockData[cblock].name === "grass" || cblock === blockIds.dirt) && !world.getBlock(x,y+1,z)){
world.setBlock(x,y,z,blockIds.farmland)
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
return p.lastPlace = Date.now()
}
if(cblock === blockIds.rootedDirt){
world.setBlock(x,y,z,blockIds.dirt)
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
world.addEntity(new Item(x, y+0.5, z, 0, 0, 0, blockIds.hangingRoots, true))
return p.lastPlace = Date.now()
}
}
if(holding && cblock && blockData[holding].shears){
if(cblock === blockIds.pumpkin){
world.setBlock(x,y,z,blockIds.carvedPumpkin)
var h = inventory.hotbar[inventory.hotbarSlot]
h.durability --
h.animation = 1.5
for(var n=0; n<4; n++)world.addEntity(new Item(x, y+0.5, z, 0, 0, 0, blockIds.pumpkinSeeds, true))
return p.lastPlace = Date.now()
}
}
}
if(blockData[holding]){
if(blockData[holding].useAnywhere ? true : hitBox.pos){
let onuse = blockData[holding].onuse
if(onuse){ //items like flint and steel can't be placed but lights stuff
if(survival && blockData[holding].minusOnUse){inventory.hotbar[inventory.hotbarSlot].amount --; updateHUD = true}
if(!onuse(x,y,z, cblock, replaceItem, useDurability, minusOne)){p.lastPlace = Date.now(); return}
}
}
}
var item = holding && blockData[holding].item
if(item && blockData[holding].canPlace && blockData[holding].canPlace(cblock)){
item = false
}
if(!hitBox.pos || !holding || item) {
return
}
let side = false
switch(hitBox.face) {
case "top":
y += 1
break
case "bottom":
y -= 1
break
case "south":
z -= 1
side = true
break
case "north":
z += 1
side = true
break
case "west":
x -= 1
side = true
break
case "east":
x += 1
side = true
break
}
var hitboxBlock = world.getBlock(x, y, z)
var blocking = blockData[holding].solid && inBox(x, y, z, 1, 1, 1)
var canPlace = (!hitboxBlock) || (blockData[hitboxBlock].noHitbox)
if (!blocking && canPlace) {
var block = holding
var prevBlockMode = blockMode;
var under = world.getBlock(x,y-1,z)
var onPot = !side && blockData[under] && blockData[under].pot
if(blockData[holding].potCross && onPot){
blockMode = POTCROSS
}else if(blockData[holding].crossShape){
if(onPot && blockIds[blockData[holding].name+"Pot"]){
block = blockIds[blockData[holding].name+"Pot"]
blockMode = POTCROSS
}else{
blockMode = CROSS
}
}
if(blockData[holding].sideCross){
if(side){
blockMode = CUBE
}else if(hitBox.face === "bottom"){
blockMode = SLAB
}else blockMode = CROSS
}
if(blockData[holding].tallcrossShape){
blockMode = TALLCROSS
}
if(blockData[holding].door && blockMode !== SLAB){
blockMode = DOOR
}
if(blockData[holding].torch){
blockMode = TORCH
if(side) blockMode = SLAB
}
if(blockData[holding].lantern){
if(world.getBlock(x,y+1,z)){
blockMode = LANTERNHANG
}else{
blockMode = LANTERN
}
}
if(blockData[holding].beacon){
blockMode = BEACON
}
if(blockData[holding].cactus && blockMode !== POTCROSS){
blockMode = CACTUS
}
if(blockData[holding].pane){
blockMode = PANE
}
if(blockData[holding].portal){
blockMode = PORTAL
}
if(blockData[holding].wallFlat){
blockMode = WALLFLAT
}
if(blockData[holding].trapdoor){
if(side){
blockMode = TRAPDOOROPEN
}else{
blockMode = TRAPDOOR
}
}
if(blockData[holding].chain){
if(side)blockMode = SLAB
else blockMode = CHAIN
}
if(blockData[holding].button){
blockMode = BUTTON
}
if(blockData[holding].pot){
blockMode = POT
}
if(blockData[holding].carpet){
blockMode = CARPET
}
if(blockData[cblock].name === "endPortalFrame" && blockData[holding].eyeOfEnder){
blockMode = SLAB
}
if(blockData[holding].name === "endRod"){
if(side){
blockMode = SLAB
}else{
blockMode = CUBE
}
}
if(blockData[holding].barrel){
if(side) blockMode = SLAB
else if(hitBox.face === "bottom") blockMode = STAIR
else blockMode = CUBE
}
if(side && blockIds[blockData[block].name+"SW"]){
block = blockIds[blockData[block].name+"SW"]
}
if(blockData[holding].layers){
var b = world.getBlock(pos[0],pos[1],pos[2])
let layer = 0
if((b & LAYER1) === LAYER1) layer = 1
if((b & LAYER2) === LAYER2) layer = 2
if((b & LAYER3) === LAYER3) layer = 3
if((b & LAYER4) === LAYER4) layer = 4
if((b & LAYER5) === LAYER5) layer = 5
if((b & LAYER6) === LAYER6) layer = 6
if((b & LAYER7) === LAYER7) layer = 7
if((b & LAYER8) === LAYER8) layer = 8
if(((b & blockIds.snow) === blockIds.snow) && layer > 0 && layer < 8){
x = pos[0], y = pos[1], z = pos[2]
layer ++
switch(layer){
case 2:
blockMode = LAYER2
break
case 3:
blockMode = LAYER3
break
case 4:
blockMode = LAYER4
break
case 5:
blockMode = LAYER5
break
case 6:
blockMode = LAYER6
break
case 7:
blockMode = LAYER7
break
case 8:
blockMode = LAYER8
break
}
}else{
blockMode = LAYER1
}
}
pos[0] = x
pos[1] = y
pos[2] = z
changeWorldBlock(block < isCube ? (block | blockMode) : block)
if(survival) inventory.hotbar[inventory.hotbarSlot].animation = 1.5 //animation because you used one of the blocks
blockMode = prevBlockMode;
if(survival && inventory.hotbar[inventory.hotbarSlot]){
inventory.hotbar[inventory.hotbarSlot].amount --;
updateHUD = true
}
//play sound
blockSound(block, "place", x,y,z)
}
holding = pholding
}
function entClick(){
p.punchEffect = 10
let ent = entHitbox.ent
if(!ent) return
var block = blockData[holding || 0]
var holdObj = inventory.hotbar[inventory.hotbarSlot]
var atime = block.attackTime
var time = (Date.now() - p.lastBreak) / 1000 * tickSpeed
var attackDamage = (block && block.attackDamage) || 0
var damage, critical
if(attackDamage){
damage = atime ? (0.2 + ((time + 0.5) / atime) ** 2 * 0.8) : 1
if(p.velocity.y < 0 && !p.onGround && !liquid && !p.flying && !p.sprinting && damage > 0.848) critical = true
damage = max(min(damage, 1), 0.2) * attackDamage
if(critical) damage *= 1.5
}else damage = 1
if(entHitbox.player){
var pd = p.direction
if (worldSettings.pvp) {
send({type:"hit", username:username, damage:damage, velx:pd.x/2, velz:pd.z/2}, ent.id)
}
}else{
if(ent.onhit){
ent.onhit(damage)
var pd = p.direction
ent.velx += pd.x / 2
ent.velz += pd.z / 2
}
}
if(block.pickaxe){
holdObj.durability -= 2
holdObj.animation = 1.5
}
if(block.sword){
holdObj.durability --
holdObj.animation = 1.5
}
if(block.shovel){
holdObj.durability -= 2
holdObj.animation = 1.5
}
if(block.axe){
holdObj.durability -= 2
holdObj.animation = 1.5
}
if(block.pickaxe || block.sword || block.shovel || block.axe){
attackCooldownStart = Date.now()
attackCooldownTime = atime
}
console.log(damage)
p.foodExhaustion += 0.1
p.lastBreak = Date.now()
}
function cracks(){
var now = performance.now()
var block = hitBox.pos ? world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) : 0
var touchBreak = pTouch.touching && pTouch.canDig && Date.now() - pTouch.touchStart > touchMoveLimit
var breaking = ((controlMap.break.pressed && !Key.control) || touchBreak) && block && (now - crack.delayStart >= crack.delayBetween)
if(!arrayValues(crack.prevPos, crack.pos)){
crack.prevPos = crack.pos
crack.soundTimer = 0
crack.delayStart = now
crack.breakStart = now
}
if(breaking){
var breakTime = blockData[block].breakTime
var breakType = blockData[block].type
if(holding && blockData[holding].shears && blockData[block].shearBreakTime){
breakTime = blockData[block].shearBreakTime
}
if(holding && (blockData[holding].pickaxe || (blockData[holding].shovel && breakType === "ground") || (blockData[holding].axe && breakType === "wood") || (blockData[holding].hoe && breakType === "plant2"))){
breakTime /= blockData[holding].mineSpeed
}
if(inWater === 1){
breakTime *= 5
if(!p.onGround) breakTime *= 5
}
let prog = map(now, crack.breakStart,crack.breakStart+breakTime, 0,1)
crack.idx = floor(prog * crack.length)
crack.tex = crack[crack.idx]
pTouch.digProg = prog
crack.soundTimer ++
if(crack.soundTimer > 15){
crack.soundTimer -= 15
blockSound(block, "breaking", hitBox.pos[0], hitBox.pos[1], hitBox.pos[2])
var x = hitBox.pos[0], y = hitBox.pos[1], z = hitBox.pos[2]
switch(hitBox.face) {
case "top":
y += 0.5
break
case "bottom":
y -= 0.5
break
case "south":
z -= 0.5
break
case "north":
z += 0.5
break
case "west":
x -= 0.5
break
case "east":
x += 0.5
break
}
blockParticles(block, x,y,z, 4, "breaking")
p.punchEffect = 10
}
if(crack.idx >= crack.length){
changeWorldBlock(0, true)
p.foodExhaustion += 0.005
}
}else{
crack.idx = -1
crack.breakStart = now
pTouch.digProg = 0
}
if(!controlMap.break.pressed){
crack.delayStart = now
}
}
// REPLACE THE EXPLODE FUNCTION IN preview.html WITH THIS BELOW
var nonExplodes = [
  blockIds.bedrock,
  blockIds.barrier,
  blockIds.endPortalFrame,
  blockIds.obsidian,
  blockIds.netheriteBlock,
]
function explode(x,y,z, r, liquid){
/*world.setBlock(x,y,z,blockIds.air);
for(var i=radius; i>0; i--){
sphereoidAt(x,y,z,i,i,i, blockIds.air)
}*/
//ball(x,y,z,r,r,r,0)
if(!liquid)world.setBlock(x,y,z, 0)
let w2 = r * r
let h2 = w2
let d2 = w2
for (let Y = -r; Y < r; Y++) {
for (let X = -r; X <= r; X++) {
for (let Z = -r; Z <= r; Z++) {
let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
if (n < 1) {
if(world.getBlock(X + x, Y + y, Z + z) === blockIds.tnt){
blockData[blockIds.tnt].explode(X+x,Y+y,Z+z, "explosion")
}
if(Math.random() > 0.5){
var time = Math.random()*1000
if(time < 10){
world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z))
}else{
setTimeout(() => world.particles.push(new ExplodeParticle(X + x, Y + y, Z + z)), time)
}
}
if(worldSettings.tntExplode && nonExplodes.indexOf( world.getBlock(X + x, Y + y, Z + z) ) === -1 ) {
if(!liquid)world.setBlock(X + x, Y + y, Z + z, 0)
}
}
}
}
}
for(var i=0; i<world.entities.length; i++){
var ent = world.entities[i]
var dist = dist3(x,y,z, ent.x, ent.y, ent.z)
if(dist <= r){
var X = ent.x - x; ent.velx += ((Math.sign(X)*r)-X)/5
var Y = ent.y - y; ent.vely += ((Math.sign(Y)*r)-Y)/5
var Z = ent.z - z; ent.velz += ((Math.sign(Z)*r)-Z)/5
if(ent.onhit){
var damageTook = round((r - dist) * 6)
ent.onhit(damageTook)
}
}
}
var p = player
var dist = dist3(x,y,z, p.x, p.y, p.z)
if(!p.spectator && dist <= r){
var X = p.x - x; p.velocity.x += ((Math.sign(X)*r)-X)/5
var Y = p.y - y; p.velocity.y += ((Math.sign(Y)*r)-Y)/5
var Z = p.z - z; p.velocity.z += ((Math.sign(Z)*r)-Z)/5
if(survival){
var damageTook = round((r - dist) * 6)
damage(damageTook, username+" blew up.")
}
}
explodeSound(x,y,z)
}
// REPLACE THE EXPLODE FUNCTION IN preview.html WITH THE ABOVE FUNCTION
  
  
function fall(x,y,z,b){
if(!worldSettings.blocksFall || world.getBlock(x,y-1,z)) return
setTimeout(() => {
world.setBlock(x,y,z, 0)
world.addEntity(new BlockEntity(b, x,y,z, true))
}, tickTime)
}
function needsSupportingBlocks(x,y,z, b){ // if block under is gone, dissapear
var under = world.getBlock(x,y-1,z)
if(!under || !blockData[under].solid){
setTimeout(() => {
world.setBlock(x,y,z, 0)
world.addEntity(new Item(x,y,z,0,0,0,b,true))
blockParticles(b,x,y,z,30)
blockSound(b, "dig", x,y,z)
}, tickTime)
}
}
function blockParticles(block,x,y,z,amount, type){
for(var i=0; i<amount; i++) world.particles.push(new BlockParticle(blockData[block].textures[2], x,y,z, type))
}
// Save the coords for a small sphere used to carve out caves
let sphere;
{
let blocks = []
let radius = 3.5
let radsq = radius * radius
for (let i = -radius; i <= radius; i++) {
for (let j = -radius; j <= radius; j++) {
for (let k = -radius; k <= radius; k++) {
if (i*i + j*j + k*k < radsq) {
blocks.push(i|0, j|0, k|0)
}
}
}
}
sphere = new Int8Array(blocks)
}
function isCave(x, y, z) {
// Generate a 3D rigid multifractal noise shell.
// Then generate another one with different coordinates.
// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.
// This is extremely slow, and requires generating 2 noise values for every single block in the world.
// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.
let smooth = 0.02
let caveSize = 0.0055
let cave1 = abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < caveSize
let cave2 = abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < caveSize
return (cave1 && cave2)
}
function carveSphere(x, y, z) {
if (y > 3) {
for (let i = 0; i < sphere.length; i += 3) {
world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true)
}
}
}
let renderedChunks = 0
function getBlock(x, y, z, blocks) {
return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
}
/**
* Returns a 1 if the face is exposed and should be drawn, or a 0 if the face is hidden
* 
* @param {number} x - The X coordinate of the block that may be covering a face
* @param {number} y - The Y coordinate of the block that may be covering a face
* @param {number} z - The Z coordinate of the block that may be covering a face
* @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
* @param {number} type - The blockstate of the block that's being considered for face culling
* @param {function} func - The function that can be called to return a block from the blocks collection
*/
function hideFace(x, y, z, blocks, type, func, sourceDir, dir, section) {
let block = func.call(world, x, y, z, blocks)
if (!block) {
return 1
}
let data = blockData[block]
let sourceData = blockData[type]
let sourceRange = 3
let hiderRange = 3
if (func !== getBlock || screen === "loading") {
// getBlock is only used during the optimize phase of worldGen
sourceRange = sourceData.shape.cull[sourceDir]
hiderRange = data.shape.cull[dir]
}
if ((sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent || data.transparent && data.shadow) {
return 1
}
return 0
}
let getShadows = {
shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
ret: [],
blocks: [],
top: function(x, y, z, block) { // Actually the bottom... How did these get flipped?
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
blocks[1] = blockData[getBlock(x, y-1, z-1, block)].shadow
blocks[2] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
blocks[4] = blockData[getBlock(x, y-1, z, block)].shadow
blocks[5] = blockData[getBlock(x+1, y-1, z, block)].shadow
blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
blocks[7] = blockData[getBlock(x, y-1, z+1, block)].shadow
blocks[8] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.75
ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.75
ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.75
ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.75
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 0.75
}
return ret
},
bottom: function(x, y, z, block) { // Actually the top
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
blocks[1] = blockData[getBlock(x, y+1, z-1, block)].shadow
blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
blocks[3] = blockData[getBlock(x-1, y+1, z, block)].shadow
blocks[4] = blockData[getBlock(x, y+1, z, block)].shadow
blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow
ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 1
}
return ret
},
north: function(x, y, z, block) {
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
blocks[1] = blockData[getBlock(x, y-1, z+1, block)].shadow
blocks[2] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
blocks[3] = blockData[getBlock(x-1, y, z+1, block)].shadow
blocks[4] = blockData[getBlock(x, y, z+1, block)].shadow
blocks[5] = blockData[getBlock(x+1, y, z+1, block)].shadow
blocks[6] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
blocks[7] = blockData[getBlock(x, y+1, z+1, block)].shadow
blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow
ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 0.95
}
return ret
},
south: function(x, y, z, block) {
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
blocks[3] = blockData[getBlock(x, y-1, z-1, block)].shadow
blocks[4] = blockData[getBlock(x, y, z-1, block)].shadow
blocks[5] = blockData[getBlock(x, y+1, z-1, block)].shadow
blocks[6] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
blocks[7] = blockData[getBlock(x+1, y, z-1, block)].shadow
blocks[8] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 0.95
}
return ret
},
east: function(x, y, z, block) {
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x+1, y-1, z-1, block)].shadow
blocks[1] = blockData[getBlock(x+1, y, z-1, block)].shadow
blocks[2] = blockData[getBlock(x+1, y+1, z-1, block)].shadow
blocks[3] = blockData[getBlock(x+1, y-1, z, block)].shadow
blocks[4] = blockData[getBlock(x+1, y, z, block)].shadow
blocks[5] = blockData[getBlock(x+1, y+1, z, block)].shadow
blocks[6] = blockData[getBlock(x+1, y-1, z+1, block)].shadow
blocks[7] = blockData[getBlock(x+1, y, z+1, block)].shadow
blocks[8] = blockData[getBlock(x+1, y+1, z+1, block)].shadow
ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8
ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8
ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 0.8
}
return ret
},
west: function(x, y, z, block) {
let blocks = this.blocks
let ret = this.ret
if(blockData[getBlock(x, y, z, block)].shadow){
blocks[0] = blockData[getBlock(x-1, y-1, z-1, block)].shadow
blocks[1] = blockData[getBlock(x-1, y, z-1, block)].shadow
blocks[2] = blockData[getBlock(x-1, y+1, z-1, block)].shadow
blocks[3] = blockData[getBlock(x-1, y-1, z, block)].shadow
blocks[4] = blockData[getBlock(x-1, y, z, block)].shadow
blocks[5] = blockData[getBlock(x-1, y+1, z, block)].shadow
blocks[6] = blockData[getBlock(x-1, y-1, z+1, block)].shadow
blocks[7] = blockData[getBlock(x-1, y, z+1, block)].shadow
blocks[8] = blockData[getBlock(x-1, y+1, z+1, block)].shadow
ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8
ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8
ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8
ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
}else{
ret[0] = ret[1] = ret[2] = ret[3] = 0.8
}
return ret
},
}
function average(l, a, b, c, d) {
a = l[a]
b = l[b]
c = l[c]
d = l[d]
let count = 1
let zero = 0
let total = a
if (b && abs(a-b) <= 2) {
total += b
count++
} else zero++
if (c && abs(a-c) <= 2) {
total += c
count++
} else zero++
if (d && abs(a-d) <= 2) {
total += d
count++
} else zero++
let mx = max(a, b, c, d)
if (mx > 2) {
return total / (count * 15)
}
if (mx > 1) {
return zero ? total / (count * 15 + 15) : total / (count * 15)
}
return (total) / 60
}
let getLight = {
blocks: [],
top: function(x, y, z, block, ret, blockLight = 0) { // Actually the bottom... How did these get flipped?
let blocks = this.blocks
blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 0, 1, 3)
ret[1] = average(blocks, 4, 1, 2, 5)
ret[2] = average(blocks, 4, 5, 7, 8)
ret[3] = average(blocks, 4, 3, 6, 7)
// debugger
return ret
},
bottom: function(x, y, z, block, ret, blockLight = 0) { // Actually the top
let blocks = this.blocks
blocks[0] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 3, 6, 7)
ret[1] = average(blocks, 4, 5, 7, 8)
ret[2] = average(blocks, 4, 1, 2, 5)
ret[3] = average(blocks, 4, 0, 1, 3)
return ret
},
north: function(x, y, z, block, ret, blockLight = 0) {
let blocks = this.blocks
blocks[0] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 5, 7, 8)
ret[1] = average(blocks, 4, 3, 6, 7)
ret[2] = average(blocks, 4, 0, 1, 3)
ret[3] = average(blocks, 4, 1, 2, 5)
return ret
},
south: function(x, y, z, block, ret, blockLight = 0) {
let blocks = this.blocks
blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 1, 2, 5)
ret[1] = average(blocks, 4, 5, 7, 8)
ret[2] = average(blocks, 4, 3, 6, 7)
ret[3] = average(blocks, 4, 0, 1, 3)
return ret
},
east: function(x, y, z, block, ret, blockLight = 0) {
let blocks = this.blocks
blocks[0] = (getBlock(x+1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x+1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x+1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x+1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x+1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x+1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 1, 2, 5)
ret[1] = average(blocks, 4, 5, 7, 8)
ret[2] = average(blocks, 4, 3, 6, 7)
ret[3] = average(blocks, 4, 0, 1, 3)
return ret
},
west: function(x, y, z, block, ret, blockLight = 0) {
let blocks = this.blocks
blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[4] = (getBlock(x-1, y, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[5] = (getBlock(x-1, y+1, z, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[7] = (getBlock(x-1, y, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
blocks[8] = (getBlock(x-1, y+1, z+1, block) & 0xf << (blockLight * 4)) >> blockLight * 4
ret[0] = average(blocks, 4, 5, 7, 8)
ret[1] = average(blocks, 4, 1, 2, 5)
ret[2] = average(blocks, 4, 0, 1, 3)
ret[3] = average(blocks, 4, 3, 6, 7)
return ret
},
}
/*for(var it in getLight){
if(typeof getLight[it] !== "function")continue
getLight[it]=function(x,y,z,block,ret){
ret[0]=ret[1]=ret[2]=ret[3]=1
return ret
}
}*///for debugging
/*
function interpolateShadows(shadows, x, y) {
let sx = (shadows[1] - shadows[0]) * x + shadows[0]
let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
return (sx2 - sx) * y + sx
}
*/
let getTint = {
top: function(x,y,z,ret){//bottom
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
bottom: function(x,y,z,ret){//top
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
north: function(x,y,z,ret){
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
south: function(x,y,z,ret){
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
east: function(x,y,z,ret){
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
west: function(x,y,z,ret){
ret[0] = ret[2] = ret[3] = ret[5] = ret[6] = ret[8] = ret[9] = ret[11] = 1
ret[1] = ret[4] = ret[7] = ret[10] = 0
return ret
},
}
var worldGenArray = {
array: [],
size: 0,
add: function(x, y, z, block) {
if (this.size === this.array.length) {
this.array.push([ x, y, z, block ])
} else {
this.array[this.size][0] = x
this.array[this.size][1] = y
this.array[this.size][2] = z
this.array[this.size][3] = block
}
this.size++
},
clear: function() {
this.size = 0
},
get:function(n){
if(n < this.size) return this.array[n]
}
}
class Generator {
constructor() {
this.seedSet = false;
this.seed = 0;
this.size = 600;
this.diagonalNeighbors = true; //true if the corners are also adjacent
this.grid = [];
this.vertex = [];
this.river = [];
this.precip = [];
this.biome = [];
this.biomeBlend = [];
this.highestPoint = [0,0];
this.updates = [];
this.stage = 0;
this.changes = 0;
this.rivers = 0;
this.h = 0;
this.X = 0;
}
GetVertex(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 0;}
return this.vertex[x+y*this.size];
}
GetHeight(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 5;}
return Math.round(
(this.GetVertex(Math.floor(x), Math.floor(y))+
this.GetVertex(Math.floor(x+0.5), Math.floor(y))+
this.GetVertex(Math.floor(x), Math.floor(y+0.5))+
this.GetVertex(Math.floor(x+0.5), Math.floor(y+0.5)))*0.5+5);
};
GetWater(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
if (this.GetBiome(x,y) === -15099421 || this.GetBiome(x,y) === -16479791) {return 1}
return Math.sqrt(this.river[x+y*this.size]);
}
GetWaterDepth(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
var w = 0;
for (let x2 = 0; x2 < 1; x2+=0.5) {
for (let y2 = 0; y2 < 1; y2+=0.5) {
w += this.GetWater(Math.floor(x+x2),Math.floor(y+y2));
}
}
w = w/4.0;
if (w > 0.25) {
return 1;
}   else {
return 0;
}
}
GetBiome(x, y) {
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return -16479791;}
return this.biome[x+y*this.size];
}
GetBiomeType(x, y) {
x = (x+this.size/2)*0.5; y = (y+this.size/2)*0.5;
if (x < 0 || x >= this.size || y < 0 || y >= this.size) {return 1;}
return this.GetBiome(Math.floor(x),Math.floor(y));
}
GetNeighbors(x, y) {
var n = [];
if (x > 0) {
n.push({x:x-1, y:y});
if (this.diagonalNeighbors) {
if (y > 0) {
n.push({x:x-1, y:y-1});
}
if (y < this.size-1) {
n.push({x:x-1, y:y+1});
}}
}
if (x < this.size-1) {
n.push({x:x+1, y:y});
if (this.diagonalNeighbors) {
if (y > 0) {
n.push({x:x+1, y:y-1});
}
if (y < this.size-1) {
n.push({x:x+1, y:y+1});
}
}
}
if (y > 0) {
n.push({x:x, y:y-1});
}
if (y < this.size-1) {
n.push({x:x, y:y+1});
}
return n;
}
GetDown(x, y) {
var n = this.GetNeighbors(x, y);
var l = this.size;
var ld = [];
for (var i in n) {
if (this.vertex[n[i].x + n[i].y*this.size] <= l) {
if (this.vertex[n[i].x + n[i].y*this.size] === l) {
ld.push(n[i]);
}
l = this.vertex[n[i].x + n[i].y*this.size];
ld = [n[i]];
}
}
if (l <= this.vertex[x + y*this.size]) {
return ld[Math.floor(random(ld.length))];
}
return undefined;
}
SetSeed(seed) {
this.seed = seed;
this.seedSet = true;
randomSeed(hash(seed, 2123155232) * 210000000)
}
Generate(start) {
var end = start+16;
var nS = 0.021;
function sq(n) {return n*n}
function color(r, g, b, a) {
a = (a === undefined ? 255 : a);
g = (g === undefined ? r : g);
b = (b === undefined ? g : b);
if (a > 127) {a = -256+a;}
return b+g*256+r*65536+a*16777216;
}
if (this.stage === 0) { //landmass
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.grid[x +y*this.size] = 0;
this.vertex[x + y*this.size] = -1;
this.precip[x + y*this.size] = -1;
this.river[x + y*this.size] = 0;
var d = this.size/2-Math.sqrt(sq(x-this.size/2)+sq(y-this.size/2));
var islandMask = Math.sqrt(sq(this.size/2)-sq(d-this.size/2))*2/this.size;
var v = noise(x*nS, y*nS, this.seed);
if (v*islandMask > 0.3) {
this.grid[x+y*this.size] = 1;
}
}
this.X++;
}
if (this.X === this.size) {
this.updates.push({type:"ocean", x:0, y:0});
}
}   else if (this.stage === 1) {    //Oceans
while (this.updates.length > 0 && win.performance.now() < end) {
var u = this.updates.shift();
if (this.grid[u.x+u.y*this.size] === 0) {
this.grid[u.x+u.y*this.size] = 2;
var n = this.GetNeighbors(u.x, u.y);
for (var i = 0; i < n.length; i++) {
if (this.grid[n[i].x+n[i].y*this.size] === 0) {
this.updates.push({type:"ocean",x:n[i].x,y:n[i].y});
}
}
}
}
if (this.updates.length === 0) {
this.X = this.size;
}
}   else if (this.stage === 2) {    //altitude
if (this.h === -1) {this.h = 0;}
var doingLake = false;
var I = 0;
while (win.performance.now() < end && this.updates.length > 0 && I < this.updates.length) {
if (this.updates[I].type === "lake") {
var u = this.updates.splice(I, 1)[0];
if (this.grid[u.x + u.y*this.size] === 0 && this.vertex[u.x+u.y*this.size] === -1) {
this.vertex[u.x + u.y*this.size] = u.a;
var n = this.GetNeighbors(u.x, u.y);
for (var i in n) {
if (this.grid[n[i].x+n[i].y*this.size] === 0 && this.vertex[n[i].x + n[i].y*this.size] === -1) {
this.updates.push({type:"lake",x:n[i].x,y:n[i].y,a:u.a});
}
}
}
I--;
}
I++;
}
while (this.X < this.size && win.performance.now() < end && !doingLake) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.vertex[x+y*this.size] === -1) {
if (this.grid[x+y*this.size] === 2) {
this.vertex[x+y*this.size] = this.h;
this.changes++;
}   else if (this.h > 0) {
var n = this.GetNeighbors(x, y);
var l = this.size;
var ld;
for (var i in n) {
var v = this.vertex[n[i].x + n[i].y*this.size];
if (v < l && v !== -1) {
l = v;
ld = n[i];
}
}
if (l !== this.size && l <= this.h) {
if (this.grid[x+y*this.size] === 0) {
this.updates.push({type:"river",x:ld.x,y:ld.y});
this.updates.push({type:"lake",x:x,y:y,a:l});
}   else {
this.vertex[x+y*this.size] = l+1+(random() > 0.5 ? 1 : 0);
}
this.changes++;
}
}
}
}
this.X++;
}
if (this.X === this.size && this.h < this.size/3) {
if (this.changes === 0) {
this.h++;
}
this.X = 0;
this.changes = 0;
}
}   else if (this.stage === 3) {    //altitude readjustment
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.vertex[x+y*this.size] = (Math.pow(20, this.vertex[x+y*this.size]/this.size*3)-1)/(20-1)*this.size/3;
if (this.vertex[x+y*this.size] > this.vertex[this.highestPoint[0]+this.highestPoint[1]*this.size]) {
this.highestPoint[0] = x;
this.highestPoint[1] = y;
}
}
this.X++;
}
}   else if (this.stage === 4) {    //rivers
if (this.rivers === 0) {
var x, y;
for (var i = 0; i < 200 && this.rivers < 100; i++) {
x = Math.floor(random(this.size));
y = Math.floor(random(this.size));
if (this.grid[x+y*this.size] === 1) {
this.updates.push({type:"river",x:x,y:y});
this.rivers++;
}
}
}   else {
if (this.updates.length === 0) {
this.X = this.size;
}
}
while(this.updates.length > 0 && win.performance.now() < end) {
var u = this.updates[0];
if (this.grid[u.x+u.y*this.size] === 1) {
this.river[u.x+u.y*this.size]++;
var d = this.GetDown(u.x, u.y);
if (d === undefined) {
this.updates.shift();
}   else {
this.updates[0].x = d.x; this.updates[0].y = d.y;
}
}   else {
this.updates.shift();
}
}
}   else if (this.stage === 5) {    //precipitation
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.precip[x + y*this.size] === -1) {
if (this.h === -1) {
if (this.grid[x + y*this.size] === 2) {
this.precip[x + y*this.size] = 5;
this.changes++;
}
}   else {
if (this.h <= 8) {
if (this.grid[x + y*this.size] === 0 || this.river[x+y*this.size] > 0) {
this.precip[x + y*this.size] = 8;
this.changes++;
}
}
var n = this.GetNeighbors(x, y);
var h = -1;
for (var i in n) {
if (this.precip[n[i].x + n[i].y*this.size] > h) {
h = this.precip[n[i].x + n[i].y*this.size];
}
}
if (h > -1 && h >= this.h) {
this.precip[x+y*this.size] = Math.max(h - (random() < 0.5 ? 0.66 : 0.33), 0);
this.changes++;
}
}
}
}
this.X++;
}
if (this.X === this.size) {
this.X = 0;
if (this.h === -1) {
this.h = 10;
}   else {
if (this.changes === 0) {
this.h--;
}
this.changes = 0;
if (this.h < 0) {
this.X = this.size;
}
}
}
}   else if (this.stage === 6) {    //readjust precipitation
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
this.precip[x+y*this.size] = Math.floor(this.precip[x+y*this.size]/10*6);
}
this.X++;
}
}   else if (this.stage === 7) {    //temperature
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
}
this.X++;
}
}   else if (this.stage === 8) {    //biomes
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
var c;
var h = Math.floor(this.vertex[x+y*this.size]/this.size*6*5);
switch (this.grid[x+y*this.size]) {
case 0: if (h > 2) {
c = color(157, 194, 201);
}   else {
c = color(25, 153, 227);
}   break;
case 1: if (this.river[x+y*this.size] > 0) {
if (h > 2) {
c = color(157, 194, 201);
}   else {
c = color(25, 153, 227);
}
}   else {
switch (h) {
case 0: switch (this.precip[x+y*this.size]) {
case 5: case 4: c = color(10, 133, 72); break;
case 3: case 2: c = color(10, 133, 23); break;
case 1: c = color(179, 232, 35); break;
case 0: c = color(209, 166, 58); break;
} break;
case 1: switch (this.precip[x+y*this.size]) {
case 5: c = color(14, 156, 85); break;
case 4: case 3: c = color(72, 133, 10); break;
case 2: case 1: c = color(179, 232, 35); break;
case 0: c = color(207, 195, 58); break;
} break;
case 2: switch (this.precip[x+y*this.size]) {
case 5: case 4: c = color(121, 191, 95); break;
case 3: case 2: c = color(155, 161, 135); break;
case 1: case 0: c = color(207, 195, 58); break;
} break;
case 3: case 4: switch (this.precip[x+y*this.size]) {
case 5: case 4: case 3: c = color(255); break;
case 2: c = color(149, 189, 94); break;
case 1: c = color(180); break;
case 0: c = color(128);
} break;
}
}
break;
case 2: c = color(4, 137, 209); break;
}
this.biome[x+y*this.size] = c;
}
this.X++;
}
}   else if (this.stage === 9) {    //add lava
let ph = this.vertex[this.highestPoint[0] + this.highestPoint[1]*this.size]-5;
while (this.X < this.size && win.performance.now() < end) {
var x = this.X;
for (var y = 0; y < this.size; y++) {
if (this.vertex[x + y*this.size] > ph) {
this.vertex[x + y*this.size] = ph-2;
this.biome[x + y*this.size] = -65536;
}
}
this.X++;
}
}
if (this.X === this.size) {
console.log(this.stage)
this.X = 0;
this.h = -1;
this.stage++;
}
}
}
class Section {
constructor(x, y, z, size, chunk) {
this.x = x
this.y = y
this.z = z
this.size = size
this.arraySize = size * size * size
this.blocks = new Int32Array(this.arraySize)
this.light = new Uint8Array(this.arraySize)
this.tags = new Array(this.arraySize) //tags are like nbt in minecraft
this.renderData = []
this.renderLength = 0
this.faces = 0
this.hasVisibleBlocks = false
this.chunk = chunk
this.world = chunk && chunk.world
this.edited = false
this.caves = !caves
this.pallete = [0]
this.palleteMap = {"0": 0}
this.palleteSize = 0
}
getBlock(x, y, z) {
let s = this.size
return this.blocks[x * s * s + y * s + z]
}
setBlock(x, y, z, blockId) {
let s = this.size
this.blocks[x * s * s + y * s + z] = blockId
}
deleteBlock(x, y, z) {
let s = this.size
this.blocks[x * s * s + y * s + z] = 0
}
optimize() {
let visible = false
let pos = 0
let xx = this.x
let yy = this.y
let zz = this.z
let blockState = 0
let palleteIndex = 0
let index = 0
let s = this.size
let blocks = this.blocks
this.hasVisibleBlocks = false
this.renderLength = 0
let localBlocks = this.world.getAdjacentSubchunks(xx, yy, zz)
//Check all the blocks in the subchunk to see if they're visible.
for (let i = 0; i < s; i++) {
for (let j = 0; j < s; j++) {
for (let k = 0; k < s; k++, index++) {
blockState = blocks[index]
if (this.palleteMap[blockState] === undefined) {
this.palleteMap[blockState] = this.pallete.length
palleteIndex = this.pallete.length
this.pallete.push(blockState)
} else {
palleteIndex = this.palleteMap[blockState]
}
visible = blockState && (hideFace(i-1, j, k, localBlocks, blockState, getBlock, "west", "east")
| hideFace(i+1, j, k, localBlocks, blockState, getBlock, "east", "west",this) << 1
| hideFace(i, j-1, k, localBlocks, blockState, getBlock, "bottom", "top",this) << 2
| hideFace(i, j+1, k, localBlocks, blockState, getBlock, "top", "bottom",this) << 3
| hideFace(i, j, k-1, localBlocks, blockState, getBlock, "south", "north",this) << 4
| hideFace(i, j, k+1, localBlocks, blockState, getBlock, "north", "south",this) << 5)
if (visible) {
pos = (i | j << 4 | k << 8) << 19
this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
this.hasVisibleBlocks = true
}
}
}
}
}
updateBlock(x, y, z, world, leaveMe) {
if (!world.meshQueue.includes(this.chunk)) {
world.meshQueue.push(this.chunk)
}
let i = x
let j = y
let k = z
let s = this.size
x += this.x
y += this.y
z += this.z
let blockState = this.blocks[i * s * s + j * s + k]
let visible = blockState && (hideFace(x-1, y, z, 0, blockState, world.getBlock, "west", "east")
| hideFace(x+1, y, z, 0, blockState, world.getBlock, "east", "west") << 1
| hideFace(x, y-1, z, 0, blockState, world.getBlock, "bottom", "top") << 2
| hideFace(x, y+1, z, 0, blockState, world.getBlock, "top", "bottom") << 3
| hideFace(x, y, z-1, 0, blockState, world.getBlock, "south", "north") << 4
| hideFace(x, y, z+1, 0, blockState, world.getBlock, "north", "south") << 5)
let pos = (i | j << 4 | k << 8) << 19
let index = -1
// Find index of current block in this.renderData
for (let i = 0; i < this.renderLength; i++) {
if ((this.renderData[i] & 0x7ff80000) === pos) {
index = i
break
}
}
// Update pallete
if (this.palleteMap[blockState] === undefined) {
this.palleteMap[blockState] = this.pallete.length
this.pallete.push(blockState)
}
if (index < 0 && !visible) {
// Wasn't visible before, isn't visible after.
return
}
if (!visible) {
// Was visible before, isn't visible after.
this.renderData.splice(index, 1)
this.renderLength--
this.hasVisibleBlocks = !!this.renderLength
return
}
if (visible && index < 0) {
// Wasn't visible before, is visible after.
index = this.renderLength++
this.hasVisibleBlocks = true
}
this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
var block = world.getBlock(x,y,z)
if(!leaveMe && blockData[block]) blockData[block].onupdate(x,y,z,block);
}
genMesh(barray, index) {
if (!this.renderLength) {
return index
}
let length = this.renderLength
let rData = this.renderData
let x = 0, y = 0, z = 0, loc = 0, data = 0,
sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
verts = null, texVerts = null, texShapeVerts = null,
tx = 0, ty = 0
let wx = this.x, wy = this.y, wz = this.z
let blocks = this.world.getAdjacentSubchunks(wx, wy, wz)
let lightChunks = this.world.getAdjacentSubchunks(wx, wy, wz, true)
let block = null
let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0], tints = [1,1,1,1,1,1,1,1,1,1,1,1]
let blockSides = Object.keys(Block)
let side = ""
let shapeVerts = null
let shapeTexVerts = null
let pallete = this.pallete
// let intShad = interpolateShadows
for (let i = 0; i < length; i++) {
data = rData[i]
block = blockData[pallete[data & 0x1fff]]
tex = block.textures
sides = data >> 13 & 0x3f
loc = data >> 19 & 0xfff
x = loc & 15
y = loc >> 4 & 15
z = loc >> 8 & 15
x2 = x + this.x
y2 = y + this.y
z2 = z + this.z
shapeVerts = block.shape.verts
shapeTexVerts = block.shape.texVerts
let texNum = 0
for (let n = 0; n < 6; n++) {
side = blockSides[n]
if (sides & Block[side]) {
shadows = getShadows[side](x, y, z, blocks)
slights = getLight[side](x, y, z, lightChunks, slights, 0)
blights = getLight[side](x, y, z, lightChunks, blights, 1) //top is actually bottom
tints = getTint[side](x2, y2, z2, tints)
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
verts = directionalFaces[facei]
texVerts = textureCoords[textureMap[tex[texNum]]]
tx = texVerts[0]
ty = texVerts[1]
texShapeVerts = shapeTexVerts[n][facei]
barray[index] = verts[0] + x2
barray[index+1] = verts[1] + y2
barray[index+2] = verts[2] + z2
barray[index+3] = tx + texShapeVerts[0]
barray[index+4] = ty + texShapeVerts[1]
barray[index+5] = shadows[0]
barray[index+6] = slights[0]
barray[index+7] = blights[0]
barray[index+8] = tints[0]
barray[index+9] = tints[1]
barray[index+10] = tints[2]
barray[index+11] = verts[3] + x2
barray[index+12] = verts[4] + y2
barray[index+13] = verts[5] + z2
barray[index+14] = tx + texShapeVerts[2]
barray[index+15] = ty + texShapeVerts[3]
barray[index+16] = shadows[1]
barray[index+17] = slights[1]
barray[index+18] = blights[1]
barray[index+19] = tints[3]
barray[index+20] = tints[4]
barray[index+21] = tints[5]
barray[index+22] = verts[6] + x2
barray[index+23] = verts[7] + y2
barray[index+24] = verts[8] + z2
barray[index+25] = tx + texShapeVerts[4]
barray[index+26] = ty + texShapeVerts[5]
barray[index+27] = shadows[2]
barray[index+28] = slights[2]
barray[index+29] = blights[2]
barray[index+30] = tints[6]
barray[index+31] = tints[7]
barray[index+32] = tints[8]
barray[index+33] = verts[9] + x2
barray[index+34] = verts[10] + y2
barray[index+35] = verts[11] + z2
barray[index+36] = tx + texShapeVerts[6]
barray[index+37] = ty + texShapeVerts[7]
barray[index+38] = shadows[3]
barray[index+39] = slights[3]
barray[index+40] = blights[3]
barray[index+41] = tints[9]
barray[index+42] = tints[10]
barray[index+43] = tints[11]
index += 44
}
}
texNum++
}
}
return index
}
carveCaves() {
let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16
for (let x = this.x, xx = 0; x < wx; x++, xx++) {
for (let z = this.z, zz = 0; z < wz; z++, zz++) {
wy = this.chunk.tops[zz * 16 + xx]
for (let y = this.y; y < wy; y++) {
if (isCave(x, y, z)) {
carveSphere(x, y, z)
}
}
}
}
this.caves = true
}
tick() {
var world = this.world
for (let i = 0; i < 3; i++) {
let rnd = Math.random() * this.blocks.length | 0
if ((this.blocks[rnd]) === blockIds.grass) {
// Spread grass
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
if (!blockData[world.getBlock(x, y + 1, z)].transparent) {
world.setBlock(x, y, z, blockIds.dirt, false)
return
}
let rnd2 = Math.random() * 27 | 0
let x2 = rnd2 % 3 - 1
rnd2 = (rnd2 - x2 - 1) / 3
let y2 = rnd2 % 3 - 1
rnd2 = (rnd2 - y2 - 1) / 3
z += rnd2 - 1
x += x2
y += y2
if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
world.setBlock(x, y, z, blockIds.grass, false)
}
} else if (this.blocks[rnd] === (blockIds.oakSapling | CROSS)){
let i = (rnd >> 8) + this.x
let j = (rnd >> 4 & 15) + this.y
let k = (rnd & 15) + this.z
blockData[blockIds.oakSapling].grow(i,j,k)
}else if (this.blocks[rnd] === (blockIds.birchSapling | CROSS)){
let i = (rnd >> 8) + this.x
let j = (rnd >> 4 & 15) + this.y
let k = (rnd & 15) + this.z
blockData[blockIds.birchSapling].grow(i,j,k)
}
}
for (i = 0; i < 8; i++) {
let rnd = rand(this.blocks.length) | 0
if(this.blocks[rnd] === blockIds.tomatoPlant){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.tomatoPlant|SLAB, false)
}else if(this.blocks[rnd] === (blockIds.tomatoPlant|SLAB)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.tomatoPlant|STAIR, false)
}else if(this.blocks[rnd] === (blockIds.tomatoPlant|STAIR)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.tomatoPlant|CROSS, false)
}else if(this.blocks[rnd] === (blockIds.tomatoPlant|CROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.tomatoPlant|TALLCROSS, false)
}/*wheat*/else if(this.blocks[rnd] === (blockIds.wheat)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|SLAB, false)
}else if(this.blocks[rnd] === (blockIds.wheat|SLAB)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|STAIR, false)
}else if(this.blocks[rnd] === (blockIds.wheat|STAIR)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|CROSS, false)
}else if(this.blocks[rnd] === (blockIds.wheat|CROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|TALLCROSS, false)
}else if(this.blocks[rnd] === (blockIds.wheat|TALLCROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|DOOR, false)
}else if(this.blocks[rnd] === (blockIds.wheat|DOOR)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|TORCH, false)
}else if(this.blocks[rnd] === (blockIds.wheat|TORCH)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.wheat|LANTERN, false)
}/*cactus fruit*/else if(this.blocks[rnd] === (blockIds.newCactusFruit|CROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.greenCactusFruit|CROSS, false)
}else if(this.blocks[rnd] === (blockIds.greenCactusFruit|CROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.redCactusFruit|CROSS, false)
}else if(this.blocks[rnd] === (blockIds.redCactusFruit|CROSS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
world.setBlock(x, y, z, blockIds.purpleCactusFruit|CROSS, false)
}/*cactus*/else if(this.blocks[rnd] === (blockIds.cactus|CACTUS)){
let x = (rnd >> 8) + this.x
let y = (rnd >> 4 & 15) + this.y
let z = (rnd & 15) + this.z
var above = world.getBlock(x,y+1,z)
if(blockData[above].cactusFruit){
if(world.getBlock(x,y+2,z)) return //the cactus fruit can't replace blocks
world.setBlock(x,y+2,z, above) //move the cactus fruit up
}else if(above) return //there is a block so it can't grow
world.setBlock(x,y+1,z, blockIds.cactus|CACTUS)
}
}
}
getLight(x, y, z, block = 0) {
let s = this.size
let i = x * s * s + y * s + z
return (this.light[i] & 15 << (block * 4)) >> (block * 4)
}
setLight(x, y, z, level, block = 0) {
let s = this.size
let i = x * s * s + y * s + z
this.light[i] = level << (block * 4) | (this.light[i] & 15 << (!block * 4))
}
getTags(x, y, z){
let s = this.size
return this.tags[x * s * s + y * s + z]
}
getTagByName(x, y, z, n){
var t = this.getTags(x,y,z)
return t && t[n]
}
setTags(x,y,z, data){
let s = this.size
this.tags[x * s * s + y * s + z] = data
}
setTagByName(x, y, z, n, data){
let s = this.size
var i = x * s * s + y * s + z
var t = this.tags[i]
if(!t){
t = this.tags[i] = {}
}
t[n] = data
return t
}
}
let emptySection = new Section(0, 0, 0, 16)
let fullSection = new Section(0, 0, 0, 16)
fullSection.blocks.fill(blockIds.bedrock)
emptySection.light.fill(15)
class Chunk {
constructor(x, z, type, world) {
this.x = x
this.z = z
this.maxY = 0
this.minY = 255
this.sections = []
this.cleanSections = []
this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
this.ceils = new Uint8Array(16 * 16) //for nether
this.biomes = new Array(16 * 16) // biome type at every (x,z) coordinate
this.optimized = false
this.generated = false; // Terrain
this.populated = superflat === true // Trees and ores
this.lit = false
this.lazy = false
this.edited = false
this.loaded = false
this.type = type || world.type
// vao for this chunk
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
this.caves = !caves
this.doubleRender = false
this.world = world
}
getBlock(x, y, z) {
let s = y >> 4
return s < this.sections.length && s >= 0 ? this.sections[s].getBlock(x, y & 15, z) : 0
}
setBlock(x, y, z, blockID, user) {
if (!this.sections[y >> 4]) {
do {
this.sections.push(new Section(this.x, this.sections.length * 16, this.z, 16, this))
} while (!this.sections[y >> 4])
}
if (user && !this.sections[y >> 4].edited) {
this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
this.sections[y >> 4].edited = true
this.edited = true
}
if (blockData[blockID].semiTrans) {
this.doubleRender = true
if (!this.world.doubleRenderChunks.includes(this)) {
this.world.doubleRenderChunks.push(this)
}
}
this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
}
getTags(x, y, z){
let s = y >> 4
return this.sections.length > s ? this.sections[s].getTags(x, y & 15, z) : null
}
getTagByName(x,y,z,n){
let s = y >> 4
return this.sections.length > s ? this.sections[s].getTagByName(x, y & 15, z,n) : null
}
setTags(x,y,z,data){
let s = y >> 4
if(this.sections.length > s) this.sections[s].setTags(x, y & 15, z, data)
}
setTagByName(x,y,z,n,data){
let s = y >> 4
if(this.sections.length > s) return this.sections[s].setTagByName(x, y & 15, z,n,data)
}
fillLight() {
let max = this.sections.length * 16 - 1
let blockSpread = []
// Set virtical columns of light to level 15
for (let x = 0; x < 16; x++) {
for (let z = 0; z < 16; z++) {
let stop = false
for (let y = max; y >= 0; y--) {
let data = blockData[this.getBlock(x, y, z)]
if (data.lightLevel) {
if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
this.setLight(x, y, z, data.lightLevel, 1)
}
if (!stop && !data.transparent) {
this.tops[z * 16 + x] = y
stop = true
} else if (!stop) {
this.setLight(x, y, z, 15, 0)
}
}
}
}
// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
let spread = []
for (let x = 0; x < 16; x++) {
for (let z = 0; z < 16; z++) {
for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
if (x === 15 || this.tops[z * 16 + x + 1] > y) {
spread.push(x + this.x, y, z + this.z)
continue
}
if (x === 0 || this.tops[z * 16 + x - 1] > y) {
spread.push(x + this.x, y, z + this.z)
continue
}
if (z === 15 || this.tops[(z + 1) * 16 + x] > y) {
spread.push(x + this.x, y, z + this.z)
continue
}
if (z === 0 || this.tops[(z - 1) * 16 + x] > y) {
spread.push(x + this.x, y, z + this.z)
continue
}
break
}
}
}
this.spreadLight(spread, 14)
for (let i = blockSpread.length - 1; i > 0; i--) {
let blocks = blockSpread[i]
if (blocks && blocks.length) {
this.spreadLight(blocks, i - 1, false, 1)
}
}
this.lit = true
}
setLight(x, y, z, level, blockLight) {
if(this.sections[y >> 4]) this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
}
getLight(x, y, z, blockLight = 0) {
if (y >= this.sections.length * 16) return 15
return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
}
trySpread(x, y, z, level, spread, blockLight, update = false) {
if(y < 0) return
if (this.world.getLight(x, y, z, blockLight) < level) {
if (blockData[this.world.getBlock(x, y, z)].transparent) {
this.world.setLight(x, y, z, level, blockLight)
spread.push(x, y, z)
}
}
if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
let chunk = this.world.getChunk(x, z)
if (chunk.buffer && !this.world.meshQueue.includes(chunk)) {
this.world.meshQueue.push(chunk)
}
}
}
spreadLight(blocks, level, update = false, blockLight = 0) {
let spread = []
let x = 0, y = 0, z = 0
for (let i = 0; i < blocks.length; i += 3) {
x = blocks[i]
y = blocks[i+1]
z = blocks[i+2]
if(y < 0) continue
this.trySpread(x - 1, y, z, level, spread, blockLight, update)
this.trySpread(x + 1, y, z, level, spread, blockLight, update)
this.trySpread(x, y - 1, z, level, spread, blockLight, update)
this.trySpread(x, y + 1, z, level, spread, blockLight, update)
this.trySpread(x, y, z - 1, level, spread, blockLight, update)
this.trySpread(x, y, z + 1, level, spread, blockLight, update)
}
if (level > 1 && spread.length) {
this.spreadLight(spread, level - 1, update, blockLight)
}
}
tryUnSpread(x, y, z, level, spread, respread, blockLight) {
if(y < 0) return
let light = this.world.getLight(x, y, z, blockLight)
let trans = blockData[this.world.getBlock(x, y, z)].transparent
if (light === level) {
if (trans) {
this.world.setLight(x, y, z, 0, blockLight)
spread.push(x, y, z)
}
} else if (light > level) {
respread[light].push(x, y, z)
}
if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
let chunk = this.world.getChunk(x, z)
if (chunk && chunk.buffer && !this.world.meshQueue.includes(chunk)) {
this.world.meshQueue.push(chunk)
}
}
}
unSpreadLight(blocks, level, respread, blockLight) {
let spread = []
let x = 0, y = 0, z = 0
for (let i = 0; i < blocks.length; i += 3) {
x = blocks[i]
y = blocks[i+1]
z = blocks[i+2]
if(y < 0) continue
this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
}
if (level > 1 && spread.length) {
this.unSpreadLight(spread, level - 1, respread, blockLight)
}
}
reSpreadLight(respread, blockLight) {
for (let i = respread.length - 1; i > 1; i--) {
let blocks = respread[i]
let level = i - 1
let spread = respread[level]
for (let j = 0; j < blocks.length; j += 3) {
let x = blocks[j]
let y = blocks[j+1]
let z = blocks[j+2]
this.trySpread(x - 1, y, z, level, spread, blockLight)
this.trySpread(x + 1, y, z, level, spread, blockLight)
this.trySpread(x, y - 1, z, level, spread, blockLight)
this.trySpread(x, y + 1, z, level, spread, blockLight)
this.trySpread(x, y, z - 1, level, spread, blockLight)
this.trySpread(x, y, z + 1, level, spread, blockLight)
}
}
}
optimize() {
for (let i = 0; i < this.sections.length; i++) {
this.sections[i].optimize()
}
if (!this.world.meshQueue.includes(this)) {
this.world.meshQueue.push(this)
}
this.optimized = true
}
render() {
if (!this.buffer) {
return
}
if (p.canSee(this.x, this.minY, this.z, this.maxY)) {
renderedChunks++
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
updateBlock(x, y, z, world, lazy, leaveMe) {
if (this.buffer) {
this.lazy = lazy
if ((this.sections.length > y >> 4) && this.sections[y >> 4]) {
this.sections[y >> 4].updateBlock(x, y & 15, z, world, leaveMe)
}
}
}
deleteBlock(x, y, z, user) {
if (!this.sections[y >> 4]) {
return
}
if (user && !this.sections[y >> 4].edited) {
this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
this.sections[y >> 4].edited = true
this.edited = true
}
this.sections[y >> 4].deleteBlock(x, y & 15, z)
this.minY = y < this.minY ? y : this.minY
this.maxY = y > this.maxY ? y : this.maxY
}
carveCaves() {
for (let i = 0; i < this.sections.length; i++) {
if (!this.sections[i].caves) {
this.sections[i].carveCaves()
if (i + 1 >= this.sections.length) {
this.caves = true
}
return
}
}
}
generateBlob(replace, blockID, amount, x,y,z, size = 1){
// Blob code from https://biome-testing.lukep0wers.repl.co
// generate blobs (ore blobs, dirt blobs, etc)
let newX=0, newY=0, newZ=0
for(let cv = 0; cv < amount; cv++) {
var block = this.getBlock(x+newX, y+newY, z+newZ)
var canReplace = false
if(Array.isArray(replace)){
for(var id of replace){
if(block === id){
canReplace = true
break
}
}
}else{
if(block === replace) {
canReplace = true
}
}
if(canReplace) this.setBlock(x+newX, y+newY, z+newZ,blockID);
newX = round(random(-size, size));
newY = round(random(-size, size));
newZ = round(random(-size, size));
}
}
populate() {
var world = this.world
var flowers = [blockIds.flowerOftheValley, blockIds.poppy, blockIds.dandelion, 
blockIds.blueOrchid, blockIds.pinkTulip, blockIds.orangeTulip, blockIds.redTulip, blockIds.whiteTulip,
blockIds.azureBluet, blockIds.cornFlower, blockIds.purpleFlower, blockIds.witherRose,
blockIds.allium, blockIds.oxeyeDaisy,
blockIds.lilac, blockIds.roseBush, blockIds.peony,
blockIds.TallGrass, blockIds.DoubleTallGrass]
randomSeed(hash(this.x, this.z) * 210000000)
let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false, topsi = 0, tall = 0
let trueX = this.x, trueY = this.y, trueZ = this.z
let smoothness = generator.smooth, hilliness = generator.height
let biomeSmooth = generator.biomeSmooth;
let biome = 0
let type = world.type
var clayReplaceable = [blockIds.dirt, blockIds.stone, blockIds.gravel]
var dirtReplaceable = [blockIds.stone,blockIds.gravel]
for (let i = 0; i < 16; i++) {
for (let k = 0; k < 16; k++) {
wx = this.x + i
wz = this.z + k
ground = this.tops[k * 16 + i]
//biome = superflat ? 0 : noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
//var b
//if(superflat){b = "field"}else b = getBiome(biome)
//let nb = getNetherBiome(biome)
let b = this.biomes[k * 16 + i] || "field", nb = this.biomes[k * 16 + i]
if (trees && random() < 0.07 && type === "" && b === "field" && world.getBlock(i, ground, k) === blockIds.grass) {
top = ground + floor(4.5 + random(2.5))
rand = floor(random(4096))
let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
let groundBlock = blockIds.dirt
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, groundBlock)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf)
}
}
}
}
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf)
world.spawnBlock(wx, top + 1, wz - 1, leaf)
world.spawnBlock(wx, top + 1, wz + 1, leaf)
world.spawnBlock(wx - 1, top + 1, wz, leaf)
}
if(b === "snowyField" && trees && random() < 0.07 && type === "" && world.getBlock(i, ground, k)){
top = ground + floor(4.5 + random(2.5))
rand = floor(random(4096))
let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog
let leaf = tree === blockIds.oakLog ? blockIds.oakLeaves : blockIds.birchLeaves
let groundBlock = blockIds.dirt
let snow = blockIds.snow
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, groundBlock)
this.setBlock(i, top + 2, k, snow | LAYER2)
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf)
world.spawnBlock(wx, top + 1, wz - 1, leaf)
world.spawnBlock(wx, top + 1, wz + 1, leaf)
world.spawnBlock(wx - 1, top + 1, wz, leaf)
world.spawnBlock(wx + 1, top + 2, wz, snow | LAYER1)
world.spawnBlock(wx, top + 2, wz - 1, snow | LAYER1)
world.spawnBlock(wx, top + 2, wz + 1, snow | LAYER1)
world.spawnBlock(wx - 1, top + 2, wz, snow | LAYER1)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf)
if(rand & 2) world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER2)
else world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf)
world.spawnBlock(wx + x, top + 1, wz + z, snow | LAYER1)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
if(rand & 2) world.spawnBlock(wx + x, top, wz + z, snow | LAYER2)
else world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
world.spawnBlock(wx + x, top, wz + z, snow | LAYER1)
}
}
}
}
//get rid of snow underneath
/*for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if(x || z){
var g = world.getTop(wx,wz)
if(g) world.setBlock(wx+i, g+1, wz+k, 0)
}
}
}*/
//
}
// Cactus
if (random() < 0.01 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
var rnd = random()
top = ground + Math.floor(2.5 + rnd*1.5);
rand = Math.floor(random(4096));
let tree = blockIds.cactus | CACTUS;
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree);
}
this.setBlock(i, ground, k, blockIds.sand);
for (let j = 5; j <= 10; j++) {
this.setBlock(1, ground-j, k, blockIds.Lava);
}
//Fruit
switch(round(rnd*4)){
case 0:
this.setBlock(i, top+1, k, blockIds.newCactusFruit|CROSS);
break
case 1:
this.setBlock(i, top+1, k, blockIds.greenCactusFruit|CROSS);
break
case 2:
this.setBlock(i, top+1, k, blockIds.redCactusFruit|CROSS);
break
}
}
if (random() < 0.006 && this.getBlock(i, ground, k) && b === "desert" && ground > 60 && this.type !== "nether") {
let tree = blockIds.deadBush | CROSS;
this.setBlock(i,ground+1,k, tree);
this.setBlock(i, ground, k, blockIds.sand);
}
// Jungle trees
if(trees && random() < 0.01 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
tall = floor(5 + random(5)) //5 to 10
top = ground + tall
let tree = blockIds.jungleLog
let leaf = blockIds.jungleLeaves
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, blockIds.dirt)
//Bottom leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top - 2, wz + z, leaf)
}
}
}
}
//2nd layer leaves
for (let x = -2; x <= 2; x++) {
for (let z = -2; z <= 2; z++) {
if (x || z) {
if ((x * z & 7) === 4) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
}
}
}
}
//3rd layer leaves
for (let x = -1; x <= 1; x++) {
for (let z = -1; z <= 1; z++) {
if (x || z) {
if (x & z) {
place = rand & 1
rand >>>= 1
if (place) {
world.spawnBlock(wx + x, top, wz + z, leaf)
}
} else {
world.spawnBlock(wx + x, top, wz + z, leaf)
}
}
}
}
//Top leaves
world.spawnBlock(wx + 1, top + 1, wz, leaf)
world.spawnBlock(wx, top + 1, wz - 1, leaf)
world.spawnBlock(wx, top + 1, wz + 1, leaf)
world.spawnBlock(wx - 1, top + 1, wz, leaf)
}//end jungle trees
//Giant jungle trees
if(trees && random() < 0.01 && type === "" && b === "giantJungle" && world.getBlock(i, ground, k)){
tall = floor(10 + random(20)) //10 to 30
top = ground + tall
let tree = blockIds.jungleLog
let leaf = blockIds.jungleLeaves
//Center
for (let j = ground + 1; j < top; j++) {
this.setBlock(i, j, k, tree)
world.spawnBlock(wx + 1, j, wz, tree)
world.spawnBlock(wx, j, wz + 1, tree)
world.spawnBlock(wx+1, j, wz+1, tree)
}
this.setBlock(i, ground, k, blockIds.dirt)
world.spawnBlock(wx + 1, ground, wz, blockIds.dirt)
world.spawnBlock(wx, ground, wz + 1, blockIds.dirt)
world.spawnBlock(wx+1, ground, wz+1, blockIds.dirt)
//Messy part
//leaves
let w2 = 5 * 5
let d2 = 5 * 5
let h2 = 5 * 5
for(var x=-4.5; x<4.5; x++){
for(var y=2; y<4.5; y++){
for(var z=-4.5; z<4.5; z++){
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.spawnBlock(wx + x+1, top-4+y, wz + z+1, leaf)
}
}
}
}
//the diagonal branches
w2 = 3 * 3
d2 = 3 * 3
h2 = 3 * 3
for(y=ground+5; y<top; y += Math.floor(random(10))){
let side = Math.floor(random(4))
let mx=0,mz=0
switch(side){
case 0:
mx=1
break
case 1:
mx=-1
break
case 2:
mz=1
break
case 3:
mz=-1
break
}
let x = mx === 1?2:mx, z = mz === 1?2:mz
var rnd = Math.floor(random(4))+2
//branch
for(var by=0; by<rnd; by++){
world.spawnBlock(wx+x, y+by, wz+z, tree)
x += mx
z += mz
}
x -= mx
z -= mz
by -= 1
//leaves
for(var lx=-3; lx<3; lx++){
for(var ly=1; ly<3; ly++){
for(var lz=-3; lz<3; lz++){
let n = lx * lx / w2 + ly * ly / h2 + lz * lz / d2
if (n < 1) {
world.spawnBlock(wx+x + lx, y+by+ly, wz+z + lz, leaf)
}
}
}
}
// m = move; l = leaf
}
//vines
for(var vi=0; vi<10; vi++){
var vy = random(ground, top)
var side = floor(random(4))
var vx = wx, vz = wz
switch(side){
case 0:
vz += 2
side = SOUTH
break
case 1:
vz -= 1
side = NORTH
break
case 2:
vx += 2
side = WEST
break
case 3:
vx -= 1
side = EAST
break
}
var vh = max(floor(random(ground,vy)), ground)
for(; vy > vh && !world.getBlock(vx, vy, vz); vy --){
world.spawnBlock(vx,vy,vz, blockIds.vine | WALLFLAT | side)
}
}
}//end giant jungle trees; jungle bushes
if(trees && random() < 0.007 && type === "" && (b === "jungle" || b === "giantJungle") && world.getBlock(i, ground, k)){
let w2 = 3 * 3
let d2 = 3 * 3
let h2 = 3 * 3
for(var x=-3; x<3; x++){
for(var y=1; y<3; y++){
for(var z=-3; z<3; z++){
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.spawnBlock(wx+x, ground+y, wz+z, blockIds.jungleLeaves)
}
}
}
}
this.setBlock(i, ground+1, k, blockIds.jungleLog)
}
if (random() < 0.005 && type === "nether" && ground > 79 && nb !== 0){
tall = floor(4.5 + random(2.5))
if(floor(random(12)) === 1) tall *= 2
top = ground + tall
rand = floor(random(4096))
let tree
let leaf
let groundBlock = blockIds.netherrack
if(this.type === "nether"){
if(nb === 1){
tree = blockIds.warpedStem
leaf = blockIds.warpedWartBlock
}else if(nb === 2){
tree = blockIds.crimsonStem
leaf = blockIds.netherWartBlock
}
}
//Center
for (let j = ground + 1; j <= top; j++) {
this.setBlock(i, j, k, tree)
}
this.setBlock(i, top + 1, k, leaf)
this.setBlock(i, ground, k, groundBlock)
//Shroomlight
for(var l=0; l<3; l++) world.spawnBlock(wx + random(-2, 2), top + random(-1,1), wz + random(-2,2), blockIds.shroomlight)
//Top leaves
for(var x=-1; x<2; x++){
for(var z=-1; z<2; z++){
place = (x&1) && (z&1) ? rand & 1 : true
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top + 1, wz + z, leaf)
}
}
}
//layer 2 leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = (x===2 || x===-2) && (z===2 || z==-2) ? rand & 1 : true
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top, wz + z, leaf)
}
}
}
rand = floor(random(4096))
//layer 1 leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2 ? !(rand & 1) : false
rand >>>= 1
if(place){
world.spawnBlock(wx + x, top - 1, wz + z, leaf)
}
}
}
rand = floor(random(40964096))
//drooping leaves
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2
rand >>>= 1
if(place){
var h = rand & 4 && rand & 8 ? rand & 3 : 0
if(h){
world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
for(var y=0; y<h; y++){
world.spawnBlock(wx + x, top - 2 - y, wz + z, leaf)
}
}
}
}
}
if(nb === 2){
rand = floor(random(40964096))
//vines
for(var x=-2; x<3; x++){
for(var z=-2; z<3; z++){
place = x===2 || x===-2 || z===2 || z==-2
rand >>>= 1
if(place){
var h = (rand & 4 && rand & 8) ? (rand & (tall-2)) - 1 : 0
if(h){
world.spawnBlock(wx + x, top - 1, wz + z, leaf) //to make sure removed ones are put back
for(var y=0; y<h; y++){
world.spawnBlock(wx + x, top - 2 - y, wz + z, blockIds.weepingVinesPlant)
}
world.spawnBlock(wx + x, top - 2 - h, wz + z, blockIds.weepingVines)
}
}
}
}
}
}
//flowers and vines
if (random() < 0.05 && this.getBlock(i, ground, k) === blockIds.grass) {
var flower = flowers[Math.round(random(flowers.length-1))]
world.spawnBlock(wx, ground+1, wz, flower);
}
var block = this.getBlock(i, ground, k)
if(random() < 0.05){
if(block === blockIds.crimsonNylium){
world.spawnBlock(wx, ground+1, wz, blockIds.crimsonRoots);
}else if(block === blockIds.warpedNylium){
world.spawnBlock(wx, ground+1, wz, blockIds.warpedRoots);
}
}
//bamboo
if(random() < 0.2 && this.getBlock(i, ground, k) && b === "bambooForest" && ground > 60 && this.type !== "nether"){
if(random() < 0.2){
this.setBlock(i, ground+1, k, blockIds.bambooShoot | CROSS)
}else{
var h = round(4+random()*10)
top = ground+h
for(var y=ground+1; y<top+1; y++){
if(y === top){
this.setBlock(i,y,k,blockIds.bambooStalk | STAIR)
}else if(y === top-1){
this.setBlock(i,y,k,blockIds.bambooStalk | SLAB)
}else{
this.setBlock(i,y,k,blockIds.bambooStalk)
}
}
}
}
//lava rivers
if(random() < 0.005 && world.getBlock(i,ground,k) && this.type==="nether"){
let it = 0
let x=wx, y=ground, z=wz
let dir=floor(random(0,8))
for(; it<100; it++){
let xp,zp
switch(dir){
case 0:
x+=1
zp=true
break
case 1:
x+=1
z+=1
break
case 2:
z+=1
xp=true
break
case 3:
x-=1
z+=1
break
case 4:
x-=1
zp=true
break
case 5:
x-=1
z-=1
break
case 6:
z-=1
xp=true
break
case 7:
x+=1
z-=1
break
}
if(random() < 0.08){
dir += round(random(-1,1))
}
let prev = world.getBlock(x,y,z)
world.setBlock(x,y,z,blockIds.Lava)
if(xp){
world.setBlock(x+1,y,z,blockIds.Lava)
}
if(zp){
world.setBlock(x,y,z+1,blockIds.Lava)
}
if(!prev && y>1){
y--
prev = world.getBlock(x,y,z)
world.setBlock(x,y,z,blockIds.Lava)
while(!prev && y>1){
y--
prev = world.getBlock(x,y,z)
world.setBlock(x,y,z,blockIds.Lava)
}
}
if(world.getBlock(x,y-1,z) === blockIds.Lava) break
}
}
if(this.type === "nether"){
let l
if(random() < 0.005){
/*let r = random(12345123451234512345)*3
let x=wx, y=this.ceils[k * 16 + i], z=wz
let ri=floor(random(5,15))
for(l=0; l<ri; l++){
x += r&1 - 1; r >>>= 1
y += r&3 - 2; r >>>= 1
z += r&1 - 1; r >>>= 1
world.spawnBlock(x,y,z, blockIds.glowstone)
}*/
this.generateBlob(0, blockIds.glowstone, 20, wx,this.ceils[k * 16 + i],wz, 2)
}
for(l=0; l<16; l++){
let x = random(0, 16)
let y = random(10, 177)
let z = random(0, 16)
if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
world.setBlock(wx+x,y,wz+z, blockIds.netherQuartzOre)
}
}
for(l=0; l<10; l++){
let x = random(0, 16)
let y = random(10, 177)
let z = random(0, 16)
if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
world.setBlock(wx+x,y,wz+z, blockIds.netherGoldOre)
}
}
for(l=0; l<5; l++){
let x = random(0, 16)
if (random(0,2) < 1) {
let y = random(5, 20)
} else {
let y = random(100, 115)
}
let z = random(0, 16)
if(world.getBlock(wx+x,y,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y+1,wz+z) === blockIds.netherrack && world.getBlock(wx+x,y-1,wz+z) === blockIds.netherrack){
world.setBlock(wx+x,y,wz+z, blockIds.ancientDebris)
}
}
}else{
// Blocks of each per chunk in Minecraft
// Coal: 185.5
// Iron: 111.5
// Gold: 10.4
// Redstone: 29.1
// Diamond: 3.7
// Lapis: 4.1
//there is also copper
ground -= 4
if (random() < 3.7 / 256) {
let y = random() * 16 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre)
this.generateBlob(blockIds.stone, blockIds.diamondOre, round(random(3, 8)), i,y,k, 10)
}
}
if (random() < 111.5 / 256) {
let y = random() * 64 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre)
this.generateBlob(blockIds.stone, blockIds.ironOre, round(random(1, 13)), i,y,k, 9)
}
}
if (random() < 51 / 256) {
let y = random() * 64 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.copperOre)
this.generateBlob(blockIds.stone, blockIds.copperOre, round(random(1, 16)), i,y,k, 9)
}
}
if (random() < 185.5 / 256) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre)
this.generateBlob(blockIds.stone, blockIds.coalOre, round(random(1, 37)), i,y,k, 20)
}
}
if (random() < 10.4 / 256) {
let y = random() * 32 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre)
this.generateBlob(blockIds.stone, blockIds.goldOre, round(random(1, 13)), i,y,k, 9)
}
}
if (random() < 29.1 / 256) {
let y = random() * 16 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre)
this.generateBlob(blockIds.stone, blockIds.redstoneOre, round(random(1, 10)), i,y,k, 8)
}
}
if (random() < 4.1 / 256) {
let y = random() * 32 | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
//this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre)
this.generateBlob(blockIds.stone, blockIds.lapisOre, round(random(1, 9)), i,y,k, 9)
}
}
//clay & dirt (& lava)
if (random() < 0.1) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)/* && blockData[this.getBlock(i, y+1, k)].name === "Water"*/) {
this.generateBlob(clayReplaceable, blockIds.clay, round(random(20, 40)), i,y,k, 5)
}
}
if (random() < 0.1) {
let y = random() * ground | 0 + 1
y = y < ground ? y : ground
if (this.getBlock(i, y, k)) {
this.generateBlob(dirtReplaceable, blockIds.dirt, round(random(20, 40)), i,y,k, 5)
}
}
let x = random(0, 16)
let y = random(5, 10)
let z = random(0, 16)
for(l=0; l<10; l++){
let xx = random(-2,2)
let zz = random(-2,2)
if(world.getBlock(wx+x+xx,y,wz+z+zz) === blockIds.stone){
world.setBlock(wx+x+xx,y,wz+z+zz, blockIds.Lava)
} else if (world.getBlock(wx+x+xx,y+1,wz+z+zz) === blockIds.stone){
world.setBlock(wx+x+xx,y+1,wz+z+zz, blockIds.Lava)
}
}
}
}
}
this.populated = true
}
genMesh() {
let start = performance.now()
let barray = bigArray
let index = 0
for (let i = 0; i < this.sections.length; i++) {
index = this.sections[i].genMesh(barray, index)
}
let arrayDone = performance.now()
if (!this.buffer) {
this.buffer = gl.createBuffer()
}
let data = barray.slice(0, index)
let maxY = 0
let minY = 255
let y = 0
for (let i = 1; i < data.length; i += 6) {
y = data[i]
maxY = max(maxY, y)
minY = min(minY, y)
}
this.maxY = maxY
this.minY = minY
this.faces = data.length / 44
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
gl.enableVertexAttribArray(glCache.aVertex)
gl.enableVertexAttribArray(glCache.aTexture)
gl.enableVertexAttribArray(glCache.aShadow)
gl.enableVertexAttribArray(glCache.aSkylight)
gl.enableVertexAttribArray(glCache.aBlocklight)
//gl.enableVertexAttribArray(glCache.tint) //doesn't work, i think bigArray needs to be bigger
gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 44, 0)
gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 44, 12)
gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 44, 20)
gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 44, 24)
gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 44, 28)
//gl.vertexAttribPointer(glCache.tint, 3, gl.FLOAT, false, 44, 40)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
this.lazy = false
}
tick() {
if (this.edited) {
for (let i = 0; i < this.sections.length; i++) {
if (this.sections[i].edited) {
this.sections[i].tick()
}
}
}
}
load() {
var world = this.world
let chunkX = this.x >> 4
let chunkZ = this.z >> 4
let load = null
for (let i = 0; i < world.loadFrom.length; i++) {
load = world.loadFrom[i]
if (load.x === chunkX && load.z === chunkZ) {
let y = load.y * 16
for (let j in load.blocks) {
if(blockData[load.blocks[j]]){ // if a block doesn't exsist, they won't be generated
world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
}
}
world.loadFrom.splice(i--, 1)
}
}
this.loaded = true
}
}
class Contacts {
constructor() {
this.array = []
this.size = 0
}
add(x, y, z, block) {
if (this.size === this.array.length) {
this.array.push([ x, y, z, block ])
} else {
this.array[this.size][0] = x
this.array[this.size][1] = y
this.array[this.size][2] = z
this.array[this.size][3] = block
}
this.size++
}
clear() {
this.size = 0
}
}
var entityMatrices = {
modelViewProjectionMatrix: new Matrix(),
projectionMatrix: new Matrix(),
modelMatrix: new Matrix()
}
class Entity {
constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, vao) {
this.x = x
this.y = y
this.z = z
this.previousX = x
this.previousY = y
this.previousZ = z
this.canStepX = true
this.canStepY = true
this.pitch = pitch
this.yaw = yaw
this.velx = velx
this.vely = vely
this.velz = velz
this.width = width
this.height = height
this.depth = depth
this.offsetY = 0
this.extraSize = 0
this.hidden = false
this.harmEffect = 0
this.contacts = new Contacts()
this.lastUpdate = performance.now()
this.onGround = false
this.hasCollided = false
this.gravityStength = -0.032
this.standingOn = 0
this.despawns = despawns
this.spawn = this.lastUpdate
this.canDespawn = false
this.dieEffect = 0
this.burning = false
this.parts = {}
this.faces = faces
if(vao){
this.vao = vao
}else{
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
generateVAO(shape, tx, ty){
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
return {vao, size}
}
generateBlockVAO(blockID){
const block = blockData[blockID]
const tex = block.textures
const shape = block.shape
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
return {vao, size}
}
updateVelocity(now) {
this.standingOn = world.getBlock(this.x, round(this.y-this.height-1), this.z)
if (this.liquid){
this.gravityStength = -0.01
this.vely *= 0.9
}else{
this.gravityStength = -0.02
}
this.vely += this.gravityStength
if (this.vely < -1.5) {
this.vely = -1.5
}
let drag = this.liquid ? 0.7 : (this.onGround ? 0.5 : 0.85)
if(blockData[this.standingOn].slide) drag = blockData[this.standingOn].slide
this.velz += (this.velz * 0.9 - this.velz)
this.velx += (this.velx * 0.9 - this.velx)
// this.vely += (this.vely * 0.9 - this.vely) * dt
}
collided(x, y, z, vx, vy, vz, block) {
let verts = blockData[block].shape.verts
let px = roundBits(this.x - this.width / 2 - x)
let py = roundBits(this.y - this.height / 2 - y)
let pz = roundBits(this.z - this.depth / 2 - z)
let pxx = roundBits(this.x + this.width / 2 - x)
let pyy = roundBits(this.y + this.height / 2 - y)
let pzz = roundBits(this.z + this.depth / 2 - z)
let minX, minY, minZ, maxX, maxY, maxZ, min, max
//Top and bottom faces
let faces = verts[0]
if (vy <= 0) {
faces = verts[1]
}
if (!vx && !vz) {
for (let face of faces) {
min = face.min
minX = min[0]
minZ = min[2]
max = face.max
maxX = max[0]
maxZ = max[2]
if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
if (vy <= 0) {
this.onGround = true
this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
this.vely = 0
return false
} else {
return true
}
}
}
return false
}
//West and East faces
if (vx < 0) {
faces = verts[4]
} else if (vx > 0) {
faces = verts[5]
}
if (vx) {
let col = false
for (let face of faces) {
min = face.min
minZ = min[2]
minY = min[1]
max = face.max
maxZ = max[2]
maxY = max[1]
if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
if (maxY - py > 0.5) {
this.canStepX = false
}
col = true
}
}
return col
}
//South and North faces
if (vz < 0) {
faces = verts[2]
} else if (vz > 0) {
faces = verts[3]
}
if (vz) {
let col = false
for (let face of faces) {
min = face.min
minX = min[0]
minY = min[1]
max = face.max
maxX = max[0]
maxY = max[1]
if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
if (maxY - py > 0.5) {
this.canStepZ = false
}
col = true
}
}
return col
}
}
move(now) {
let pminX = floor(this.x - this.width / 2)
let pmaxX = ceil(this.x + this.width / 2)
let pminY = floor(this.y - this.height / 2)
let pmaxY = ceil(this.y + this.height / 2)
let pminZ = floor(this.z - this.depth / 2)
let pmaxZ = ceil(this.z + this.depth / 2)
let block = null
this.liquid = false
for (let x = pminX; x <= pmaxX; x++) {
for (let y = pminY; y <= pmaxY; y++) {
for (let z = pminZ; z <= pmaxZ; z++) {
let block = world.getBlock(x, y, z)
if (block && blockData[block].solid && !blockData[block].liquid) {
this.contacts.add(x, y, z, block)
}
if(x === round(this.x) && z === round(this.z) && blockData[block].liquid){
this.liquid = true
}
}
}
}
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
this.canStepX = false
this.canStepY = false
this.onGround = false
this.hasCollided = false
//Check collisions in the Y direction
this.y += this.vely
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
this.y = this.previousY
this.vely = 0
this.hasCollided = true
break
}
}
if (this.y === this.previousY) {
this.canStepX = true
this.canStepZ = true
}
//Check collisions in the X direction
this.x += this.velx
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
continue
}
this.x = this.previousX
this.velx = 0
this.hasCollided = true
break
}
}
//Check collisions in the Z direction
this.z += this.velz
for (let i = 0; i < this.contacts.size; i++) {
block = this.contacts.array[i]
if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
continue
}
this.z = this.previousZ
this.velz = 0
this.hasCollided = true
break
}
}
if(this.onGround){
this.hasCollided = true
}
this.lastUpdate = now
this.contacts.clear()
}
moveTowards(x,y,z, rw, rh, rd, slowDown = 1){
var dist = dist3(this.x/rw,this.y/rh,this.z/rd,x/rw,y/rh,z/rd)
var aDist = abs(dist)
if(aDist > 1) return
var iDist = 1 - aDist //inverted distance
var toX = lerp(iDist, this.x, x)
var toY = lerp(iDist, this.y, y)
var toZ = lerp(iDist, this.z, z)
this.velx = (toX - this.x) / slowDown * iDist
if(this.onGround) this.vely = (toY - this.y) / slowDown * iDist
this.velz = (toZ - this.z) / slowDown * iDist
/*var xd = this.x - p.x, zd = this.z - p.z;
var x = xd; this.velx = (x-(Math.sign(x)*7.25)) / 150
if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40}
var z = zd; this.velz = (z-(Math.sign(z)*7.25)) / 150*/
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
}
render() {
if(this.hidden) return
let diff = (performance.now() - this.lastUpdate) / tickTime
if (diff > 1) diff = 1
const offsetY = this.offsetY
let renderx = (this.x - this.previousX) * diff + this.previousX
let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
let renderz = (this.z - this.previousZ) * diff + this.previousZ
const modelMatrix = entityMatrices.modelMatrix;
modelMatrix.identity()
modelMatrix.translate(renderx, rendery, renderz)
modelMatrix.rotZ(this.dieEffect)
modelMatrix.rotX(this.pitch)
modelMatrix.rotY(this.yaw)
modelMatrix.scale(this.width + this.extraSize, this.height + this.extraSize, this.depth + this.extraSize)
const viewMatrix = p.transformation.elements
const proj = p.projection
let projectionMatrix = entityMatrices.projectionMatrix
projectionMatrix.set(proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0)
projectionMatrix = projectionMatrix.elements
const modelViewProjectionMatrix = entityMatrices.modelViewProjectionMatrix
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSamplerEntity, 0)
gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
gl.uniform1f(glCache.harmEffectEntity, this.harmEffect || this.dieEffect)
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
for(var part in this.parts){
this.renderPart(this.parts[part], modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, renderx, rendery, renderz)
}
gl.uniform1f(glCache.harmEffectEntity, 0)
if(this.burning){
entityFire.render(this)
}
}
addPart(name,size,vao,x,y,z,w,h,d,rx,ry,rz = 0){
this.parts[name] = {
name,
size,vao,
x,y,z,w,h,d,rx,ry,rz, //x,y,z,rx,ry are relative to entity position
originalX:x, originalY:y, originalZ:z
}
}
renderPart(part, modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, x,y,z){
modelMatrix.identity()
modelMatrix.translate(x, y, z)
modelMatrix.rotZ(this.dieEffect)
modelMatrix.rotX(this.pitch)
modelMatrix.rotY(this.yaw)
modelMatrix.translate(part.x, part.y, part.z)
modelMatrix.rotZ(part.rz)
modelMatrix.rotX(part.rx)
modelMatrix.rotY(part.ry)
modelMatrix.scale(part.w, part.h, part.d)
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
modelViewProjectionMatrix.transpose()
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(part.vao)
gl.drawElements(gl.TRIANGLES, 6 * part.size, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
class Item extends Entity {
constructor(x, y, z, velx, vely, velz, blockID, autoSetVel, amount, durability = null) {
const block = blockData[blockID]
const tex = block.textures
const shape = block.shape
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
super(x, y, z, 0, 0, velx, vely, velz, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
this.block = blockID
this.type = "Item"
this.from = achexUsername
this.durability = durability
//this.amount = amount || 1
if(autoSetVel){
this.velx = (Math.random()-0.5) * 0.2
this.vely = Math.random() * 0.2
this.velz = (Math.random()-0.5) * 0.2
}
}
update() {
if(this.amount <= 0){
return this.canDespawn = true
}
let now = performance.now()
this.yaw += 0.01;
if(this.yaw > Math.PI*2){
this.yaw -= Math.PI*2
}
this.updateVelocity(now)
this.move(now)
let pickup = false
let comeCloser = false
if(now - this.spawn > 1000 && !p.spectator){
let xDist = this.x - p.x
let yDist = this.y - (p.y - p.bottomH)
let zDist = this.z - p.z
var hRange = 1.425
comeCloser = xDist > -hRange && xDist < hRange && yDist > -0.75 && yDist < 2.3 && zDist > -hRange && zDist < hRange
if(comeCloser){
var onGround = this.onGround
this.onGround = true
this.moveTowards(p.x, p.y, p.z, hRange,2.3,hRange, 0.5)
this.onGround = onGround
}
var w = p.w
pickup = xDist > -w && xDist < w && yDist > p.bottomH - 0.1 && yDist < p.bottomH + p.topH && zDist > -w && zDist < w
/*if(pickup){
var dist = dist3(this.x, this.y, this.z, p.x, p.y, p.z)
var dist2 = dist3(this.x, this.y, this.z, p.x, p.y-1, p.z)
pickup = ((1 >= dist) && (dist >= -1)) || ((1 >= dist2) && (dist2 >= -1))
}*/
}
/*if(multiplayer ? host : true){
let d = 3/4
var updateShape
for(var i=0; i<world.entities.length; i++){
var e = world.entities[i]
if(e.type === "Item" && e !== this){
xDist = this.x - e.x
yDist = this.y - e.y
zDist = this.z - e.z
let stack = xDist > -d && xDist < d && yDist > -d && yDist < d && zDist > -d && zDist < d
if(stack){
this.amount += e.amount
e.amount = 0
updateShape = true
}
}
}
if(updateShape) this.updateShape()
}*/
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(pickup){
/*var a = this.amount
for(var i=0; i<a; i++){
if(newInvItem(this.block)) this.amount --
else break
}
if(this.amount === 0){
this.canDespawn = true
updateHUD = true
playSound("entity.item.pickup")
}else this.updateShape()*/
if(newInvItem(this.block, this.durability)){
this.canDespawn = true
if(this.block === blockIds.oakLog || this.block === blockIds.birchLog || this.block === blockIds.jungleLog){
achievment("Getting Wood")
}
if(this.block === blockIds.diamond){
achievment("DIAMONDS!")
}
if(this.block === blockIds.ancientDebris){
achievment("Hidden In The Depths")
}
if(multiplayer && this.block === blockIds.diamond && this.from !== achexUsername){
//that achivement
send({type:"diamondsToYou"}, this.from)
}
if(this.block === blockIds.tomatoSeeds){
achievment("Time to plant tomatoes!")
}
updateHUD = true
var pitch = rand(0.8, 1.5)
playSound("entity.item.pickup", 0, 1, pitch)
if(multiplayer) send({type:"playSound", data:"entity.item.pickup", x:this.x,y:this.y,z:this.z, pitch:pitch})
}
}
this.offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
}
updateShape(){
if(blockData[this.block].shape !== shapes.cube) return
var shape
if(this.amount === 1){
shape = "cube"
}else if(this.amount < 4){
shape = "cube"+this.amount
}else{
shape = "cube4"
}
const block = blockData[this.block]
const tex = block.textures
shape = shapes[shape]
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
var vertices = new Float32Array(shapeVerts.flat(Infinity))
texture = new Float32Array(texture)
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
this.faces = size
}
}
win.Item = Item
class BlockEntity extends Entity{
constructor(blockID, x,y,z, solidOnGround, cacheBlocks){
const block = blockData[blockID]
const tex = block.textures
const shape = block.shape
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
super(x, y, z, 0, 0, 0, 0, 0, 0.996, 0.996, 0.996, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
this.block = blockID
this.type = "BlockEntity"
this.solidOnGround = solidOnGround
this.cacheBlocks = cacheBlocks
this.cached = {}
if(cacheBlocks){
this.cached[blockID] = this.vao
}
}
changeBlock(blockID){
if(this.cached[blockID]){
this.vao = this.cached[blockID]
return
}
const block = blockData[blockID]
const tex = block.textures
const shape = block.shape
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
var vertices = new Float32Array(shapeVerts.flat(Infinity)),
faces = size
texture = new Float32Array(texture),
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
if(this.cacheBlocks){
this.cached[blockID] = this.vao
}
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(this.onGround && this.solidOnGround){
var x = round(this.x), y = round(this.y), z = round(this.z)
var b = world.getBlock(x, y, z)
if(b){
// non cube block breaks falling blocks
world.addEntity(new Item(x,y,z, 0,0,0, this.block))
}else{
world.setBlock(x,y,z, this.block)
blockSound(this.block, "land", x,y,z)
}
this.canDespawn = true
}
}
}
win.BlockEntity = BlockEntity
class PrimedTNT extends BlockEntity{
constructor(x,y,z, timerStart){
super(blockIds.tnt, x,y,z)
this.type = "PrimedTNT"
this.velx = (Math.random() * 0.1) - 0.05
this.vely = Math.random() * 0.1
this.velz = (Math.random() * 0.1) - 0.05
this.prevTex = blockIds.tnt
this.tex = this.prevTex
this.timerStart = timerStart || this.spawn
this.lastCollidedY = this.timerStart
this.timeLimit = 80
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
if(this.onGround){
this.lastCollidedY = this.y
}
var h = this.y - this.lastCollidedY
if(h > 19.75){
this.lastCollidedY = this.y
this.timerStart -= 1000
}
var i = Math.floor((now - this.timerStart) / 250)
if(i%2){
this.tex = blockIds.tnt
}else{
this.tex = blockIds.whiteConcrete
world.particles.push(new TNTSmokeParticle(this.x,this.y+0.5-0.125,this.z))
}
if(this.prevTex !== this.tex){
this.changeBlock(this.tex)
this.prevTex = this.tex
}
if((now - this.spawn) / tickTime >= this.timeLimit - 10){
//get bigger
this.extraSize = -((this.timeLimit - 10) - ((now - this.spawn) / tickTime)) / 40
}
if((now - this.spawn) / tickTime >= this.timeLimit){
this.canDespawn = true
var x = round(this.x), y = round(this.y), z = round(this.z)
explode(x,y,z,4, blockData[world.getBlock(x,y,z)].liquid || !worldSettings.tntExplode)
}
}
}
class EnderPearl extends BlockEntity{
constructor(x,y,z,velx,vely,velz){
super(blockIds.enderPearl, x,y,z)
this.type = "EnderPearl"
this.velx = velx
this.vely = vely
this.velz = velz
this.from = achexUsername
this.gravityStrength = -0.05
}
updateVelocity(now) {
this.vely += this.gravityStength
if (this.vely < -1.5) {
this.vely = -1.5
}
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
var fromMe = this.from === achexUsername
if (fromMe && now - this.spawn > this.despawns) {
this.canDespawn = true
}
if(fromMe && this.hasCollided){
p.x = this.x
p.y = this.y
p.z = this.z
this.canDespawn = true
}
}
}
class Snowball extends BlockEntity{
constructor(x,y,z,velx,vely,velz){
super(blockIds.snowball, x,y,z)
this.type = "Snowball"
this.velx = velx
this.vely = vely
this.velz = velz
this.from = achexUsername
this.gravityStrength = -0.05
}
updateVelocity(now) {
this.vely += this.gravityStrength
if (this.vely < -0.5) {
this.vely = -0.5
}
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
if(fromMe && now - this.spawn > 1000){
var collided = entityRayTrace(this.x,this.y,this.z,true)
if(collided && collided !== this){
if(entPlayerCollided){
send({type:"hit", username:username, data:1, message:username+" killed "+ent.username+" with snowballs."}, ent.id)
}else{
if(collided.onhit) collided.onhit(1)
}
this.canDespawn = true
}else if(collidedWithMe && survival){
damage(1, username+" got killed by their own snowball.")
this.canDespawn = true
}
}
var fromMe = this.from === achexUsername
if (fromMe && (now - this.spawn > this.despawns || this.hasCollided)) {
this.canDespawn = true
}
}
}
class ExperienceOrb extends Entity{
//experienceOrb
constructor(x,y,z,value){
var i
if(!value || value <= 2){
i = 0
}else if(value <= 6){
i = 1
}else if(value <= 16){
i = 2
}else if(value <= 36){
i = 3
}else if(value <= 72){
i = 4
}else if(value <= 148){
i = 5
}else if(value <= 306){
i = 6
}else if(value <= 616){
i = 7
}else if(value <= 1236){
i = 8
}else if(value <= 2476){
i = 9
}else if(value <= 32767){
i = 10
}
super(x, y, z, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, null, null, experienceOrbVaos.size, 300000, experienceOrbVaos[i])
this.type = "ExperienceOrb"
this.value = value
this.tint = {r:1,g:1,b:1}
}
update(){
let now = performance.now()
var dist = dist3(this.x,this.y,this.z,p.x,p.y-p.bottomH,p.z)
if(!p.spectator){
if(dist < 7.25 && dist > -7.25){
////var speed = (7.25 - dist) / 10
//var aDist = abs(dist)
//var xd = this.x - p.x, zd = this.z - p.z;
//var x = xd/*/abs(zd)*/; this.velx = (x-(Math.sign(x)*7.25)) / 150//; this.velx = -this.velx
//if(this.onGround) {var y = this.y - (p.y-p.bottomH); this.vely = (y-(Math.sign(y)*7.25)) / 40/*; this.vely = -this.vely*/}
//var z = zd/*/abs(xd)*/; this.velz = (z-(Math.sign(z)*7.25)) / 150//; this.velx = -this.velx
this.moveTowards(p.x, p.y-p.bottomH, p.z, 7.25,7.25,7.25, 10)
}
if(dist < 0.5 && dist > -0.5){
if(now - p.lastXP >= 10000){
XP(this.value)
this.canDespawn = true
}
}
}
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
this.facePlayer()
this.tint.r = min(max(abs((now-this.spawn) % 1000 - 500) / 500, 0), 1)
this.tint.g = 1
this.tint.b = 0
}
facePlayer(){
this.yaw = Math.PId - (atan2(p.z - this.z, p.x - this.x) + Math.PI2 + Math.PI)
var adjacent = dist2(this.x,this.z,p.x,p.z)
this.pitch = Math.PId - atan2(p.y - this.y, adjacent)
}
render(){
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(this.x, this.y, this.z)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0)
gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
gl.uniform1i(glCache.uSamplerEntity, 5)
gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
gl.uniform1f(glCache.harmEffectEntity, 0)
gl.uniform1i(glCache.isTextureAtlasEntity,0)
gl.uniform3f(glCache.tintEntity, this.tint.r,this.tint.g,this.tint.b)
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
gl.uniform1i(glCache.isTextureAtlasEntity,1)
gl.uniform3f(glCache.tintEntity, 1,1,1)
}
}
win.ExperienceOrb = ExperienceOrb
class crackEntity extends Entity{
constructor(tex, x,y,z){
const shape = shapes.cube
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
}
super(x, y, z, 0, 0, 0, 0, 0, 1.01, 1.01, 1.01, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
this.cached = {}
}
cacheTexture(tex){
const shape = shapes.cube
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
}
var vertices = new Float32Array(shapeVerts.flat(Infinity)),
faces = size
texture = new Float32Array(texture)
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
this.cached[tex] = this.vao
}
changeTexture(tex){
this.vao = this.cached[tex]
}
render(){
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(this.x, this.y, this.z)
modelMatrix.rotX(this.pitch)
modelMatrix.rotY(this.yaw)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const skysLight = world.getLight(x, y+1, z, 0) * (skyLight / 15)
const lightLevel = 1
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSamplerEntity, 0)
gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
class EntityFire extends Entity{
constructor(){
const shape = shapes.entityFire
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap["fire"]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
}
super(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity)
}
render(ent){ //for burning entities
if(!ent) return
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(ent.x, ent.y+ent.offsetY+(ent.height*0.25), ent.z)
//modelMatrix.rotX(0)
modelMatrix.rotY(ent.yaw)
modelMatrix.scale(ent.width*1.5, ent.height*1.5, ent.depth*1.5) //taller than the entity
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSamplerEntity, 0)
gl.uniform1f(glCache.uLightLevelEntity, 1)
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
//character is seen in 3rd person mode
class Character extends Entity{
constructor(blockID){
super(0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, null, null, 0, Infinity, "this isn't really a VAO... but it will be overwritten")
var v = this.generateVAO(shapes.playerBody, 0,0)
this.faces = v.size
this.vao = v.vao
var pix = 1/16
this.defaultOffsetY = pix*-8
this.sneakingOffsetY = pix*-(8-4.8)
this.die = false
this.sneaking = false
this.walking = false
this.sprinting = false
var part = this.generateVAO(shapes.playerHead,0,0)
this.addPart("head",part.size,part.vao,0,pix*6,0,1,1,1,0,0)
part = this.generateVAO(shapes.playerLeftArm,0,0)
this.addPart("leftArm",part.size,part.vao,pix*6,pix*6,0,1,1,1,0,0)
part = this.generateVAO(shapes.playerRightArm,0,0)
this.addPart("rightArm",part.size,part.vao,pix*-6,pix*6,0,1,1,1,0,0)
part = this.generateVAO(shapes.playerLeftLeg,0,0)
this.addPart("leftLeg",part.size,part.vao,pix*2,pix*-6,0,1,1,1,0,0)
part = this.generateVAO(shapes.playerRightLeg,0,0)
this.addPart("rightLeg",part.size,part.vao,pix*-2,pix*-6,0,1,1,1,0,0)
this.headYaw = 0
this.headPitch = 0
this.holding = 1 //shown in the hand, it is set to the blockid for the block the player is holding
this.prevHolding = 1
this.holdRot = Math.PI / -10
part = this.generateBlockVAO(this.holding)
this.addPart("holding",part.size,part.vao,0, 0, 0, 1,1,1, 0, 0)
this.walkRot = 0
this.punchEffect = 0
this.skinSet = false
this.skinURL = null
this.skinImg = images.skin
}
setSkin(url){
this.skinSet = true
this.skinURL = url
if(!url) return //some people don't have skins. prevent it from breaking
var image = new Image()
var me = this
image.onload = function(){
me.skinImg = image
}
image.src = url
}
generateVAO(shape, tx, ty, texAtlas){
var scale = texAtlas ? 1 : (16 * 16 / 64)
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = (tx + texShapeVerts[0]) * scale
texture[index + 1] = (ty + texShapeVerts[1]) * scale
texture[index + 2] = (tx + texShapeVerts[2]) * scale
texture[index + 3] = (ty + texShapeVerts[3]) * scale
texture[index + 4] = (tx + texShapeVerts[4]) * scale
texture[index + 5] = (ty + texShapeVerts[5]) * scale
texture[index + 6] = (tx + texShapeVerts[6]) * scale
texture[index + 7] = (ty + texShapeVerts[7]) * scale
index += 8
}
texNum++
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
return {vao, size}
}
update(){
var now = performance.now()
var pix = 1 / 16
var armRot = (sin((now - this.spawn) / 1000) / 2 + 0.5) * Math.PI / 40
if(this.harmEffect > 0){
this.harmEffect -= 3
}
if(this.die){
this.dieEffect += 0.18
if(this.dieEffect > Math.PI2){
this.y = 0
this.die = false
this.dieEffect = 0
}
}
this.parts.head.rx = this.headPitch
this.parts.head.ry = this.headYaw - this.yaw
if(this.sneaking){
this.offsetY = this.sneakingOffsetY
var rot = Math.PI / 6
this.pitch = rot
this.parts.head.rx -= rot
this.parts.leftLeg.rx = this.parts.rightLeg.rx = -rot
}else{
this.offsetY = this.defaultOffsetY
this.pitch = 0
this.parts.leftLeg.rx = this.parts.rightLeg.rx = 0
}
this.parts.leftArm.rz = armRot
this.parts.rightArm.rz = -armRot
var part = this.parts.holding
if(this.holding !== this.prevHolding){
this.prevHolding = this.holding
var v = this.generateBlockVAO(this.holding)
part.vao = v.vao
part.size = v.size
}
this.parts.rightArm.rx = this.holdRot
this.parts.leftArm.rx = 0
if(blockData[this.holding].tool){//part.size,part.vao,pix*-6, 0, pix*8, 0.25,0.25,0.25, this.holdRot, 0
part.x = 0
part.y = pix*-12
part.z = pix*6
part.w = part.h = part.d = 1
part.rx = Math.PI / 1.25
part.ry = Math.PI * -0.5
}else if(blockData[this.holding].item){
part.x = pix*3
part.y = pix*-12
part.z = pix*2
part.w = part.h = part.d = 0.5
part.rx = 0
part.ry = 0
}else if(this.holding){
part.x = 0
part.y = pix*-12
part.z = pix*3
part.w = part.h = part.d = 0.25
part.rx = 0
part.ry = Math.PI / 4
}else{
this.parts.rightArm.rx = 0
}
var walkRotTarget
if(this.walking){
if(this.sprinting){
walkRotTarget = sin((now - this.spawn) / 50) * Math.PI / 4
}else if(this.sneaking){
walkRotTarget = sin((now - this.spawn) / 220) * Math.PI / 4
}else{
walkRotTarget = sin((now - this.spawn) / 100) * Math.PI / 4
}
}else{
walkRotTarget = 0
}
this.walkRot = lerp(0.5, this.walkRot, walkRotTarget)
this.parts.leftLeg.rx += this.walkRot
this.parts.rightLeg.rx -= this.walkRot
this.parts.leftArm.rx += this.walkRot
this.parts.rightArm.rx -= this.walkRot
if(this.punchEffect > 0){
this.punchEffect -= 3
if(this.punchEffect < 0) this.punchEffect = 0
var punchEffect = this.punchEffect/6
this.parts.rightArm.rx -= punchEffect
this.parts.rightArm.ry2 = punchEffect/2
}else this.parts.rightArm.ry2 = 0
}
setPos(x,y,z){
this.previousX = this.x
this.previousY = this.y
this.previousZ = this.z
this.x = x
this.y = y
this.z = z
this.lastUpdate = performance.now()
}
setRot(rx,ry){
this.headPitch = rx
this.headYaw = this.yaw = ry
}
changeBlock(blockID){
return //using skin texture, not block texture
/*if(this.cached[blockID])return this.vao = this.cached[blockID]
const block = blockData[blockID]
const tex = block.textures
const shape = block.shape
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
var vertices = new Float32Array(shapeVerts.flat(Infinity)),
faces = size
texture = new Float32Array(texture),
this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexEntity)
gl.enableVertexAttribArray(glCache.aTextureEntity)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
this.cached[blockID] = this.vao*/
}
render(){
let diff = (performance.now() - this.lastUpdate) / tickTime
if (diff > 1) diff = 1
const offsetY = this.offsetY
let renderx = (this.x - this.previousX) * diff + this.previousX
let rendery = ((this.y - this.previousY) * diff + this.previousY) + offsetY
let renderz = (this.z - this.previousZ) * diff + this.previousZ
//set texture to skin
gl.activeTexture(gl.TEXTURE7)
gl.bindTexture(gl.TEXTURE_2D, skinTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.skinImg)
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(renderx, rendery, renderz)
modelMatrix.rotZ(this.dieEffect)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0)
gl.bindTexture(gl.TEXTURE_2D, skinTexture)
gl.uniform1i(glCache.uSamplerEntity, 7)
gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
gl.uniform1f(glCache.harmEffectEntity, this.harmEffect || this.dieEffect)
gl.uniform1i(glCache.isTextureAtlasEntity,0)
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
for(var part in this.parts){
this.renderPart(this.parts[part], modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, renderx, rendery, renderz)
}
gl.uniform1f(glCache.harmEffectEntity, 0)
gl.uniform1i(glCache.isTextureAtlasEntity,1)
if(this.burning){
entityFire.render(this)
}
}
renderPart(part, modelMatrix, modelViewProjectionMatrix, projectionMatrix, viewMatrix, x,y,z){
var texAtlas = part.name === "holding"
if(texAtlas){
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSamplerEntity, 0)
gl.uniform1i(glCache.isTextureAtlasEntity,1)
}
modelMatrix.identity()
modelMatrix.translate(x, y, z)
modelMatrix.rotZ(this.dieEffect)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
if(part.name === "holding"){
var arm = this.parts.rightArm
modelMatrix.translate(arm.x, arm.y, arm.z)
modelMatrix.rotZ(arm.rz)
if(arm.ry2) modelMatrix.rotY(arm.ry2)
modelMatrix.rotX(arm.rx)
modelMatrix.rotY(arm.ry)
}
modelMatrix.translate(part.x, part.y, part.z)
modelMatrix.rotZ(part.rz)
if(part.ry2) modelMatrix.rotY(part.ry2)
modelMatrix.rotX(part.rx)
modelMatrix.rotY(part.ry)
modelMatrix.scale(part.w, part.h, part.d)
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
modelViewProjectionMatrix.transpose()
gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(part.vao)
gl.drawElements(gl.TRIANGLES, 6 * part.size, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
if(texAtlas){
gl.bindTexture(gl.TEXTURE_2D, skinTexture)
gl.uniform1i(glCache.uSamplerEntity, 7)
gl.uniform1i(glCache.isTextureAtlasEntity,0)
}
}
}
window.Player = Character
//world.entities.push(new Cow(p2.x, p2.y, p2.z))
class Mob extends Entity{
constructor(){
super(...arguments)
this.moveTime = 0
this.spinTime = 0
this.spin = 0
this.dirx = 0
this.dirz = 0
this.health = 0
this.lastY = this.y
}
AI(now){
let dt = (now - this.lastUpdate) / 33
dt = dt > 2 ? 2 : dt
if(this.moveTime > 0){
this.moveTime --
this.velx += this.dirx / 100
this.velz += this.dirz / 100
}else if(this.spinTime > 0){
this.spinTime --
this.yaw += this.spin
if(this.yaw > Math.PI*2){
this.yaw -= Math.PI*2
}
if(this.yaw < 0){
this.yaw += Math.PI*2
}
}else if(Math.random()>0.8){
if(Math.random() > 0.5){
this.spinTime = Math.random()*60
this.spin = (Math.random()>0.5 ? 0.05 : -0.05)
}else{
this.moveTime = Math.random()*60
this.dirx = Math.cos(this.yaw)
this.dirz = -Math.sin(this.yaw)
}
}
if(this.moveTime > 0 && Math.random() > 0.5){
var b = world.getBlock(round(this.x+this.dirx), this.y, round(this.z+this.dirz))
if(this.onGround && blockData[b].solid && !blockData[b].liquid){
this.vely = 0.3
}
if(blockData[b].liquid){
this.vely += 0.05
}
}
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
//health and death & stuff
if(this.onGround){
let fall = this.lastY - this.y
this.lastY = this.y
if(fall > 3){
let damage = Math.floor(fall-3)
this.health -= damage
this.harmEffect = 40
}
}
if(this.harmEffect > 0){
this.harmEffect -= 3
}
if(this.health <= 0){
this.health = -1
this.dieEffect += 0.18
if(this.dieEffect > Math.PI2){
this.canDespawn = true
poof(this.x,this.y,this.z)
}
}
this.AI(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
}
onhit(damage){
this.health -= damage
this.harmEffect = 40
}
}
class Cow extends Mob{
constructor(x,y,z){
const tex = ["cow","cow","cowSide","cowSide","cowSide","cowSide"]
const shape = shapes.cow
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < blockSides.length; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
super(x, y, z, 0, 0, 0, 0, 0, 1, 1, 1, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
this.type = "Cow"
this.health = 10
}
}
class Pig extends Mob{
constructor(x,y,z){
const tex = new Array(6).fill("pinkWool")
const shape = shapes.cow
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < blockSides.length; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex[texNum]]]
let tx = texVerts[0]
let ty = texVerts[1]
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + texShapeVerts[0]
texture[index + 1] = ty + texShapeVerts[1]
texture[index + 2] = tx + texShapeVerts[2]
texture[index + 3] = ty + texShapeVerts[3]
texture[index + 4] = tx + texShapeVerts[4]
texture[index + 5] = ty + texShapeVerts[5]
texture[index + 6] = tx + texShapeVerts[6]
texture[index + 7] = ty + texShapeVerts[7]
index += 8
}
texNum++
}
super(x, y, z, 0, 0, 0, 0, 0, .9, .9, .9, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000)
this.type = "Pig"
this.health = 10
}
}
class Particle extends Entity{
constructor() {
super(...arguments)
}
facePlayer(){
this.yaw = Math.PId - (atan2(p.z - this.z, p.x - this.x) + Math.PI2 + Math.PI)
var adjacent = dist2(this.x,this.z,p.x,p.z)
this.pitch = Math.PId - atan2(p.y - this.y, adjacent)
/*//var magnitude = dist3(this.x,this.y,this.z,p.x,p.y,p.z)
this.yaw = atan2(p.z - this.z, p.x-this.x)
var adjacent = dist2(this.x,this.z,p.x,p.z)
this.pitch = atan2(p.y - this.y, adjacent)*/
/*var r = this.rotationMatrix
r.identity()
var e = r.elements
var up = vec4
up.x = 0
up.y = 1
up.z = 0
e[12] = this.x
e[13] = this.y
e[14] = this.z
var z = vec1
z.x = this.x - p.x
z.y = this.y - p.y
z.z = this.z - p.z
z.normalize()
var x = up.crossProduct(z.x,z.y,z.z, vec2)
x.normalize()
var y = z.crossProduct(x.x,x.y,x.z, vec3)
y.normalize()
e[0] = x.x
e[1] = x.y
e[2] = x.z
e[4] = y.x
e[5] = y.y
e[6] = y.z
e[8] = z.x
e[9] = z.y
e[10] = z.z*/
/*/less code, more computing
var dx = p.x-this.x;
var dy = p.y-this.y;
var dz = p.z-this.z;
var rxy = Math.sqrt( Math.pow(dx,2) + Math.pow(dy,2) );
var lambda = Math.atan(dy/dx);
var phi = Math.atan(dz/rxy)
if (dx < 0) phi = phi + Math.PI;
if (dz < 0) lambda = -1 * lambda;
this.pitch = rxy
this.yaw = lambda*/
}
updateVelocity(now) {
this.vely += -0.02
if (this.vely < -1.5) {
this.vely = -1.5
}
let drag = this.onGround ? 0 : 0.9
this.velz += (this.velz * drag - this.velz)
this.velx += (this.velx * drag - this.velx)
// this.vely += (this.vely * 0.9 - this.vely) * dt
}
update() {
let now = performance.now()
this.updateVelocity(now)
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
this.canFacePlayer = true
}
render() {
let diff = (performance.now() - this.lastUpdate) / tickTime
if (diff > 1) diff = 1
let renderx = (this.x - this.previousX) * diff + this.previousX
let rendery = (this.y - this.previousY) * diff + this.previousY
let renderz = (this.z - this.previousZ) * diff + this.previousZ
if(this.canFacePlayer){
this.facePlayer()
this.canFacePlayer = false
}
const offsetY = this.offsetY
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(renderx, rendery + offsetY, renderz)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSamplerParticle, 0)
gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
}
}
class BlockParticle extends Particle{
constructor(tex, x,y,z, type){
let s=4/16
let bs = 3/16 //particle size
let p=1/(16+4)
let offX = random(p), offY = random(p)
let velx = (Math.random()-0.5) * 0.3,
vely = Math.random() * 0.2,
velz = (Math.random()-0.5) * 0.3
let despawn = Math.random()*3000
switch(type){
case "breaking":
bs /= 2
despawn /= 4
velx /= 2
vely /= 2
velz /= 2
break
}
const shape = shapes.blockParticle
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texVerts = textureCoords[textureMap[tex]]
let tx = texVerts[0] + offX
let ty = texVerts[1] + offY
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = tx + (texShapeVerts[0]*s)
texture[index + 1] = ty + (texShapeVerts[1]*s)
texture[index + 2] = tx + (texShapeVerts[2]*s)
texture[index + 3] = ty + (texShapeVerts[3]*s)
texture[index + 4] = tx + (texShapeVerts[4]*s)
texture[index + 5] = ty + (texShapeVerts[5]*s)
texture[index + 6] = tx + (texShapeVerts[6]*s)
texture[index + 7] = ty + (texShapeVerts[7]*s)
index += 8
}
}
super(x, y, z, 0, 0, velx, vely, velz, bs, bs, bs, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, despawn)
}
}
win.BlockParticle = BlockParticle
class PoofParticle extends Particle{
constructor(x,y,z){
super(x, y, z, 0, 0, rand(-0.05, 0.05), 0, rand(-0.05, 0.05), 0.5, 0.5, 0.5, null, null, genericVaos.size, rand(1000, 3000), genericVaos[floor(rand(8))])
this.brightness = rand(0.8, 1)
this.speed = rand(0.01, 0.05)
}
update(){
let now = performance.now()
this.updateVelocity(now)
this.vely = this.speed
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
this.canFacePlayer = true
}
render(){
if(this.canFacePlayer){
this.facePlayer()
this.canFacePlayer = false
}
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(this.x, this.y, this.z)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0) * this.brightness
gl.bindTexture(gl.TEXTURE_2D, genericTexture)
gl.uniform1i(glCache.uSamplerParticle, 6)
gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
gl.uniform1i(glCache.isTextureAtlasParticle, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
gl.uniform1i(glCache.isTextureAtlasParticle, 1)
}
}
win.PoofParticle = PoofParticle
function poof(x,y,z){
for(var i=0; i<20; i++){
world.particles.push(new PoofParticle(x,y,z))
}
}
win.poof = poof
function playerPoof(player){
var {x,y,z} = player
y += player.offsetY
y -= 1/4
var space = 1/4
let w2 = 1 * 1
let d2 = 1 * 1
let h2 = 1.2 * 1.2
for (let Y = -h2; Y < h2; Y+=space) {
for (let X = -w2; X <= w2; X+=space) {
for (let Z = -d2; Z <= d2; Z+=space) {
let n = X * X / w2 + Y * Y / h2 + Z * Z / d2
if (n < 1) {
world.particles.push(new PoofParticle(x+X,y+Y,z+Z))
}
}
}
}
}
win.playerPoof = playerPoof
class ExplodeParticle extends Particle{
constructor(x,y,z){
var vao = explodeVaos[8]
var frameTime = 25
super(x, y, z, 0, 0, 0, 0, 0, 2, 2, 2, null, null, explodeVaos.size, explodeVaos.length*frameTime, vao)
this.index = 0
this.brightness = (Math.random()/2)+0.5
this.frameTime = frameTime
}
update(){
let now = performance.now()
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
this.index = Math.floor((now - this.spawn) / this.frameTime)
this.vao = explodeVaos[this.index]
this.canFacePlayer = true
}
render(){
if(this.canFacePlayer){
this.facePlayer()
this.canFacePlayer = false
}
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(this.x, this.y, this.z)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0) * this.brightness
gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
gl.uniform1i(glCache.uSamplerParticle, 3) //explode texture
gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
gl.uniform1i(glCache.isTextureAtlasParticle, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
gl.uniform1i(glCache.isTextureAtlasParticle, 1)
}
}
win.ExplodeParticle = ExplodeParticle
class TNTSmokeParticle extends Particle {
constructor(x,y,z){
var frameTime = tickTime
super(x, y, z, 0, 0, rand(-0.02,0.02), 0, rand(-0.02,0.02), 0.125, 0.125, 0.125, null, null, genericVaos.size, genericVaos.length*frameTime, genericVaos[0])
this.brightness = rand(0, 0.2)
this.speed = 0.05
this.frameTime = frameTime
}
update(){
let now = performance.now()
this.updateVelocity(now)
this.vely = this.speed
this.move(now)
if (now - this.spawn > this.despawns) {
this.canDespawn = true
}
this.index = genericVaos.length - 1 - Math.floor((now - this.spawn) / this.frameTime)
this.vao = genericVaos[this.index]
this.canFacePlayer = true
}
render(){
if(this.canFacePlayer){
this.facePlayer()
this.canFacePlayer = false
}
const modelMatrix = new Matrix();
modelMatrix.identity()
modelMatrix.translate(this.x, this.y, this.z)
modelMatrix.rotY(this.yaw)
modelMatrix.rotX(this.pitch)
modelMatrix.scale(this.width, this.height, this.depth)
const viewMatrix = p.transformation.elements
const proj = p.projection
const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
const modelViewProjectionMatrix = new Matrix()
modelViewProjectionMatrix.identity()
modelViewProjectionMatrix.mult(projectionMatrix)
modelViewProjectionMatrix.mult(viewMatrix)
modelViewProjectionMatrix.mult(modelMatrix.elements)
// row major to column major
modelViewProjectionMatrix.transpose()
const x = round(this.x)
const y = round(this.y)
const z = round(this.z)
const blockLight = world.getLight(x, y, z, 1)
const skysLight = world.getLight(x, y, z, 0)
const lightLevel = min(max(skysLight * skyLight / 15, blockLight / 15) * 0.9 + 0.1, 1.0) * this.brightness
gl.bindTexture(gl.TEXTURE_2D, genericTexture)
gl.uniform1i(glCache.uSamplerParticle, 6)
gl.uniform1f(glCache.uLightLevelParticle, lightLevel)
gl.uniformMatrix4fv(glCache.uViewParticle, false, modelViewProjectionMatrix.elements)
gl.uniform1i(glCache.isTextureAtlasParticle, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
gl.uniform1i(glCache.isTextureAtlasParticle, 1)
}
}
win.TNTSmokeParticle = TNTSmokeParticle
function initParticles(){
win.explodeVaos = explodeVaos
let shape = shapes.blockParticle
explodeVaos.size = shape.size
let shapeVerts = shape.verts
for(let y=0; y<4; y++){
for(let x=0; x<4; x++){
var texSize = 1/4
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let tx = x / 4
let ty = y / 4
texture[index    ] = tx + texSize
texture[index + 1] = ty
texture[index + 2] = tx
texture[index + 3] = ty
texture[index + 4] = tx
texture[index + 5] = ty + texSize
texture[index + 6] = tx + texSize
texture[index + 7] = ty + texSize
index += 8
}
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexParticle)
gl.enableVertexAttribArray(glCache.aTextureParticle)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
explodeVaos.push(vao)
}
}
//xp
shape = shapes.blockParticle
experienceOrbVaos.size = shape.size
shapeVerts = shape.verts
for(let y=0; y<4; y++){
for(let x=0; x<4; x++){
var texSize = 1/4
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let tx = x / 4
let ty = y / 4
texture[index    ] = tx + texSize
texture[index + 1] = ty
texture[index + 2] = tx
texture[index + 3] = ty
texture[index + 4] = tx
texture[index + 5] = ty + texSize
texture[index + 6] = tx + texSize
texture[index + 7] = ty + texSize
index += 8
}
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexParticle)
gl.enableVertexAttribArray(glCache.aTextureParticle)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
experienceOrbVaos.push(vao)
}
}
//generic particle
shape = shapes.blockParticle
genericVaos.size = shape.size
shapeVerts = shape.verts
for(let y=0; y<3; y++){
for(let x=0; x<3; x++){
var texSize = 1/3
let blockSides = Object.keys(Block)
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let tx = x / 3
let ty = y / 3
texture[index    ] = tx + texSize
texture[index + 1] = ty
texture[index + 2] = tx
texture[index + 3] = ty
texture[index + 4] = tx
texture[index + 5] = ty + texSize
texture[index + 6] = tx + texSize
texture[index + 7] = ty + texSize
index += 8
}
}
var vao = glExtensions.vertex_array_object.createVertexArrayOES()
const verticesBuffer = gl.createBuffer()
const textureBuffer = gl.createBuffer()
glExtensions.vertex_array_object.bindVertexArrayOES(vao)
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapeVerts.flat(Infinity)), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aVertexParticle, 3, gl.FLOAT, false, 0, 0)
gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW)
gl.vertexAttribPointer(glCache.aTextureParticle, 2, gl.FLOAT, false, 0, 0)
gl.enableVertexAttribArray(glCache.aVertexParticle)
gl.enableVertexAttribArray(glCache.aTextureParticle)
glExtensions.vertex_array_object.bindVertexArrayOES(null)
genericVaos.push(vao)
}
}
}
let analytics = {
totalTickTime: 0,
worstFrameTime: 0,
totalRenderTime: 0,
totalFrameTime: 0,
lastUpdate: 0,
frames: 1,
displayedTickTime: "0",
displayedRenderTime: "0",
displayedFrameTime: "0",
displayedwFrameTime: 0,
fps: 0,
}
function chunkDist(c) {
let dx = p.x - c.x
let dz = p.z - c.z
if (dx > 16) {
dx -= 16
} else if (dx > 0) {
dx = 0
}
if (dz > 16) {
dz -= 16
} else if (dz > 0) {
dz = 0
}
return Math.sqrt(dx * dx + dz * dz)
}
function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
let dx1 = p.x - c1.x - 8
let dy1 = p.z - c1.z - 8
let dx2 = p.x - c2.x - 8
let dy2 = p.z - c2.z - 8
return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
}
function fillReqs(x, z) {
// Chunks must all be loaded first.
var done = true
for (let i = x - 3; i <= x + 3; i++) {
for (let j = z - 3; j <= z + 3; j++) {
let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
if (!chunk.generated) {
world.generateQueue.push(chunk)
done = false
}
if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2) {
world.populateQueue.push(chunk)
done = false
}
if (world.loadFrom.length && !chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
world.loadQueue.push(chunk)
done = false
} else if (!world.loadFrom.length && !chunk.loaded) {
chunk.loaded = true
}
if (!chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
world.lightingQueue.push(chunk)
done = false
}
}
}
return done
}
function maxDist(x, z, x2, z2) {
let ax = abs(x2 - x)
let az = abs(z2 - z)
return max(ax, az)
}
function renderFilter(chunk) {
return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
}
function debug(message) {
let ellapsed = performance.now() - debug.start
if (ellapsed > 30) {
console.log(message, ellapsed.toFixed(2), "milliseconds")
}
}
function updateUserTo(fetchRes){
if(typeof fetchRes === "object"){
username = fetchRes.username
userInfo = fetchRes
//p.character.changeBlock(abs(r.hashCode()) % 80 + 1)
if(fetchRes.skin) p.character.setSkin(fetchRes.skin)
return username
}else{
username = "Steve"
userInfo = null
return null
}
}
function login(){
return new Promise((resolve, reject) => {
var w = width / 2
var h = height / 2
var x = w - (w/2)
var y = h - (h/2)
var w = open("https://www.thingmaker.repl.co/website/login.html", "login","resizable=no,width="+w+",height="+h+",top="+y+",left="+x)
function onmsg(event){
if (event.source !== w) return;
if (event.data.startsWith("logged:")){
w.close()
window.removeEventListener("message", onmsg);
resolve(event.data.replace("logged:",''))
}else if(event.data === "canceled"){
w.close()
window.removeEventListener("message", onmsg);
reject()
}
}
window.addEventListener("message", onmsg);
})
}
var achexUsername = "player"+Date.now()
win.username = "Steve"
win.userInfo = null
async function loggedIn(){
var logged = false;
await fetch("https://server.thingmaker.repl.co/account", {credentials:"include"}).then(r => r.json()).then(r => {
logged = updateUserTo(r)
})
if(logged){
username = logged
return logged
}else{
if(confirm("Your not logged in. Head over to www.thingmaker.repl.co/login.html to login.\n\nPress OK to login,")){
var logged
await login().then(r => logged=r).catch(r => logged=r)
if(logged){
username = logged
await fetch("https://server.thingmaker.repl.co/account", {credentials:"include"}).then(r => r.json()).then(r => {
updateUserTo(r)
})
return logged
}
}
return false
changeScene("main menu")
}
}
async function getWorlds(pingCallback){
if(!navigator.onLine) return "offline"
var logged = await loggedIn()
if(!logged){
return "notLoggedIn"
}
var worlds
await fetch("https://server.thingmaker.repl.co/worlds").then(r => r.json()).then(r => worlds=r).catch(e => logError(e))
if(pingCallback){
fetch("https://server.thingmaker.repl.co/worldsPing").then(r => r.json()).then(pingCallback).catch(e => logError(e))
}
return worlds
}
var multiplayer = null
var multiplayerError = null
var players = {}
win.playersInv = {}
win.playerSkins = {}
function hasPlayer(username){
for(var i in players){
if(players[i].username === username) return true
}
}
function getPlayerByUsername(username){
for(var i in players){
if(players[i].username === username) return players[i]
}
}
/*const hub = "Minekhan"
function sendHub(obj){
let str = JSON.stringify({
"toH": hub,
"msg": JSON.stringify(obj)
})
multiplayer.send(str)
return str
}
function sendUser(user, obj){
let str = JSON.stringify({
"to": user,
"msg": JSON.stringify(obj)
})
multiplayer.send(str)
return str
}*/
function send(msg, to){
if(!multiplayer){
console.warn("Multiplayer WebSocket is not created. Trying to send:",msg)
return
}
if(multiplayer.readyState !== WebSocket.OPEN){
console.warn("WebSocket is not in open state. Current state is: "+multiplayer.readyState+". Trying to send: ",msg)
return
}
msg.FROM = achexUsername
msg.USER = username
if(to) msg.TO = to
multiplayer.send(JSON.stringify(msg))
}
var host
function initMultiplayer(target){
if(multiplayer) return
var ban = []
host = false
if(!target){
target = world.id || 0
host = true
}
players = {} //empty
multiplayerError = null
multiplayer = new WebSocket("wss://server.thingmaker.repl.co/ws?target="+target)
multiplayer.onopen = e => {
/*multiplayer.send(JSON.stringify({
"auth": achexUsername,
"passwd":"none"
}))
multiplayer.send(JSON.stringify({
"joinHub":hub,
"passwd":"none"
}))*/
send({
"type":"connect",
username: username,
id: achexUsername
})
if(host){
send({
"type":"init",
name: world.name
})
}
send({type:"mySkin", data:p.character.skinURL})
send({
"type":"getSave"
})
var invStuff = {}
var shouldSendInvStuff = false
multiplayer.pos = setInterval(() => {
if(world){
invStuff.invItems = invItems
invStuff.hotbar = inventory.hotbar
invStuff.x = p.x
invStuff.y = p.y
invStuff.z = p.z
invStuff.survival = survival
invStuff.survivStr = world.getSurvivStr()
shouldSendInvStuff = true
if(host){
send({type:"entityPosAll", data: world.getEntities()})
}
}
}, 500)
multiplayer.sendPos = () => {
var obj = {type:"pos", data:p3, host:host, dimension: world.type}
if(shouldSendInvStuff){
obj.inv = invStuff
obj.worldSettings = worldSettings
shouldSendInvStuff = false
}
send(obj)
}
}
multiplayer.onmessage = msg => {
let packet = JSON.parse(msg.data)
var author = packet.FROM //should be the id
var data = packet//.msg ? JSON.parse(packet.msg) : {}
if(data.type === "ping"){
send({
type:"pong",
data:Date.now()
})
}else if(data.type === "getSave"){
if(host){
if(ban.includes(data.USER)){
send({
type: "ban",
data: data.USER
}, author)
}else{
send({
type:"loadSave",
data:world.getSaveString(),
nether:world.getNetherSaveString(),
tags: world.getEditedTags(),
mod: world.mod,
id: world.id || Date.now(),
time: worldTime,
dimension: world.type || "overworld",
cheats:cheats,
inv: playersInv[data.USER]
}, author)
}
}
send({type:"mySkin", data:p.character.skinURL})
}else if(data.type === "loadSave"){
dimensions = {
overworld: new World(),
nether: new World("nether")
}
world = dimensions.overworld
world.id = data.id
if (data.data) {
try {
world.loadSave(data.data)
}catch(e) {
alert("Unable to load save code. Error: "+e)
return
}
}
if (data.nether) {
let world = dimensions.nether
try {
world.loadSave(data.nether)
}catch(e) {
alert("Unable to load nether save code. Error: "+e)
return
}
}
if(survival){
setHotbar([0,0,0,0,0,0,0,0,0])
clearInv()
}
world = dimensions[data.dimension || "overworld"]
worldTime = data.time
cheats = data.cheats
if(data.inv){
invItems = data.inv.invItems
inventory.hotbar = data.inv.hotbar
if(data.inv.x){
p.x = data.inv.x
p.y = data.inv.y
p.z = data.inv.z
}
survival = data.inv.survival || false
if(data.survivStr) world.loadSurvivStr(data.survivStr)
}
world.editedTagsToLoad = data.tags
world.mod = data.mod
if(data.mod){
try{
var mod = Function("return "+data.mod)()
mod()
}catch(e){console.log("error loading mod: "+e)}
}
changeScene("loading")
}else if(data.type === "mySkin"){
playerSkins[author] = data.data
}else if(data.type === "pos"){
var pos = data.data
if(!players[author]){
players[author] = new Player(abs( (pos.username || "").hashCode()) % 80 + 1)
}
let thisplayer = players[author]
thisplayer.setPos(pos.x,pos.y,pos.z)
thisplayer.setRot(pos.rx, pos.ry)
thisplayer.sneaking = pos.sneaking
thisplayer.dimension = data.dimension
thisplayer.id = author
thisplayer.survival = pos.survival
thisplayer.harmEffect = pos.harmEffect
if(thisplayer.username !== pos.username){
thisplayer.username = pos.username
//thisplayer.changeBlock(abs((pos.username || "").hashCode()) % 80 + 1)
}
thisplayer.crackPos = pos.crackPos
thisplayer.crack = pos.crack //crack number
thisplayer.burning = pos.burning
thisplayer.holding = pos.holding || 0
thisplayer.walking = pos.walking
thisplayer.sprinting = pos.sprinting
thisplayer.punchEffect = pos.punchEffect
if(data.host){
worldTime = pos.time
}
if(data.inv) playersInv[data.USER] = data.inv
if(!thisplayer.skinSet && playerSkins[author]){
thisplayer.setSkin(playerSkins[author])
}
if(data.host && data.worldSettings){
Object.assign(worldSettings, data.worldSettings)
}
}else if(data.type === "dc"){
if(players[data.data]){
if(world) playerPoof(players[data.data]) //cool effect
delete players[data.data]
}
}else if(data.type === "setBlock"){
if(world){
let pos = data.data
let world = dimensions[pos.dimension]
let prevBlock = world.getBlock(pos.x, pos.y, pos.z)
world.setBlock(pos.x, pos.y, pos.z, pos.block, false, false, true, pos.keepTags)
}
}else if(data.type === "setTags"){
if(world){
let world = getWorld(data.dimension)
world.setTags(data.x,data.y,data.z,data.data, true)
}
}else if(data.type === "entityPos"){
if(world){
let world = getWorld(data.dimension)
world.posEntity(data, true)
}
}else if(data.type === "entityPosAll"){
if(world){
var arr = data.data
//if(arr.length !== world.entities.length) world.entities = []
for(var i=0; i<arr.length; i++){
let world = getWorld(arr[i].dimension)
world.posEntity(arr[i], true)
}
}
}else if(data.type === "entityDelete"){
if(world){
world.deleteEntity(data.id, true)
}
}else if(data.type === "achievment"){
Messages.add(data.USER+" earned the achievment: "+data.data)
}else if(data.type === "diamondsToYou"){
achievment("Diamonds to you!")
}else if(data.type === "hit"){
if(survival){
damage(data.data || 1, data.message || (data.username+" killed "+username))
p.velocity.x += data.velx || 0
p.velocity.z += data.velz || 0
}
}else if(data.type === "harmEffect"){
if(players[data.id]) players[data.id].harmEffect = 40
}else if(data.type === "kill"){
dieMessage = data.data
die()
}else if(data.type === "die"){
var ent = players[data.id]
if(ent){
ent.die = true
if(world) poof(ent.x, ent.y, ent.z)
}
Messages.add(data.message)
}else if(data.type === "message"){
if(data.fromServer){
Messages.add(data.data)
}else{
Messages.write(data.data, data.username)
}
}else if(data.type === "playSound"){
var volume = 1
if((data.x || data.x === 0)){
volume = posSound(data.x,data.y,data.z)
}
if(data.volume) volume *= data.volume
playSound(data.data, 0, volume, data.pitch)
}else if(data.type === "eval"){
console.log("Evaluating script: "+data.data)
try{
eval(data.data)
}catch(e){
console.error(e)
}
}else if(data.type === "error"){
if(host){
alert(data.data)
}else{
console.warn("Multiplayer error!",data.data)
multiplayerError = data.data
}
}
}
multiplayer.onclose = () => {
if(host){
alert("Multiplayer connection lost!")
}else{
releasePointer()
multiplayerError = multiplayerError || "Disconnected from server"
changeScene("multiplayer lost")
}
clearInterval(multiplayer.pos)
multiplayer = null
}
multiplayer.onerror = e => {
console.warn("WebSocket error!", e)
multiplayerError = e
multiplayer.close()
}
win.ban = (username, why) => {
if(!host) return alert("Only the host can ban players.")
send({
type: "ban",
data: username,
reason:why
})
if(!ban.includes(username)) ban.push(username)
}
win.unban = username => {
if(!host) return alert("Only the host can unban players.")
if(ban.includes(username)) {
var i = ban.indexOf(username)
if(i === -1) return
ban.splice(i,1)
}
}
}
function getNetherBiome(biome) {
if(biome > 0.4 && biome < 0.5){
return 1
}else if(biome > 0.4){
return 2
}
return 0
}
function getBiome(biome){
if(biome > 0.6){
return "snowyField"
}else if(biome > 0.5){
return "desert"
}else if(biome > 0.4){
return "field"
}else if(biome > 0.37){
return "jungle"
}else if(biome > 0.35){
return "giantJungle"
}else if(biome > 0.3){
return "bambooForest"
}else{
return "oakForest"
}
}
function getBiomeTemperature(biome){
var t
switch(biome){
case "snowyField":
t = 2
break
case "desert":
t = 17
break
case "field":
t = 9
break
case "giantJungle":
t = 12
break
case "oakForest":
t = 9
break
//nether
case 0: //nether wastes
t = 18
break
case 1://crimson and warped forests
case 2:
t = 16
break
default:
t = 10
break
}
return t
}
function getDimension(){
if(world.type === ""){
return "overworld"
}else return world.type
}
function getWorld(d){
if(!dimensions) return
if(!d){
d = "overworld"
}
return dimensions[d]
}
win.getWorld = getWorld
let skyLight = 0
let worldTime = 0 //current in-game time
let fogDist = 16
class World {
constructor(type) {
generatedChunks = 0
fogDist = 16
p.y = superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
this.type = type || ""
this.spawnPoint = {
x: 8,
y: p.y,
z: 8
}
//Initialize the world's arrays
this.chunks = []
this.loaded = []
this.sortedChunks = []
this.doubleRenderChunks = []
this.offsetX = 0
this.offsetZ = 0
this.lwidth = 0
this.chunkGenQueue = []
this.populateQueue = []
this.generateQueue = []
this.lightingQueue = []
this.loadQueue = []
this.meshQueue = []
this.loadFrom = []
this.entities = []
this.particles = []
this.lastChunk = ","
this.edited = false
this.saveStr = null
this.hasLoaded = false
this.editedTags = []
this.editedTagsToLoad = null
}
genChunk(chunk) {
let x = chunk.x >> 4
let z = chunk.z >> 4
let trueX = chunk.x
let trueZ = chunk.z
if (chunk.generated) {
return false
}
let hide = !loadString
let smoothness = generator.smooth
let hilliness = generator.height
let biomeSmooth = generator.biomeSmooth
//{ for the nether terrain
const biomeSize = 1//0.001 // smaller = bigger
const flatness = 40 // bigger = flatter
const overhang = 3 // bigger = more overhang; flatter = less overhang
const bottom = 4 // Minimum height of the ground
const hillSize = 0.006 // smaller = bigger; 0.005 to 0.01 seems the be a reasonable range
//}
let gen = 0, floatGen = 0
for (let i = 0; i < 16; i++) {
for (let k = 0; k < 16; k++) {
floatGen = noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness + generator.extra
gen = superflat === "island" && this.type === "" ? win.islandGenerator.GetHeight(x*16+i, z*16+k) : (superflat ? 4 : Math.round(floatGen))
if(this.type === "nether" && superflat){
gen = Math.round(floatGen)
}
chunk.tops[k * 16 + i] = gen
if(this.type === "nether"){
let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth)
let b = getNetherBiome(biome)
chunk.biomes[k * 16 + i] = b
let block = blockIds.netherrack
if(b === 1){
block = blockIds.warpedNylium
}else if(b === 2){
block = blockIds.crimsonNylium
}
const smo = noise((trueX + i) * biomeSize, (trueZ + k) * biomeSize) * flatness + 40
let top = 0
let solid = true
for (let j = 1; j < 128; j++) {
if (noise((trueX + i)/smo, overhang*j/smo, (trueZ + k)/smo) - (j - bottom) * hillSize > 0) {
chunk.setBlock(i, j, k, blockIds.netherrack)
top = j
solid = true
} else if (solid) {
chunk.setBlock(i, j - 1, k, block)
/*if (chunk.getBlock(i, j - 2, k)) chunk.setBlock(i, j - 2, k, block)
if (chunk.getBlock(i, j - 3, k)) chunk.setBlock(i, j - 3, k, block)
if (chunk.getBlock(i, j - 4, k)) chunk.setBlock(i, j - 4, k, block)*/
solid = false
} else if(j < 80){
chunk.setBlock(i, j-1, k, blockIds.Lava)
if(chunk.getBlock(i, j - 2, k) === block) chunk.setBlock(i, j-2, k, blockIds.netherrack)
}
}
chunk.tops[k * 16 + i] = top
chunk.setBlock(i, 0, k, blockIds.bedrock)
block = blockIds.netherrack
for(let j=1; j<gen; j++){
chunk.setBlock(i, maxHeight - 50 - j, k, block)
}
chunk.setBlock(i,maxHeight-50,k, blockIds.bedrock)
chunk.ceils[k * 16 + i] = maxHeight - 50 - gen
}else if (superflat === "island") {
if (win.islandGenerator.GetWaterDepth(x*16+i, z*16+k) > 0) {
chunk.setBlock(i, gen, k, blockIds.Water);
chunk.setBlock(i, gen - 1, k, blockIds.Water)
chunk.setBlock(i, gen - 2, k, blockIds.dirt)
chunk.setBlock(i, gen - 3, k, blockIds.dirt)
}   else {
let biomeHere =win.islandGenerator.GetBiomeType(x*16+i, z*16+k);
if (biomeHere === -3161286) {
chunk.setBlock(i, gen, k, blockIds.sand)
chunk.setBlock(i, gen - 1, k, blockIds.sand)
chunk.setBlock(i, gen - 2, k, blockIds.sand)
chunk.setBlock(i, gen - 3, k, blockIds.sand)
}   else if (biomeHere === -1) {
chunk.setBlock(i, gen, k, blockIds.snowBlock)
chunk.setBlock(i, gen - 1, k, blockIds.snowBlock)
chunk.setBlock(i, gen - 2, k, blockIds.stone)
chunk.setBlock(i, gen - 3, k, blockIds.stone)
}   else if (biomeHere === -4934476 || biomeHere === -8355712 || biomeHere === -6963874) {
chunk.setBlock(i, gen, k, blockIds.stone)
chunk.setBlock(i, gen - 1, k, blockIds.stone)
chunk.setBlock(i, gen - 2, k, blockIds.stone)
chunk.setBlock(i, gen - 3, k, blockIds.stone)
} else if (biomeHere === -65536) {
chunk.setBlock(i, gen, k, blockIds.Lava)
chunk.setBlock(i, gen - 1, k, blockIds.stone)
chunk.setBlock(i, gen - 2, k, blockIds.stone)
chunk.setBlock(i, gen - 3, k, blockIds.stone)
} else {
chunk.setBlock(i, gen, k, blockIds.grass)
chunk.setBlock(i, gen - 1, k, blockIds.dirt)
chunk.setBlock(i, gen - 2, k, blockIds.dirt)
chunk.setBlock(i, gen - 3, k, blockIds.dirt)
}
}
} else if(superflat){
chunk.tops[k * 16 + i] = gen;
chunk.setBlock(i, gen, k, blockIds.grass);
chunk.setBlock(i, gen - 1, k, blockIds.dirt);
chunk.setBlock(i, gen - 2, k, blockIds.dirt);
chunk.setBlock(i, gen - 3, k, blockIds.dirt);
}else{
let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
var b = getBiome(biome)
chunk.biomes[k * 16 + i] = b
if(b === "desert"){
chunk.tops[k * 16 + i] = gen;
chunk.setBlock(i, gen, k, blockIds.sand);
chunk.setBlock(i, gen - 1, k, blockIds.sand);
chunk.setBlock(i, gen - 2, k, blockIds.sandstone);
chunk.setBlock(i, gen - 3, k, blockIds.sandstone);
if(gen<60) {
gen = 59;
chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
chunk.setBlock(i, gen, k, blockIds.Water);
chunk.setBlock(i, gen - 1, k, blockIds.Water);
chunk.setBlock(i, gen - 2, k, blockIds.gravel);
chunk.setBlock(i, gen - 3, k, blockIds.gravel);
}
if(gen>120){
chunk.setBlock(i, gen, k, blockIds.stone);
}
if(gen>140){
chunk.setBlock(i, gen, k, blockIds.sand);
}
}
if(b === "field" || b === "oakForest"){
chunk.tops[k * 16 + i] = gen;
chunk.setBlock(i, gen, k, blockIds.grass);
chunk.setBlock(i, gen - 1, k, blockIds.dirt);
chunk.setBlock(i, gen - 2, k, blockIds.dirt);
chunk.setBlock(i, gen - 3, k, blockIds.dirt);
if(gen<60) {
gen = 59;
chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
chunk.setBlock(i, gen, k, blockIds.Water);
chunk.setBlock(i, gen - 1, k, blockIds.Water);
chunk.setBlock(i, gen - 2, k, blockIds.gravel);
chunk.setBlock(i, gen - 3, k, blockIds.gravel);
}
}
if(b === "snowyField"){
chunk.tops[k * 16 + i] = gen;
if(gen >= 60){
var h = ceil(((floatGen + 0.5) % 1) * 8)
switch(h){//really smooth terrain!
case 1:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER1)
break
case 2:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER2)
break
case 3:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER3)
break
case 4:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER4)
break
case 5:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER5)
break
case 6:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER6)
break
case 7:
chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER7)
break
case 8:
chunk.setBlock(i, gen + 1, k, blockIds.snowBlock)
break
}
chunk.setBlock(i, gen, k, blockIds.grass | CROSS);
chunk.setBlock(i, gen - 1, k, blockIds.dirt);
chunk.setBlock(i, gen - 2, k, blockIds.dirt);
chunk.setBlock(i, gen - 3, k, blockIds.dirt);
}
if(gen<60) {
gen = 59;
chunk.setBlock(i, gen+1, k, blockIds.ice);
chunk.setBlock(i, gen, k, blockIds.ice);
chunk.setBlock(i, gen - 1, k, blockIds.Water);
chunk.setBlock(i, gen - 2, k, blockIds.gravel);
chunk.setBlock(i, gen - 3, k, blockIds.gravel);
}
}
if(b === "jungle" || b === "giantJungle" || b === "bambooForest"){
chunk.tops[k * 16 + i] = gen;
if(b === "bambooForest") chunk.setBlock(i, gen, k, blockIds.podzol)
else chunk.setBlock(i, gen, k, blockIds.mossBlock)
chunk.setBlock(i, gen - 1, k, blockIds.dirt);
chunk.setBlock(i, gen - 2, k, blockIds.dirt);
chunk.setBlock(i, gen - 3, k, blockIds.dirt);
if(gen<60) {
chunk.setBlock(i, 60, k, blockIds.Water | SLAB);
for(var y=59; y>=gen; y--){
chunk.setBlock(i, y, k, blockIds.Water);
}
chunk.setBlock(i, gen, k, blockIds.gravel);
chunk.setBlock(i, gen - 1, k, blockIds.gravel);
}
}
}
if(this.type !== "nether"){
for (let j = 1; j < gen - 3; j++) {
chunk.setBlock(i, j, k, blockIds.stone)
}
chunk.setBlock(i, 0, k, blockIds.bedrock)
}
}
}
chunk.generated = true
}
getAdjacentSubchunks(x, y, z, lights) {
let minChunkX = x - 16 >> 4
let maxChunkX = x + 16 >> 4
let minChunkY = y - 16 >> 4
let maxChunkY = y + 16 >> 4
let minChunkZ = z - 16 >> 4
let maxChunkZ = z + 16 >> 4
let section = null
let ret = []
for (x = minChunkX; x <= maxChunkX; x++) {
for (let y = minChunkY; y <= maxChunkY; y++) {
for (z = minChunkZ; z <= maxChunkZ; z++) {
if (y < 0) {
ret.push(lights ? emptySection.light : emptySection.blocks)
} else if (this.chunks[x] && this.chunks[x][z]) {
section = this.chunks[x][z].sections[y] || emptySection
ret.push(lights ? section.light : section.blocks)
} else {
ret.push(lights ? emptySection.light : emptySection.blocks)
}
}
}
}
return ret
}
updateBlock(x, y, z, lazy, leaveMe) {
let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
if (chunk && chunk.buffer) {
chunk.updateBlock(x & 15, y, z & 15, this, lazy, leaveMe)
}
}
getChunk(x, z) {
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
return this.loaded[X * this.lwidth + Z]
}
getWorldBlock(x, y, z) {
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return blockIds.air
}
return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
}
getBlock(x, y, z) {
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
if (y > maxHeight) {
return blockIds.air
} else if (y < 0) {
return blockIds.air
} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
return this.getWorldBlock(x, y, z)
}
return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15)
}
setBlock(x, y, z, blockID, lazy, leaveSelf, remote, keepTags) {
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return
}
if(y < 0) return
let chunk = this.chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
var prev = chunk.getBlock(xm,y,zm)
if (blockID) {
chunk.setBlock(xm, y, zm, blockID, !lazy)
let data = blockData[blockID]
if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
this.updateLight(x, y, z, true, data.lightLevel)
}
} else {
let data = blockData[chunk.getBlock(xm, y, zm)]
chunk.deleteBlock(xm, y, zm, !lazy)
if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
this.updateLight(x, y, z, false, data.lightLevel)
}
}
if (lazy) {
return
}
var prevTags = this.getTags(x,y,z)
if(!keepTags) this.setTags(x, y, z, null)
if(prev && blockData[prev].ondelete){
blockData[prev].ondelete(x,y,z, prevTags)
}
if(blockID && blockData[blockID].onplace){
blockData[blockID].onplace(x,y,z)
}
if(multiplayer && !remote){
send({type:"setBlock", data:{x:x, y:y, z:z, block:blockID, dimension:getDimension(), keepTags:keepTags}})
}
//Update the 6 adjacent blocks and 1 changed block
if (xm && xm !== 15 && zm && zm !== 15) {
chunk.updateBlock(xm - 1, y, zm, this, lazy)
chunk.updateBlock(xm, y - 1, zm, this, lazy)
chunk.updateBlock(xm + 1, y, zm, this, lazy)
chunk.updateBlock(xm, y + 1, zm, this, lazy)
chunk.updateBlock(xm, y, zm - 1, this, lazy)
chunk.updateBlock(xm, y, zm + 1, this, lazy)
}
else {
this.updateBlock(x - 1, y, z, lazy)
this.updateBlock(x + 1, y, z, lazy)
this.updateBlock(x, y - 1, z, lazy)
this.updateBlock(x, y + 1, z, lazy)
this.updateBlock(x, y, z - 1, lazy)
this.updateBlock(x, y, z + 1, lazy)
}
chunk.updateBlock(xm, y, zm, this, lazy, leaveSelf)
// Update the corner chunks so shadows in adjacent chunks update correctly
if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
this.edited = true
}
tagsChanged(x,y,z, t, remote){
var str = x.toString(36)+","+y.toString(36)+","+z.toString(36)
if(t){
if(!this.editedTags.includes(str)) this.editedTags.push(str)
}else{
if(this.editedTags.includes(str)){
this.editedTags.splice(this.editedTags.indexOf(str),1)
}
}
if(multiplayer && !remote){
send({type:"setTags", x:x, y:y, z:z, data:t, dimension:getDimension()})
}
}
getWorldTags(x, y, z) {
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return
}
return this.chunks[x >> 4][z >> 4].getTags(x & 15, y, z & 15)
}
getTags(x,y,z){
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
if (y > maxHeight) {
return
} else if (y < 0) {
return
} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
return this.getWorldTags(x, y, z)
}
return this.loaded[X * this.lwidth + Z].getTags(x & 15, y, z & 15)
}
getTagByName(x,y,z,n){
var t = this.getTags(x,y,z)
return t && t[n]
}
setTags(x,y,z,data, remote){
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return
}
if(y < 0) return
let chunk = this.chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
chunk.setTags(xm, y, zm, data)
this.tagsChanged(x,y,z,data, remote)
}
setTagByName(x,y,z,n,data, remote){
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return
}
if(y < 0) return
let chunk = this.chunks[x >> 4][z >> 4]
let xm = x & 15
let zm = z & 15
var t = chunk.setTagByName(xm, y, zm, n,data)
this.tagsChanged(x,y,z,t, remote)
}
updateTags(x,y,z){
var t = world.getTags(x,y,z)
this.tagsChanged(x,y,z,t)
}
getLight(x, y, z, blockLight = 0) {
if(y < 0) return 0
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
if(this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]){
return this.chunks[x >> 4][z >> 4].getLight(x & 15, y, z & 15, blockLight)
}
}
if(this.loaded[X * this.lwidth + Z]){
return this.loaded[X * this.lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
}
return 15
}
setLight(x, y, z, level, block) {
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
if (this.loaded[X * this.lwidth + Z]) {
return this.loaded[X * this.lwidth + Z].setLight(x & 15, y, z & 15, level, block)
}
}
updateLight(x, y, z, place, blockLight = 0) {
let chunk = this.getChunk(x, z)
let cx = x & 15
let cz = z & 15
let center = chunk.getLight(cx, y, cz, 0)
let blight = chunk.getLight(cx, y, cz, 1)
let up = this.getLight(x, y+1, z)
let down = this.getLight(x, y-1, z)
let north = this.getLight(x, y, z+1)
let south = this.getLight(x, y, z-1)
let east = this.getLight(x+1, y, z)
let west = this.getLight(x-1, y, z)
let spread = []
if (!place) { // Block was removed; increase light levels
if ((up & 15) === 15) {
for (let i = y; i > 0; i--) {
if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
chunk.setLight(cx, i, cz, 15)
spread.push(x, i, z)
} else {
break
}
}
chunk.spreadLight(spread, 14, true)
} else {
center = max(up, down, north, south, east, west)
if (center > 0) center -= 1
this.setLight(x, y, z, center)
if (center > 1) {
spread.push(x, y, z)
chunk.spreadLight(spread, center - 1, true)
}
}
// Block light levels
if (!blockLight || blockLight < blight) {
spread.length = 0
up = this.getLight(x, y+1, z, 1)
down = this.getLight(x, y-1, z, 1)
north = this.getLight(x, y, z+1, 1)
south = this.getLight(x, y, z-1, 1)
east = this.getLight(x+1, y, z, 1)
west = this.getLight(x-1, y, z, 1)
blight = max(up, down, north, south, east, west)
if (blight > 0) blight -= 1
this.setLight(x, y, z, blight, 1)
if (blight > 1) {
spread.push(x, y, z)
chunk.spreadLight(spread, blight - 1, true, 1)
}
}
}
else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
let respread = []
for (let i = 0; i <= 15/*center + 1*/; i++) respread[i] = []
chunk.setLight(cx, y, cz, 0, 0)
chunk.setLight(cx, y, cz, 0, 1)
spread.push(x, y, z)
// Sky light
if (center === 15) {
for (let i = y-1; i > 0; i--) {
if (blockData[chunk.getBlock(cx, i, cz)].transparent) {
chunk.setLight(cx, i, cz, 0)
spread.push(x, i, z)
} else {
break
}
}
}
chunk.unSpreadLight(spread, center - 1, respread)
chunk.reSpreadLight(respread)
// Block light
if (blight) {
respread.length = 0
for (let i = 0; i <= 15/*blight + 1*/; i++) respread[i] = []
spread.length = 0
spread.push(x, y, z)
chunk.unSpreadLight(spread, blight - 1, respread, 1)
chunk.reSpreadLight(respread, 1)
}
}
if (place && blockLight) { // Light block was placed
this.setLight(x, y, z, blockLight, 1)
spread.length = 0
spread.push(x, y, z)
chunk.spreadLight(spread, blockLight - 1, true, 1)
} else if (!place && blockLight) { // Light block was removed
this.setLight(x, y, z, 0, 1)
spread.push(x, y, z)
let respread = []
for (let i = 0; i <= 15/*blockLight + 1*/; i++) respread[i] = []
chunk.unSpreadLight(spread, blockLight - 1, respread, 1)
chunk.reSpreadLight(respread, 1)
}
}
spawnBlock(x, y, z, blockID) {
//Sets a block anywhere without causing block updates around it. Only to be used in world gen.
if(blockData[blockID].crossShape) blockID |= CROSS
if(blockData[blockID].tallcrossShape) blockID |= TALLCROSS
if(blockData[blockID].cactus) blockID |= CACTUS
let chunkX = x >> 4
let chunkZ = z >> 4
if (!this.chunks[chunkX]) {
this.chunks[chunkX] = []
}
let chunk = this.chunks[chunkX][chunkZ]
if (!chunk) {
chunk = new Chunk(chunkX * 16, chunkZ * 16,this.type, this)
this.chunks[chunkX][chunkZ] = chunk
}
if (chunk.buffer) {
//Only used if spawning a block post-gen
this.setBlock(x, y, z, blockID, true)
} else if (!chunk.getBlock(x & 15, y, z & 15)) {
chunk.setBlock(x & 15, y, z & 15, blockID)
}
}
getBiome(x,y,z){
if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
return
}
var X = x & 15
var Z = z & 15
return this.chunks[x >> 4][z >> 4].biomes[Z * 16 + X]
}
getEntity(id){
for(var i=0; i<this.entities.length; i++){
if(this.entities[i].id === id){
return i
}
}
}
getEntPos(ent){
return {x:ent.x, y:ent.y, z:ent.z, yaw:ent.yaw, pitch:ent.pitch, block:ent.block, velx:ent.velx, vely:ent.vely, velz:ent.velz, amount:ent.amount, solidOnGround:ent.solidOnGround,harmEffect:ent.harmEffect, health:ent.health, from:ent.from, spawn:ent.spawn, value:ent.value, burning:ent.burning, durability:ent.durability}
}
addEntity(ent, remote){
if(!ent.id)ent.id = Date.now()
if(multiplayer && !remote){
//host controls entities
send({type:"entityPos", id:ent.id, entType:ent.type, pos:this.getEntPos(ent), dimension:this.type})
this.entities.push(ent)
}else{
this.entities.push(ent)
}
}
deleteEntity(id, remote, i){
i = (i || i===0) ? i : this.getEntity(id)
if(!(i || i===0)) return
var ent = this.entities[i]
if(multiplayer && !remote){
send({type:"entityDelete", id:ent.id})
}
this.entities.splice(i, 1)
}
posEntity(d, m){ //for multiplayer.onmessage only
let p = d.pos
var i = this.getEntity(d.id)
var ent
if(i || i===0){
ent = this.entities[i]
}else{
switch(d.entType){
case "Item":
ent = new Item(0, 0, 0, 0, 0, 0, p.block, false, p.amount, p.durability)
break
case "BlockEntity":
ent = new BlockEntity(p.block, 0,0,0, p.solidOnGround)
break
case "PrimedTNT":
ent = new PrimedTNT(0,0,0)
break
case "EnderPearl":
ent = new EnderPearl(0,0,0,0,0,0)
break
case "Snowball":
ent = new Snowball(0,0,0,0,0,0)
break
case "ExperienceOrb":
ent = new ExperienceOrb(0,0,0,p.value)
break
case "Cow":
ent = new Cow(0,0,0)
break
case "Pig":
ent = new Pig(0,0,0)
break
default:
break
}
if(!ent) return
ent.id = d.id
this.addEntity(ent, true)
}
if(!ent) return
ent.x = p.x
ent.y = p.y
ent.z = p.z
ent.yaw = p.yaw
ent.pitch = p.pitch
ent.velx = p.velx
ent.vely = p.vely
ent.velz = p.velz
ent.harmEffect = p.harmEffect
ent.health = p.health
ent.from = p.from
if(!m)ent.spawn = p.spawn
ent.burning = p.burning
}
getEntities(){
if(this.entities.length === 0) return this.entities //its an empty array, so no problems
return this.entities.map(ent => {
return {
id:ent.id,
entType:ent.type,
pos: this.getEntPos(ent),
dimension:this.type
}
})
}
tick() {
let tickStart = performance.now()
let maxChunkX = (p.x >> 4) + settings.renderDistance
let maxChunkZ = (p.z >> 4) + settings.renderDistance
let chunk = maxChunkX + "," + maxChunkZ
if (chunk !== this.lastChunk) {
this.lastChunk = chunk
this.loadChunks()
this.chunkGenQueue.sort(sortChunks)
}
if(worldSettings.dayNightCycle) worldTime += 0.0005
if (controlMap.break.pressed && !Key.control && p.lastBreak < Date.now() - 250 && screen === "play" && !survival && !entHitbox.ent) { // survival breaking isn't instant
changeWorldBlock(0)
}
if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250 && !p.autoBuild) {
newWorldBlock()
}
if (controlMap.break.pressed && p.autoBreak && !Key.control) {
changeWorldBlock(0)
}
if ((controlMap.place.pressed || Key.leftMouse && Key.control) && p.autoBuild) {
newWorldBlock()
}
for (let i = 0; i < this.sortedChunks.length; i++) {
this.sortedChunks[i].tick()
}
for (let i = this.entities.length - 1; i >= 0; i--) {
const entity = this.entities[i]
entity.update()
if (entity.canDespawn || (entity.y <= -64)) {
this.deleteEntity(0, false, i)
}
}
for (let i = this.particles.length - 1; i >= 0; i--) {
const particle = this.particles[i]
particle.update()
if (particle.canDespawn || (particle.y <= -64)) {
this.particles.splice(i,1)
}
}
updtPlayer()
if(multiplayer){
for(let i in players){
players[i].update()
}
}
do {
let doneWork = false
debug.start = performance.now()
if (this.meshQueue.length) {
// Update all chunk meshes.
let len = this.meshQueue.length - 1
do {
this.meshQueue.pop().genMesh()
} while(this.meshQueue.length)
doneWork = true
debug("Meshes")
}
if (this.generateQueue.length && !doneWork) {
let chunk = this.generateQueue.pop()
this.genChunk(chunk)
doneWork = true
}
if (this.populateQueue.length && !doneWork) {
let chunk = this.populateQueue[this.populateQueue.length - 1]
if (!chunk.caves) {
chunk.carveCaves()
debug("Carve caves")
} else if (!chunk.populated) {
chunk.populate()
this.populateQueue.pop()
}
doneWork = true
}
if (this.loadQueue.length && !doneWork) {
this.loadQueue.pop().load()
doneWork = true
if (!this.loadQueue.length) {
return
}
}
if (this.lightingQueue.length && !doneWork) {
this.lightingQueue.pop().fillLight()
doneWork = true
}
if (this.chunkGenQueue.length && !doneWork) {
let chunk = this.chunkGenQueue[0]
if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
else if (!chunk.optimized) {
chunk.optimize(this)
debug("Optimize")
} else if (!chunk.buffer) {
chunk.genMesh()
debug("Initial mesh")
} else {
this.chunkGenQueue.shift()
generatedChunks++
}
doneWork = true
}
if (!doneWork) {
break
}
} while(performance.now() - tickStart < 5)
}
render() {
gl.useProgram(program3D);
initModelView(p)
if(this.type === "nether"){
skyLight = 0
if(inWater === 1) gl.clearColor(0,0,255,1)
else if(inWater === 2) gl.clearColor(255,0,0,1)
else gl.clearColor(0, 0, 0, 1)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
}else{
skyLight = min(max(abs(worldTime % (Math.PId*1.2) - Math.PI) / Math.PI - 0.04, 0.1), 1)
/*var redTintAmount = min(abs(skyLight - 0.5), 1)
sky[0] = lerp(redTintAmount, defaultSky[0], 255)
sky[1] = lerp(redTintAmount, defaultSky[1], 0)
sky[2] = lerp(redTintAmount, defaultSky[2], 0)*/
if(inWater === 1) gl.clearColor(0,0,255,1)
else if(inWater === 2) gl.clearColor(255,0,0,1)
else gl.clearColor(sky[0] * skyLight, sky[1] * skyLight, sky[2] * skyLight, 1)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
//skybox render
if(inWater === 0){
/*gl.useProgram(skyboxProgram);
gl.uniform1f(glCache.skyboxTime, worldTime);
gl.depthFunc(gl.ALWAYS);
gl.disable(gl.CULL_FACE);
skybox.render();
gl.depthFunc(gl.LESS);
gl.enable(gl.CULL_FACE)*/
}
}
gl.useProgram(program3D);
renderedChunks = 0
let dist = (settings.renderDistance) * 16
if (this.chunkGenQueue.length) {
this.chunkGenQueue.sort(sortChunks)
let chunk = this.chunkGenQueue[0]
dist = min(dist, chunkDist(chunk))
}
if (dist !== fogDist) {
if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120
else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30
else fogDist = dist
}
gl.uniform1i(glCache.isInWorld, 1)
gl.uniform3f(glCache.uPos, p.x, p.y, p.z)
gl.uniform1f(glCache.uDist, fogDist)
// this is interesting because uTime is not actually based on time
// if you are going to change this to use actual time change line 4487 as well
// since it depends on it
gl.uniform1f(glCache.uTime, skyLight)
if(inWater) gl.uniform3f(glCache.skyColor, 0, 0, 255)
else gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
gl.uniform1i(glCache.inWater, inWater)
let c = this.sortedChunks
for (let chunk of c) {
chunk.render()
}
if (this.doubleRenderChunks.length) {
gl.depthMask(false)
gl.uniform1i(glCache.uTrans, 1)
for (let chunk of this.doubleRenderChunks) {
chunk.render()
}
gl.uniform1i(glCache.uTrans, 0)
gl.depthMask(true)
}
gl.uniform3f(glCache.uPos, 0, 0, 0)
gl.uniform1i(glCache.inWater, 0)
gl.useProgram(programEntity)
for (let i = this.entities.length - 1; i >= 0; i--) {
const entity = this.entities[i]
entity.render()
}
if(multiplayer){
for(let i in players){
let player = players[i]
if(player.dimension === world.type){
player.render()
if(player.crack > -1 && player.survival){
let pos = player.crackPos
crack.entity.x = pos[0]
crack.entity.y = pos[1]
crack.entity.z = pos[2]
crack.entity.changeTexture(crack[player.crack])
crack.entity.render()
}
}
}
}
renderPlayer()
if(crack.idx > -1 && survival){
crack.entity.x = crack.pos[0]
crack.entity.y = crack.pos[1]
crack.entity.z = crack.pos[2]
crack.entity.changeTexture(crack.tex)
crack.entity.render()
}
gl.useProgram(programParticle)
for (let i = this.particles.length - 1; i >= 0; i--) {
const particle = this.particles[i]
particle.render()
}
gl.useProgram(program3D)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.uniform1i(glCache.uSampler, 0)
if(hitBox.pos) {
blockOutlines = true
blockFill = false
block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p)
blockOutlines = false
blockFill = true
}
gl.uniform1i(glCache.isInWorld, 0)
//clear alpha so transparent things aren't white
gl.clearColor(1, 1, 1, 1);
gl.colorMask(false, false, false, true);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.colorMask(true, true, true, true);
}
loadChunks() {
let renderDistance = settings.renderDistance + 3
let cx = p.x >> 4
let cz = p.z >> 4
p.cx = cx
p.cz = cz
let minChunkX = cx - renderDistance
let maxChunkX = cx + renderDistance
let minChunkZ = cz - renderDistance
let maxChunkZ = cz + renderDistance
this.offsetX = -minChunkX
this.offsetZ = -minChunkZ
this.lwidth = renderDistance * 2 + 1
this.chunkGenQueue.length = 0
this.lightingQueue.length = 0
this.populateQueue.length = 0
this.generateQueue.length = 0
if (this.loaded.length > this.lwidth * this.lwidth) {
this.loaded.length = this.lwidth * this.lwidth
}
let i = 0
for (let x = minChunkX; x <= maxChunkX; x++) {
for (let z = minChunkZ; z <= maxChunkZ; z++) {
let chunk
if (!this.chunks[x]) {
this.chunks[x] = []
}
if (!this.chunks[x][z]) {
chunk = new Chunk(x * 16, z * 16,this.type,this)
if (maxDist(cx, cz, x, z) <= settings.renderDistance) {
this.chunkGenQueue.push(chunk)
}
this.chunks[x][z] = chunk
}
chunk = this.chunks[x][z]
if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= settings.renderDistance) {
this.chunkGenQueue.push(chunk)
}
this.loaded[i++] = chunk
}
}
this.sortedChunks.length = 0
this.doubleRenderChunks.length = 0
for (let chunk of this.loaded) {
if (renderFilter(chunk)) {
this.sortedChunks.push(chunk)
}
if (chunk.doubleRender) {
this.doubleRenderChunks.push(chunk)
}
}
this.sortedChunks = this.loaded.filter(renderFilter)
this.sortedChunks.sort(sortChunks)
}
getTop(x,z){
let X = (x >> 4) + this.offsetX
let Z = (z >> 4) + this.offsetZ
if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
return this.chunks[x >> 4][z >> 4].tops[(z&15) * 16 + (x&15)]
}
}
getThisSaveString(){
let world = this
let edited = []
for (let x in this.chunks) {
for (let z in this.chunks[x]) {
let chunk = this.chunks[x][z]
if (chunk.edited) {
for (let y = 0; y < chunk.sections.length; y++) {
if (chunk.sections[y].edited) {
edited.push([ chunk.sections[y], chunk.cleanSections[y] ])
}
}
}
}
}
let pallete = {}
for (let chunks of edited) {
let changes = false
chunks[0].blocks.forEach((id, i) => {
if (id !== chunks[1][i]) {
pallete[id] = true
changes = true
}
})
if (!changes) {
chunks[0].edited = false
}
}
let blocks = Object.keys(pallete).map(n => Number(n))
pallete = {}
blocks.forEach((block, index) => pallete[block] = index)
let rnd = round
let options = p.flying | (superflat==="island" ? 2 : superflat) << 1 | p.spectator << 3 | caves << 4 | trees << 5 | survival << 6
let str = world.name + ";" + worldSeed.toString(36) + ";"
+ rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
+ (this.version || version) + ";"
+ blocks.map(b => b.toString(36)).join(",") + ";"
for (let i = 0; i < edited.length; i++) {
if (!edited[i][0].edited) {
continue
}
let real = edited[i][0]
let blocks = real.blocks
let original = edited[i][1]
str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
for (let j = 0; j < original.length; j++) {
if (blocks[j] !== original[j]) {
str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
}
}
str = str.substr(0, str.length - 1); //Remove trailing comma
str += ";"
}
if (str.match(/;$/)) str = str.substr(0, str.length - 1)
return str
}
getSaveString() {
let world = this
if(this.type !== "") world = dimensions.overworld //save overworld
if(!world.edited && world.saveStr) return world.saveStr
return world.getThisSaveString()
}
getNetherSaveString(){
let world = this
if(this.type !== "nether") world = dimensions.nether //save nether
if(!world.edited && world.saveStr) return world.saveStr
return world.getThisSaveString()
}
getInv(){
let str = ""
let arr = []
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i]){
arr.push(inventory.hotbar[i].id)
arr.push(inventory.hotbar[i].amount)
}else{
arr.push(0)
arr.push(0)
}
}
str += arr.join(",") + "|"
arr = []
for(i=0; i<invItems.length; i++){
if(invItems[i]){
arr.push(invItems[i].id)
arr.push(invItems[i].amount)
}else{
arr.push(0)
arr.push(0)
}
}
str += arr.join(",") + "|"
arr = []
for(let i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i]){
arr.push(inventory.hotbar[i].durability || 0)
}else{
arr.push(0)
}
}
str += arr.join(",") + "|"
arr = []
for(i=0; i<invItems.length; i++){
if(invItems[i]){
arr.push(invItems[i].durability || 0)
}else{
arr.push(0)
}
}
return str
}
getSurvivStr(){
//survival stuff like player health
let str = ""
str += p.health + ","
str += witherEffect + ","
str += witherTime + ","
str += witherDamage + ","
str += world.spawnPoint.x + "," + world.spawnPoint.y + "," + world.spawnPoint.z + ","
str += p.food + "," + p.foodSaturation + "," + p.foodExhaustion + ","
str += p.oxygen + ","
str += worldTime + ","
str += (cheats ? "1" : "0")+","
str += freezeEffect+","
str += p.XP+","+p.level
return str
}
getEditedTags(){
var obj = {}
for(var pos of this.editedTags){
var arr = pos.split(",")
obj[pos] = this.getTags(parseInt(arr[0], 36),parseInt(arr[1], 36),parseInt(arr[2],36))
}
return obj
}
loadSave(str) {
this.saveStr = str
let data = str.split(";")
if (!str.includes("Alpha")) {
return this.loadOldSave(str)
}
this.name = data.shift()
setSeed(parseInt(data.shift(), 36))
let playerData = data.shift().split(",")
if(this.type === ""){
p.x = parseInt(playerData[0], 36)
p.y = parseInt(playerData[1], 36)
p.z = parseInt(playerData[2], 36)
p.rx = parseInt(playerData[3], 36) / 100
p.ry = parseInt(playerData[4], 36) / 100
}
let options = parseInt(playerData[5], 36)
let v = data[0].replace("Alpha ","")
if(this.type === ""){
let extra = verMoreThan(v, "1.0.3") || v === "1.0.3"
p.flying = options & 1
p.spectator = options >> (2+extra) & 1
superflat = options >> 1 & 3
if(superflat === 0){superflat = false}
if(superflat === 1){superflat = true}
if(superflat === 2){superflat = "island"}
caves = options >> (3+extra) & 1
trees = options >> (4+extra) & 1
survival = (options >> (5+extra) & 1) ? true : false
}
let version = data.shift()
this.version = version
// if (version.split(" ")[1].split(".").join("") < 70) {
// 	alert("This save code is for an older version. 0.7.0 or later is needed")
// }
let pallete = data.shift().split(",").map(n => parseInt(n, 36))
this.loadFrom = []
for (let i = 0; data.length; i++) {
let blocks = data.shift().split(",")
this.loadFrom.push({
x: parseInt(blocks.shift(), 36),
y: parseInt(blocks.shift(), 36),
z: parseInt(blocks.shift(), 36),
blocks: [],
})
for (let j = 0; j < blocks.length; j++) {
let block = parseInt(blocks[j], 36)
let index = block & 0xffffff
let pid = block >> 12
this.loadFrom[i].blocks[index] = pallete[pid]
}
}
}
loadInv(str){
let arr = str.split("|")
let inv = arr[1].split(",")
let hotb = arr[0].split(",")
let len = inventory.hotbar.length
inventory.hotbar = []
for(let i=0; i<len*2; i+=2){
if(hotb[i]){
inventory.hotbar.push({
id: parseInt(hotb[i]),
amount: parseInt(hotb[i+1])
})
}else inventory.hotbar.push(0)
}
invItems = []
for(let i=0; i<inv.length; i+=2){
invItems.push({
id: parseInt(inv[i]),
amount: parseInt(inv[i+1])
})
}
try{
inv = arr[3].split(",")
hotb = arr[2].split(",")
for(let i=0; i<len*2; i++){
hotb[i] = parseInt(hotb[i]) || 0
if(hotb[i]){
inventory.hotbar[i].durability = hotb[i]
}
}
for(let i=0; i<inv.length; i++){
inv[i] = parseInt(inv[i]) || 0
if(inv[i]){
invItems[i].durability = inv[i]
}
}
}catch{}
}
loadSurvivStr(str){
let arr = str.split(",")
p.health = parseInt(arr[0])
witherEffect = parseInt(arr[1])
witherTime = parseInt(arr[2])
witherDamage = parseInt(arr[3])
world.spawnPoint.x = parseInt(arr[4]) || 0
world.spawnPoint.y = parseInt(arr[5]) || 0
world.spawnPoint.z = parseInt(arr[6]) || 0
p.food = parseInt(arr[7]); if(isNaN(p.food)) p.food = 20
p.foodSaturation = parseFloat(arr[8]) || 0, p.foodExhaustion = parseFloat(arr[9]) || 0
p.oxygen = parseInt(arr[10]); if(!p.oxygen) p.oxygen = 20
worldTime = parseFloat(arr[11]) || 0
cheats = arr[12] ? arr[12] === "1" : !survival
freezeEffect = parseInt(arr[13])
p.XP = parseFloat(arr[14]) || 0
p.level = parseInt(arr[15]) || 0; setLevel()
}
loadEditedTags(obj){
for(var t in obj){
var data = obj[t]
var pos = t.split(",")
world.setTags(parseInt(pos[0],36),parseInt(pos[1],36),parseInt(pos[2],36),data)
}
}
loadOldSave(str) {
let data = str.split(";");
setSeed(parseInt(data.shift(), 36))
this.id = Date.now()
this.name = "Old World " + (Math.random() * 1000 | 0)
let playerData = data.shift().split(",");
p.x = parseInt(playerData[0], 36);
p.y = parseInt(playerData[1], 36);
p.z = parseInt(playerData[2], 36);
p.rx = parseInt(playerData[3], 36) / 100;
p.ry = parseInt(playerData[4], 36) / 100;
let editCount = parseInt(data.shift(), 36);
this.loadFrom = [];
let coords = data.shift().split(",").map(function(n) {
return parseInt(n, 36);
});
for (let j = 0; j < coords.length; j += 3) {
this.loadFrom.push({
x: coords[j],
y: coords[j + 1],
z: coords[j + 2],
blocks: [],
})
}
for (let i = 0; data.length > 0; i++) {
let blocks = data.shift().split(",");
for (let j = 0; j < blocks.length; j++) {
let block = parseInt(blocks[j], 36);
let index = block >> 8;
let id = block & 0x7f | (block & 0x80) << 1;
this.loadFrom[i].blocks[index] = id;
}
}
}
}
win.World = World
// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
let mouseS = 300
class Slider {
constructor(x, y, w, h, scenes, label, min, max, settingName, callback, percentage, mouseup, replaceValue) {
this.x = x
this.y = y
this.h = h
this.w = Math.max(w, 350)
this.name = settingName
this.scenes = Array.isArray(scenes) ? scenes : [scenes]
this.label = label
this.min = min
this.max = max
this.sliding = false
this.callback = callback
this.percentage = percentage || false //show integer or float
this.mouseup = mouseup
this.replaceValue = replaceValue
}
draw() {
if (!this.scenes.includes(screen)) {
return
}
let current = (settings[this.name] - this.min) / (this.max - this.min)
// Outline
ctx.beginPath()
strokeWeight(2)
stroke(0)
fill(85)
ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
ctx.stroke()
ctx.fill()
// Slider bar
var exponent; if(this.percentage) exponent = 10**4 //max digits after decimal point: 4
let value = this.percentage ? (round(settings[this.name]*100*exponent)/exponent)+"%" : round(settings[this.name])
if(this.replaceValue && this.replaceValue[value]){
value = this.replaceValue[value]
}
ctx.beginPath()
fill(130)
let x = this.x - (this.w - 10) / 2 + (this.w - 10) * current - 5
ctx.fillRect(x, this.y - this.h / 2, 10, this.h)
//Label
fill(255, 255, 255)
textSize(13)
ctx.textAlign = 'center'
text(`${this.label}: ${value}`, this.x, this.y + this.h / 8)
}
mouseCollided(){
return mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2
}
click() {
if (!mouseDown || !this.scenes.includes(screen)) {
return false
}
if (this.mouseCollided()) {
let current = (mouseX - this.x + this.w / 2) / this.w
if (current < 0) current = 0
if (current > 1) current = 1
this.sliding = true
settings[this.name] = current * (this.max - this.min) + this.min
this.callback(current * (this.max - this.min) + this.min)
this.draw()
}
}
drag() {
if (!this.sliding || !this.scenes.includes(screen)) {
return false
}
let current = (mouseX - this.x + this.w / 2) / this.w
if (current < 0) current = 0
if (current > 1) current = 1
settings[this.name] = current * (this.max - this.min) + this.min
this.callback(current * (this.max - this.min) + this.min)
}
release() {
if(this.sliding && this.mouseup) this.mouseup()
this.sliding = false
}
static draw() {
for (let slider of Slider.all) {
slider.draw()
}
}
static click() {
for (let slider of Slider.all) {
slider.click()
}
}
static release() {
for (let slider of Slider.all) {
slider.release()
}
}
static drag() {
if (mouseDown) {
for (let slider of Slider.all) {
slider.drag()
}
}
}
static add(x, y, w, h, scenes, label, min, max, defaut, callback, percentage, mouseup, replaceValue) {
Slider.all.push(new Slider(x, y, w, h, scenes, label, min, max, defaut, callback, percentage, mouseup, replaceValue))
}
}
Slider.all = []
class Button {
constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText, setIndex) {
this.x = x
this.y = y
this.h = h
this.w = w
this.index = 0
this.disabled = disabled || (() => false)
this.hoverText = !hoverText || typeof hoverText === "string" ? (() => hoverText) : hoverText
this.scenes = Array.isArray(scenes) ? scenes : [scenes]
this.labels = Array.isArray(labels) ? labels : [labels]
this.callback = callback
this.setIndex = setIndex
}
mouseIsOver() {
return mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2
}
draw() {
if (!this.scenes.includes(screen)) {
return
}
let hovering = this.mouseIsOver()
let disabled = this.disabled()
let hoverText = this.hoverText()
if(this.setIndex){
this.index = this.setIndex()
}
// Outline
ctx.beginPath()
strokeWeight(6)
stroke(80)
if (disabled) {
fill(60)
stroke(20)
} else {
if (hovering) {
cursor(HAND)
fill(100, 120, 200)
stroke(100,80,160)
}else{
fill(120)
}
}
ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
ctx.stroke()
ctx.fill()
ctx.beginPath()
stroke(200)
if (hovering && !disabled)stroke(200, 200, 255);
if(disabled)stroke(130);
strokeWeight(3.5)
if(disabled){
ctx.moveTo(this.x + (this.w / 2) + 2, this.y - this.h / 2-2)
ctx.lineTo(this.x + (this.w / 2) + 2, this.y + (this.h / 2)+1)
ctx.lineTo(this.x - this.w / 2 - 1, this.y + (this.h / 2)+1)
}else{
ctx.moveTo(this.x - this.w / 2 - 2, this.y + (this.h / 2)-2)
ctx.lineTo(this.x - this.w / 2 - 2, this.y - this.h / 2-2)
ctx.lineTo(this.x + (this.w / 2)+1, this.y - this.h / 2-2)
}
ctx.stroke()
stroke(0)
strokeWeight(1)
ctx.strokeRect(this.x-this.w/2-4, this.y-this.h/2-4, this.w+8, this.h+8)
//Label
textSize(13)
ctx.textAlign = 'center'
fill(0)
text(this.labels[this.index], this.x +2, this.y + this.h / 8 +2)
disabled ? fill(255) : (hovering ? fill(255,255,0) : fill(255) )
text(this.labels[this.index], this.x, this.y + this.h / 8)
if (hovering && hoverText) {
hoverbox.innerText = hoverText
hoverbox.classList.remove("hidden")
if (mouseY < height / 2) {
hoverbox.style.bottom = ""
hoverbox.style.top = mouseY + 10 + "px"
} else {
hoverbox.style.top = ""
hoverbox.style.bottom = height - mouseY + 10 + "px"
}
if (mouseX < width / 2) {
hoverbox.style.right = ""
hoverbox.style.left = mouseX + 10 + "px"
} else {
hoverbox.style.left = ""
hoverbox.style.right = width - mouseX + 10 + "px"
}
}
}
click() {
if (this.disabled() || !mouseDown || !this.scenes.includes(screen)) {
return false
}
if (this.mouseIsOver()) {
this.index = (this.index + 1) % this.labels.length
this.callback(this.labels[this.index])
return true
}
}
static draw() {
hoverbox.classList.add("hidden")
for (let button of Button.all) {
button.draw()
}
}
static click() {
for (let button of Button.all) {
if (button.click()) {
Button.draw()
playSound("click")
break
}
}
}
static add(x, y, w, h, labels, scenes, callback, disabled, hoverText, setIndex) {
Button.all.push(new Button(x, y, w, h, labels, scenes, callback, disabled, hoverText, setIndex))
}
}
Button.all = []
var initEverything
function initButtons() {
Button.all = []
Slider.all = []
const nothing = () => false
const always = () => true
// Main menu buttons
Button.add(width / 2, height / 2 - 40, 400, 40, "Singleplayer", "main menu", r => changeScene("loadsave menu"))
Button.add(width / 2, height / 2 + 15, 400, 40, "Multiplayer", "main menu", r => {
changeScene("multiplayer menu")
}, null, "A better alternative to willard.fun/minekhan!")
Button.add(width / 2, height / 2 + 70, 400, 40, "Marketplace", "main menu", r => changeScene("marketplace"))
Button.add(width / 2 - 105, height / 2 + 160, 190, 40, "Options", "main menu", r => changeScene("options"))
Button.add(width / 2 + 105, height / 2 + 160, 190, 40, "Quit", "main menu", r => {
if(window.opener !== null || window.history.length === 1){
close()
}else{
location.href = "https://www.thingmaker.repl.co"
}
})
Button.add(width / 2 - 235, height / 2 + 160, 40, 40, "?", "main menu", r => changeScene("help"))
// Creation menu buttons
Button.add(width / 2-160, 135, 300, 40, ["Game Mode: Creative", "Game Mode: Survival"], "creation menu", r => survival = r === "Game Mode: Survival")
Button.add(width / 2+160, 135, 300, 40, "Difficulty: Peaceful", "creation menu", nothing, always, "Coming soon\n\nPlease stop asking for mobs. Adding them will take a very long time. I know a lot of people want them, so just be patient.")
Button.add(width / 2-160, 245, 300, 40, "Cheats:", "creation menu", nothing, always, "If you have creative mode on, cheats are on. Otherwise, cheats are off.")
Button.add(width / 2+160, 245, 300, 40, ["World Type: Normal", "World Type: Superflat", "World Type: Island"], "creation menu", r => {superflat = r === "World Type: Superflat"; if(r==="World Type: Island")superflat="island"})
Button.add(width / 2-160, 295, 300, 40, "Game Rules", "creation menu", nothing, always, "Game rules are configurable ingame via Options.")
Button.add(width / 2+160, 295, 300, 40, "World Generation Options", "creation menu", nothing, always, "These don't exist yet.")
Button.add(width / 2-160, 405, 300, 40, "Create New World", "creation menu", r => {
if(boxCenterTop.value.startsWith("JSON")){
alert("That name is not allowed")
return
}
createNewWorld()
})
Button.add(width / 2+160, 405, 300, 40, "Cancel", "creation menu", r => changeScene(previousScreen))
// Loadsave menu buttons
const selected = () => !selectedWorld || !worlds[selectedWorld]
let w4 = min(width / 4 - 10, 220)
let x4 = w4 / 2 + 5
let w2 = min(width / 2 - 10, 450)
let x2 = w2 / 2 + 5
let mid = width / 2
Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", r => changeScene("editworld"), () => (selected() || !worlds[selectedWorld].edited))
Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", r => {
if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}?`)) {
deleteFromDB(selectedWorld)
window.worlds.removeChild(document.getElementById(selectedWorld))
delete worlds[selectedWorld]
selectedWorld = 0
}
}, () => (selected() || !worlds[selectedWorld].edited), "Delete the world forever.")
Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", r => {
boxCenterTop.value = worlds[selectedWorld].code
}, selected, "Export the save code into the text box above for copy/paste.")
Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "loadsave menu", r => changeScene("main menu"))
Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "loadsave menu", r => {
var ver
if(worlds[selectedWorld]){
ver = worlds[selectedWorld].version.replace("Alpha ","")
}else{
ver = boxCenterTop.value.split(";")[3].replace("Aplha ","")
}
if(!verMoreThan(ver, "1.0.2")){
changeScene("broken world")
return
}
playSelectedWorld()
}, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", r => changeScene("creation menu"))
//broken world buttons
Button.add(mid, height / 2 + 50, w2, 40, "Cancel", "broken world", r => {changeScene("loadsave menu")})
Button.add(mid, height / 2 + 105, w2, 40, "Load anyways", "broken world", r => {
try{
playSelectedWorld()
}catch(e){
alert(e)
}
})
// Edit world menu
Button.add(mid, height / 2, w2, 40, "Save", "editworld", r => {
let w = worlds[selectedWorld]
w.name = boxCenterTop.value.replace(/;/g, "\u037e")
let split = w.code.split(";")
split[0] = w.name
w.code = split.join(";")
w.thumbnail = window.url.value
saveToDB(w.id, w).then(success => {
initWorldsMenu()
changeScene("loadsave menu")
}).catch(e => console.error(e))
})
Button.add(mid, height / 2 + 50, w2, 40, "Back", "editworld", r => changeScene(previousScreen))
// Multiplayer buttons
Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "multiplayer menu", r => changeScene("main menu"))
Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "multiplayer menu", async() => {
changeScene("multiplayer connecting")
initMultiplayer(servers[selectedWorld].id)
}, () => !servers[selectedWorld])
//multiplayer connecting buttons
Button.add(mid, height / 2 + 40, w2, 40, "Cancel", "multiplayer connecting", r => {multiplayer.close();changeScene("multiplayer lost")})
//multiplayer lost buttons
Button.add(mid, height / 2 + 40, w2, 40, "Back", "multiplayer lost", r => changeScene("multiplayer menu"))
//play buttons
if(touchScreen){
Button.add(mid-14, 14, 20,20, "/", "play", Messages.showInput)
Button.add(mid+14, 14, 20,20, "??", "play", r => changeScene("pause"))
}
// Pause buttons
Button.add(width / 2, 175, 300, 40, "Resume", "pause", play)
Button.add(width / 2, 225, 300, 40, "Options", "pause", r => changeScene("options"))
Button.add(width / 2, 275, 300, 40, "Save", "pause", () => save(), nothing, () => `Save the world to your computer/browser. Doesn't work in incognito.\n\nLast saved ${timeString(Date.now() - world.edited)}.`)
Button.add(width / 2, 325, 300, 40, "Get Save Code", "pause", r => {
savebox.classList.remove("hidden")
saveDirections.classList.remove("hidden")
savebox.value = world.getSaveString()
})
Button.add(width / 2, 375, 300, 40, "Exit Without Saving", "pause", r => {
savebox.value = world.getSaveString()
initWorldsMenu()
if(multiplayer) multiplayer.close()
changeScene("main menu")
})
Button.add(width / 2, 425, 300, 40, "Enable Multiplayer", "pause", async r => {
var logged
await loggedIn().then(r => logged = r)
if(logged){
initMultiplayer()
}
}, () => multiplayer)
Button.add(width / 2, 475, 300, 40, "Get Invite Link", "pause", r => {
savebox.classList.remove("hidden")
savebox.value = "https://minekhan.thingmaker.repl.co/?target="+world.id
}, () => !multiplayer, () => "Invite someone to this world if it is multiplayer.")
Button.add(width / 2, 525, 300, 40, "Download This World", "pause", r => {
var a = document.createElement("a")
a.href = "data:text/plain,"+getSaveJSON()
a.download = world.name+".minekhan"
a.click()
}, nothing)
// You Died buttons
Button.add(width / 2, 225, 300, 40, "Respawn", "dead", r => {
respawn()
updateHUD = true
play()
})
//Help buttons
Button.add(60, 30, 80, 30, "Back", "help", r => changeScene(previousScreen))
// Marketplace buttons
Button.add(60, 40, 80, 30, "Back", "marketplace", r => changeScene("main menu"))
Button.add(mid - x2, height - 75, w2, 40, "Download", "marketplace", saveFromMarketplace, () => !marketplace[selectedWorld])
// Comingsoon menu buttons
Button.add(width / 2, 395, width / 3, 40, "Back", "comingsoon menu", r => changeScene(previousScreen))
// Options Sliders & Buttons
Slider.add(width/4, height/2 + -245, width / 3, 40, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val))
Slider.add(width/4, height/2 + -185, width / 3, 40, "options", "FOV", 30, 110, "fov", val => {
p.FOV(val)
if (world) {
p.setDirection()
world.render()
}
})
Slider.add(width/4, height/2 + -125, width / 3, 40, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val)
Button.add(width / 4, height/2 + -65, width / 3, 40, ["Reach distance: "+normReach, "Reach distance: "+bigReach], "options", r => {
if(r === "Reach distance: "+normReach){
reach = normReach
}else reach = bigReach
})
//Button.add(width / 2, 500, width / 3, 40, ["Sound: On", "Sound: Off"], "options", r => soundOn = r === "Sound: On")
Slider.add(width / 4, height/2 + -5, width / 3, 40, "options", "Sound Volume", 0,1, "volume", val => settings.volume = val, true, val => {blockSound(blockIds.grass, "place")}, {"0%":"Off"})
Button.add(width / 4, height/2 + 55, width / 3, 40, "Change Controls", "options", r => changeScene("options controls"))
Button.add(width / 4, height/2 + 115, width / 3, 40, "Change skin", "options", r => {
if(userInfo){
window.open("https://www.thingmaker.repl.co/website/account.html#skin", "_blank")
}else{
window.open("https://www.thingmaker.repl.co/website/login.html?redirect=account.html%23skin", "_blank")
}
})
Button.add(width * 0.75, height/2 + -245, width / 3, 40, "World Options", "options", r => changeScene("options worldSettings"), () => beforeOptionsScreen !== "pause")
Button.add(width * 0.75, height/2 + -185, width / 3, 40, "Narrator Options", "options", r => changeScene("options narrator"))
Button.add(width / 2, height - 50, width / 3, 40, "Back", "options", r => changeScene(beforeOptionsScreen))
// World settings buttons
var needsCheats = () => !cheats
var noCheatsThenSayIt = () => !cheats && "This requires cheats."
Button.add(width / 2, height/2 + -245, width / 4, 40, ["TNT Explodes: On","TNT Explodes: Off"], "options worldSettings", r => worldSettings.tntExplode = r === "TNT Explodes: On", null, null, () => worldSettings.tntExplode ? 0 : 1)
Button.add(width / 2, height/2 + -5, width / 4, 40, ["PVP: On","PVP: Off"], "options worldSettings", r => worldSettings.pvp = r === "PVP: On", null, null, () => worldSettings.pvp ? 0 : 1)
Button.add(width / 2, height/2 + -185, width / 4, 40, ["Kill command enabled","Kill command disabled"], "options worldSettings", r => worldSettings.killCmdOff = r === "Kill command disabled", null, null, () => worldSettings.killCmdOff ? 1 : 0)
Button.add(width / 2, height/2 + -125, width / 4, 40, ["Day/Night Cycle: On", "Day/Night Cycle: Off"], "options worldSettings", r => worldSettings.dayNightCycle = r === "Day/Night Cycle: On", needsCheats, noCheatsThenSayIt, () => worldSettings.dayNightCycle ? 0 : 1)
Button.add(width / 2, height/2 + -65, width / 4, 40, ["Blocks Fall: On", "Blocks Fall: Off"], "options worldSettings", r => worldSettings.blocksFall = r === "Blocks Fall: On", needsCheats, noCheatsThenSayIt, () => worldSettings.blocksFall ? 0 : 1)
Button.add(width / 2, height - 50, width / 3, 40, "Back", "options worldSettings", r => changeScene(previousScreen))
// Control menu buttons
Button.add(mid - x2, height - 30, w2, 40, "Done", "options controls", r => {
changeScene(previousScreen)
})
Button.add(mid + x2, height - 30, w2, 40, "Reset Controls", "options controls", r => resetControls(), () => controlsAreDefault)
//Narrator options buttons
Button.add(width / 2, height/2 + -245, width / 3, 40, ["Chat Narrator: Off", "Chat Narrator: On"], "options narrator", r => {
settings.narrator = r === "Chat Narrator: On"
speakIt()
}, null, null, () => settings.narrator ? 1 : 0)
Slider.add(width / 2, height/2 + -185, width / 3, 40, "options narrator", "Narrator Rate", 0.1,10, "narratorRate", val => settings.narratorRate = val, true, val => speakIt())
Slider.add(width / 2, height/2 + -125, width / 3, 40, "options narrator", "Narrator Pitch", 0,10, "narratorPitch", val => settings.narratorPitch = val, true, val => speakIt())
Button.add(width / 2, height - 50, width / 3, 40, "Back", "options narrator", r => changeScene(previousScreen))
}
let texturePixels
let textureImageData //for drawing on canvas
let textureImageCanvas
let textureImageCtx
let textureSize = 256
let textureH = 2048
function initTextures() {
let scale = 1 / (textureSize/16)
let scaleH = 1 / (textureSize/16)
texturePixels = new Uint8Array(textureSize * textureH * 4)
textureImageData = ctx.createImageData(textureSize, textureH)
win.textureImageData = textureImageData
textureImageCanvas = document.createElement("canvas")
textureImageCanvas.width = textureSize
textureImageCanvas.height = textureH
win.textureImageCanvas = textureImageCanvas
textureImageCtx = textureImageCanvas.getContext("2d")
textureMap = {}
textureCoords = []
setPixel = function(textureNum, x, y, r, g, b, a) {
let texX = textureNum & 15
let texY = textureNum >> 4
let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
texturePixels[offset] = r
texturePixels[offset + 1] = g
texturePixels[offset + 2] = b
texturePixels[offset + 3] = a !== undefined ? a : 255
}
/*getPixels = function(str) {
// var w = parseInt(str.substr(0, 2), 36)
// var h = parseInt(str.substr(2, 2), 36)
var colors = []
var pixels = []
var dCount = 0
for (;str[4 + dCount] === "0"; dCount++) {}
var ccount = parseInt(str.substr(4+dCount, dCount+1), 36)
for (var i = 0; i < ccount; i++) {
var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36)
colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ])
}
for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
let num = parseInt(str[i], 36)
pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3])
}
return pixels
};*/
const base256CharSet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEF!#$%&L(MNO)*+,-./:;<=WSTR>Q?@[]P^_{|}~ÀÁÂÃUVÄÅÆÇÈÉÊËÌÍKÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãGäåæçèéêHëìíîXïðñIòóôõö÷øùúJûüýþÿAaAaAaCcCcCcCcDdÐdEeEeEeEeEeGgGgGgGgHhHYhIiIiIiIiIi??JjKk?LlLlLl??LlNnNnNn???OoOoOoŒœRrRrRrSsSsSsŠšTtTtZ'
const base256DecodeMap = new Map()
for (let i = 0; i < 256; i++) base256DecodeMap.set(base256CharSet[i], i)
function decodeByte(str) {
let num = 0
for (let char of str) {
num <<= 8
num += base256DecodeMap.get(char)
}
return num
}
getPixels = function(str, r = 255, g = 255, b = 255) {
const width = decodeByte(str.substr(0, 2))
const height = decodeByte(str.substr(2, 2))
const colorCount = decodeByte(str.substr(4, 1))
const colors = []
const pixels = new Uint8ClampedArray(width * height * 4)
let pixi = 0
for (let i = 0; i < colorCount; i++) {
const num = decodeByte(str.substr(5 + i * 3, 3))
let alpha = (num & 63) << 2
let blue  = (num >>> 6 & 63) << 2
let green = (num >>> 12 & 63) << 2
let red   = (num >>> 18 & 63) << 2
if (alpha >= 240) alpha = 255 // Make sure we didn't accidentally make the texture transparent
if (red === blue && red === green) {
red = red / 252 * r | 0
green = green / 252 * g | 0
blue = blue / 252 * b | 0
}
colors.push([ red, green, blue, alpha ])
}
// Special case for a texture filled with 1 pixel color
if (colorCount === 1) {
while (pixi < pixels.length) {
pixels[pixi + 0] = colors[0][0]
pixels[pixi + 1] = colors[0][1]
pixels[pixi + 2] = colors[0][2]
pixels[pixi + 3] = colors[0][3]
pixi += 4
}
return pixels
}
let bytes = []
for (let i = 5 + colorCount * 3; i < str.length; i++) { // Load the bit-packed index array
const byte = decodeByte(str[i])
bytes.push(byte)
}
const bits = Math.ceil(Math.log2(colorCount))
const bitMask = (1 << bits) - 1
let filledBits = 8
let byte = bytes.shift()
while (bytes.length || filledBits) {
let num = 0
if (filledBits >= bits) { // The entire number is inside the byte
num = byte >> (filledBits - bits) & bitMask
if (filledBits === bits && bytes.length) {
byte = bytes.shift()
filledBits = 8
}
else filledBits -= bits
}
else {
num = byte << (bits - filledBits) & bitMask // Only part of the number is in the byte
byte = bytes.shift() // Load in the next byte
num |= byte >> (8 - bits + filledBits) // Apply the rest of the number from this byte
filledBits += 8 - bits
}
pixels[pixi + 0] = colors[num][0]
pixels[pixi + 1] = colors[num][1]
pixels[pixi + 2] = colors[num][2]
pixels[pixi + 3] = colors[num][3]
pixi += 4
}
return pixels
}
semiTransTextures.splice(0,semiTransTextures.length)
textureUpdated()
{
//get amount of textures
var t = 0
for(var i in textures) t++
//t = Math.ceil(t / 16) * 16
// Specify the texture coords for each index
const s = scale, sh = scaleH
for (let i = 0; i < t; i++) {
let texX = i & 15
let texY = i >> 4
let offsetX = texX * s
let offsetY = texY * sh
textureCoords.push(new Float32Array([ offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + sh, offsetX, offsetY + sh ]))
}
// Set all of the textures into 1 big tiled texture
let n = 0
for (let i in textures) {
if (typeof textures[i] === "function") {
textures[i](n)
} else if (typeof textures[i] === "string") {
let pix = getPixels(textures[i])
let semiTrans
for (let j = 0; j < pix.length; j += 4) {
setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3])
let a = pix[j+3]
if(a !== 0 && a !== 255){
semiTrans = true
}
}
if(semiTrans)semiTransTextures.push(i)
}
textureMap[i] = n
n++
}
for(var t in animated){
var a = animated[t].arr
var trans
for(var ti = 0; ti<a.length; ti++){
if(semiTransTextures.includes(a[ti])){//if this animated texture has transparent frames
trans = true
}
}
if(trans) semiTransTextures.push(t)
}
//Set the hitbox texture to 1 pixel
let arr = new Float32Array(192)
for (let i = 0; i < 192; i += 2) {
arr[i] = textureCoords[textureMap.hitbox][0] + 0.01
arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01
}
textureCoords[textureMap.hitbox] = arr
}
//Set imageData
textureImageData.data.set(texturePixels)
textureImageCtx.putImageData(textureImageData,0,0)
// Big texture with everything in it
textureAtlas = gl.createTexture()
gl.activeTexture(gl.TEXTURE0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
gl.generateMipmap(gl.TEXTURE_2D)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
gl.uniform1i(glCache.uSampler, 0)
// Dirt texture for the background
let dirtPixels = new Uint8Array(getPixels(textures.dirt))
dirtTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE1)
gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
gl.generateMipmap(gl.TEXTURE_2D)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
// Netherrack texture for the background
let netherPixels = new Uint8Array(getPixels(textures.netherrack))
netherTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE2)
gl.bindTexture(gl.TEXTURE_2D, netherTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, netherPixels)
gl.generateMipmap(gl.TEXTURE_2D)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
let explodePixels = new Uint8Array([255,0,0,1])
explodeTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE3)
gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, explodePixels)
images.explode.addEventListener("load", function(){
gl.activeTexture(gl.TEXTURE3)
gl.bindTexture(gl.TEXTURE_2D, explodeTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.explode)
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
})
let experienceOrbPixels = new Uint8Array([255,0,0,1])
experienceOrbTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE5)
gl.bindTexture(gl.TEXTURE_2D, experienceOrbTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, experienceOrbPixels)
images.experienceOrb.addEventListener("load", function(){
gl.activeTexture(gl.TEXTURE5)
gl.bindTexture(gl.TEXTURE_2D, experienceOrbTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.experienceOrb)
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
})
let panoramaPixels = new Uint8Array([255,0,0,1])
panoramaTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE4)
gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, panoramaPixels)
images.panorama.addEventListener("load", function(){
gl.activeTexture(gl.TEXTURE4)
gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.panorama)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
mainBGW = images.panorama.width
})
let genericPixels = new Uint8Array([255,0,0,1])
genericTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE6)
gl.bindTexture(gl.TEXTURE_2D, genericTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, genericPixels)
images.generic.addEventListener("load", function(){
gl.activeTexture(gl.TEXTURE6)
gl.bindTexture(gl.TEXTURE_2D, genericTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.generic)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
})
let skinPixels = new Uint8Array([255,0,0,1])
skinTexture = gl.createTexture()
gl.activeTexture(gl.TEXTURE7)
gl.bindTexture(gl.TEXTURE_2D, skinTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, skinPixels)
images.skin.addEventListener("load", function(){
gl.activeTexture(gl.TEXTURE7)
gl.bindTexture(gl.TEXTURE_2D, skinTexture)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images.skin)
//gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
})
genIcons()
}
function updateTextures() {
var now = performance.now()
for(var i in animated){
var t = animated[i]
var fi = Math.floor((now / t.time) % t.arr.length)
var fi2 = (fi+1) % t.arr.length
var lerpAmount = (now / t.time) % 1
var frame = t.arr[fi]
var frame2 = t.arr[fi2]
var pos = textureCoords[textureMap[frame]]
var pos2 = textureCoords[textureMap[frame2]]
var idx = textureMap[i]
var r=1,g=1,b=1,a=1
if(t.tint){
r = t.tint[0]/255
g = t.tint[1]/255
b = t.tint[2]/255
a = t.tint[3]/255
if(isNaN(a)) a = 1
}
for(var x=0; x<16; x++){
for(var y=0; y<16; y++){
var texX = pos[0]*16, texY = pos[1]*16
var texX2 = pos2[0]*16, texY2 = pos2[1]*16
var offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
var offset2 = (texY2 * 16 + y) * 1024 + texX2 * 64 + x * 4
var pixr = texturePixels[offset]*r
var pixg = texturePixels[offset+1]*g
var pixb = texturePixels[offset+2]*b
var pixa = texturePixels[offset+3]*a
if(t.interpolate){
pixr = lerp(lerpAmount, pixr, texturePixels[offset2]*r)
pixg = lerp(lerpAmount, pixg, texturePixels[offset2+1]*g)
pixb = lerp(lerpAmount, pixb, texturePixels[offset2+2]*b)
pixa = lerp(lerpAmount, pixa, texturePixels[offset2+3]*a)
}
setPixel(idx, x,y, pixr,pixg,pixb,pixa)
}
}
}
if(portalEffect > 0 || p.burning){
textureImageData.data.set(texturePixels)
textureImageCtx.putImageData(textureImageData,0,0)
}
gl.activeTexture(gl.TEXTURE0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureH, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
}
function drawIcon(x, y, id, obj) {
id = id < isCube ? (id | blockMode) : id
let X =  x / (3 * height) - 0.1666 * width / height
let Y = y / (3 * height) - 0.1666
let scale = 1
if(obj && obj.animation){
scale = obj.animation
}
let semiTrans
if(blockData[id].semiTrans) semiTrans = true
initModelView(null, X, Y, 0, 0, 0, scale)
let buffer = blockIcons[id]
let length = blockIcons.lengths[id]
if(!blockIcons[id]){
buffer = blockIconError
length = blockIconError.length
}
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
gl.disableVertexAttribArray(glCache.aSkylight)
gl.disableVertexAttribArray(glCache.aBlocklight)
gl.vertexAttrib1f(glCache.aSkylight, 1.0)
gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
if(semiTrans){
gl.uniform1i(glCache.uTrans, 1)
gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, 0)
gl.uniform1i(glCache.uTrans, 0)
}
if(!obj) return
let s = inventory.size
let s2 = s/2
let ts = inventory.ts
if(obj.durability){
let percent = obj.durability / blockData[id].durability
if(percent !== 1){
let ww = (s-(ts*2))
let w = ww*percent
let color = percent > 0.6666 ? "#af5" : (percent > 0.3333 ? "#fa0" : "#f55")
let dx = x-s2+ts
let dy = y+s2-(ts*3)
let prevFill = ctx2.fillStyle
ctx2.fillStyle = "#333"
ctx2.fillRect(dx,dy,ww,ts*2)
ctx2.fillStyle = color
ctx2.fillRect(dx,dy,w,ts)
ctx2.fillStyle = prevFill
}
}
}
function hotbar() {
FOV(90)
let s = inventory.size
let s2 = s/2
ctx2.fillStyle = "white"
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
for(let i = 0; i < inventory.hotbar.length; i ++) {
let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
let y = height - inventory.size
if(inventory.hotbar[i] && inventory.hotbar[i].id) {
drawIcon(x, y, inventory.hotbar[i].id, inventory.hotbar[i])
if(survival && inventory.hotbar[i].amount>1) ctx2.fillText(inventory.hotbar[i].amount, x+(s/2), y+(s/2))
}
}
if(touchScreen && screen === "play"){
i++
let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
let y = height - inventory.size
ctx.fillStyle = "#0a0"
ctx.fillRect(x-s2, y-s2, s,s)
ctx.textAlign = "center"
var prev = ctx.textBaseline
ctx.textBaseline = "middle";
ctx.fillStyle = "white"
ctx.fillText("...",x,y)
ctx.textBaseline = prev;
}
}
function hud() {
if (p.spectator) {
return
}
//{ why does hotbar dissapear???
gl.useProgram(program3D)
gl.uniform1i(glCache.uSampler, 0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
//}
hotbar()
let s = inventory.size
let s2 = s / 2
let x = width / 2 + 0.5
let y = height / 2 + 0.5
let maxX = width / 2 - inventory.hotbar.length / 2 * s + 9.5 * s + 25
textSize(10)
// Spyglass image
if(p.usingSpyglass){
var w2 = width / 2
var h2 = height / 2
var t = p.spyglassTimer > 250 ? 250 : p.spyglassTimer
var size = min(width, height)
size = map(t,0,250, size/2,size)
var size2 = size / 2
ctx.fillStyle = "black"
ctx.fillRect(0,0,width,height)
ctx.clearRect(w2 - size2, h2 - size2, size, size)
ctx.drawImage(images.spyglassScope, w2 - size2, h2 - size2, size, size)
}
// Crosshair
if (!p.spectator) {
ctx.lineWidth = 1
ctx.strokeStyle = "white"
ctx.beginPath()
ctx.moveTo(x - 10, y)
ctx.lineTo(x + 10, y)
ctx.moveTo(x, y - 10)
ctx.lineTo(x, y + 10)
ctx.stroke()
}
//fire and portal
if(p.burning && !p.thirdPerson){
ctx.globalAlpha = 0.8
var tex = textureCoords[textureMap.fire]
ctx.drawImage(textureImageCanvas, tex[0]*textureSize,tex[1]*textureSize, 16,16, 0,0,width,height)
ctx.globalAlpha = 1
}
if(portalEffect > 0){
ctx.globalAlpha = portalEffect / 100
var tex = textureCoords[textureMap.portal]
ctx.drawImage(textureImageCanvas, tex[0]*textureSize,tex[1]*textureSize, 16,16, 0,0,width,height)
ctx.globalAlpha = 1
}
//Attack indicator
if(attackCooldown > 0){
var c = attackCooldown * 16
ctx.drawImage(images.attackIndicatorCrosshair, 0,0,16,4, x-16,y+10,32,8)
ctx.drawImage(images.attackIndicatorCrosshair, 16,0,c,4, x-16,y+10,c*2,8)
}
//Hotbar
x = width / 2 - 9 / 2 * s + 0.5 + 25
y = height - s * 1.5 + 0.5
ctx.strokeStyle = "black"
ctx.lineWidth = 2
ctx.beginPath()
ctx.moveTo(x, y)
ctx.lineTo(x + s * 9, y)
ctx.moveTo(x, y + s)
ctx.lineTo(x + s * 9, y + s)
for(let i = 0; i <= 9; i++) {
ctx.moveTo(x + i * s, y)
ctx.lineTo(x + i * s, y + s)
}
ctx.stroke()
ctx.strokeStyle = "white"
ctx.lineWidth = 2
ctx.beginPath()
ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)
if(survival){
var iw = 18
var pw = 2 //pixel width
var pw2 = pw/2
var iw2 = iw/2
var dw = iw2 - pw2
var iy = y-iw-4-12
var ih = iw+2
//Health bar
var outline = (healEffect < 40 && healEffect > 30) || (healEffect < 20 && healEffect > 10)
if((loseHealthEffect < 60 && loseHealthEffect > 50) || (loseHealthEffect < 40 && loseHealthEffect > 30) || (loseHealthEffect < 20 && loseHealthEffect > 10)) outline = true
var heartNum = Math.floor(p.health)
let wither = witherEffect > 0
let i
for(i=0; i<heartNum; i+=2){
var heartX = (i * dw) + x;
var offY = p.health < 5 ? (round(Math.random())*2)-1 : 0
if(heartNum === i+1){
ctx.drawImage(images[wither ? "witherHalfHeart": (freezeEffect === 140 ? "freezeHalfHeart" : "halfHeart")], heartX, iy+offY, iw, iw);
}else{
ctx.drawImage(images[wither ? "witherHeart" : (freezeEffect === 140 ? "freezeHeart" : "heart")], heartX, iy+offY, iw, iw);
}
if(outline){
ctx.drawImage(images.whiteHeart, heartX, iy, iw, iw);
}
}
for(; i<20; i+=2){
var heartX = (i * dw) + x;
var offY = p.health < 5 ? (round(Math.random())*2)-1 : 0
ctx.drawImage(images.deadHeart, heartX, iy+offY, iw, iw);
if(outline){
ctx.drawImage(images.whiteHeart, heartX, iy+offY, iw, iw);
}
}
//Hunger bar
for(i=0; i<p.food; i+=2){
var offY = (p.foodJitter === 0)? round(Math.random())*2 : 0
var X = maxX - ((i+4) * iw2)
if(p.food === i+1){
ctx.drawImage(images.halfDrumstick, X, iy+offY, iw, iw);
}else{
ctx.drawImage(images.drumstick, X, iy+offY, iw, iw);
}
}
for(; i<20; i+=2){
var offY = (p.foodJitter === 0)? round(Math.random())*2 : 0
var X = maxX - ((i+4) * iw2)
ctx.drawImage(images.drumstickBG, X, iy+offY, iw, iw);
}
//Oxygen bar
if(p.oxygen !== 20){
for(i=0; i<p.oxygen; i+=2){
var bubbleX = (maxX - (iw*11)) + (i * iw2)
if(p.oxygen === i+1){
ctx.drawImage(images.bubblePop, bubbleX, iy-ih, iw, iw);
}else{
ctx.drawImage(images.bubble, bubbleX, iy-ih, iw, iw);
}
}
}
//Temperature
var temp = Math.round(p.temperature)
if(temp !== 10){
for(i=0; i<temp; i+=2){
if(i+2 <= temp){
var X = maxX - (i*iw2) - iw*2
ctx.drawImage(images.hot, X, iy - ih*2, iw, iw);
}
}
var I = i
for(i=18; i>=temp; i-=2){
var X = maxX - (i*iw2) - iw*2
ctx.drawImage(images.cold, X, iy - ih*2, iw, iw);
}
if(I !== temp){
var X = maxX - (i*iw2) - iw*2
ctx.drawImage(images.warm, X, iy - ih*2, iw, iw);
}
}
var xpBar = p.XP / p.nextLevel
var level = p.level
ctx.drawImage(images.experienceBar, 0,0,182,5, x,iy+ih,s*9,10)
ctx.drawImage(images.experienceBar, 0,5,182*xpBar,5, x,iy+ih,s*9*xpBar,10)
ctx.font = "18px VT323"
ctx.textAlign = "center"
var barX = x+s*4.5
ctx.strokeStyle = "black"
ctx.lineWidth = 4
ctx.strokeText(level, barX, iy+ih)
ctx.fillStyle = colors.a
ctx.fillText(level, barX, iy+ih)
ctx.textAlign = "left"
}
if(freezeEffect > 0){
var opacity = freezeEffect / 140
ctx.globalAlpha = opacity
ctx.drawImage(images.freezeEffect,0,0,width,height)
ctx.globalAlpha = 1
}
if(inventory.showName > 0){
ctx.globalAlpha = inventory.showName > 1 ? 1 : inventory.showName
var Y = y - (s*1.5)
ctx.font = "18px VT323"
var slot = inventory.hotbar[inventory.hotbarSlot]
var name = slot && slot.id && (blockData[slot.id].Name || blockData[slot.id].name)
if(name){
var w = ctx.measureText(name).width + 20
var X = (width / 2) - (w/2)
fill(0)
ctx.fillRect(X,Y,w,s)
fill(255)
ctx.textBaseline = "Middle"
ctx.fillText(name, X+10,Y+s2)
ctx.textBaseline = "Alphabetic"
}
ctx.globalAlpha = 1
}
ctx.fillStyle = "white"
ctx.font = "10px VT323"
let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
+ "FPS: " + analytics.fps//*temp*/ + "   atk-cdn_"+attackCooldown+",start_"+attackCooldownStart+",time_"+attackCooldownTime
if (p.autoBreak) {
text("Super breaker enabled", 5, height - 89, 12)
}
if (p.autoBuild) {
text("Hyper builder enabled", 5, height - 101, 12)
}
if (multiplayer) {
let closest = Infinity
let cname = "Yourself"
for (let name in players) {
let pos = players[name]
if(pos.dimension === world.type){
let distance = sqrt((pos.x - p2.x)*(pos.x - p2.x) + (pos.y - p2.y)*(pos.y - p2.y) + (pos.z - p2.z)*(pos.z - p2.z))
if (distance < closest) {
closest = distance
cname = pos.username
}
}
}
if(cname === "Yourself") closest = 0
var info = round(closest)+" blocks away"
if(closest === 0) info = "Right here"
text(`Closest player: ${cname} (${info})`, 5, height - 113, 12)
}
ctx.textAlign = 'right'
text(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0)
ctx.textAlign = 'left'
text(str, 5, height - 77, 12)
}
function updateCraftingGrid(){
let arr = inventory.crafting.map(v => v?v.id:0)
let recipe = inventory.craftingStr = arr.join(",")
if(crafts[recipe]){
inventory.craftingRes = crafts[recipe]
}else{
var shapeless = shapelessCraft(arr)
if(shapeless){
inventory.craftingRes = crafts[shapeless]
}else{
inventory.craftingRes = 0
}
}
}
window.invScroll = 0;
let draggingInvBar = false
let invHeight = 0
var barW = 20
var invBarOffset = 0
var barH = 0
function drawInv(nodraw) {
let x = 0
let y = 0
let s = inventory.size
let s2 = s / 2
let perRow = 13
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
gl.useProgram(program3D)
gl.uniform1i(glCache.uSampler, 0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
ctx.fillStyle = "rgb(127, 127, 127)"
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx2.clearRect(0, 0, canvas.width, canvas.height)
FOV(90)
let count = 1;
if(survival){
count = invLength
}else{
for (let i = 1; i < BLOCK_COUNT; i++) {
if(!blockData[i].hidden)count ++;
}
}
invHeight = (Math.ceil(count / perRow) * s)
let invWinH = s * 9;
// Scrollbar
if(survival){invScroll = 0}else{
barH = height * (invWinH/invHeight);
if(draggingInvBar){
invScroll = map(mouseY-invBarOffset, (barH/2), height-(barH/2), 0, invHeight);
if(invScroll > invHeight) invScroll = invHeight
if(invScroll < 0) invScroll = 0
}
var barYCent = map(invScroll, 0, invHeight, (barH/2), height-(barH/2));
var barTop = barYCent - (barH/2);
fill(100)
ctx.fillRect(width-barW-2, 0, barW+2, height)
fill(200)
ctx.fillRect(width-barW, barTop, barW-2, barH)
}
// Draw the grid
ctx.translate(0, -(invScroll % s))
ctx.lineWidth = 1
ctx.strokeStyle = "black"
ctx.beginPath()
for (y = 0; y < 10; y++) {
ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s)
ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s)
}
y--
for (x = 0; x < perRow + 1; x++) {
ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2)
ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s)
}
ctx.translate(0, invScroll % s)
// Hotbar
x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
y = height - s * 1.5 + 0.5
ctx.moveTo(x, y)
ctx.lineTo(x + s * 9, y)
ctx.moveTo(x, y + s)
ctx.lineTo(x + s * 9, y + s)
for(let i = 0; i <= inventory.hotbar.length; i ++) {
ctx.moveTo(x + i * s, y)
ctx.lineTo(x + i * s, y + s)
}
ctx.stroke()
let overHot = (mouseX - x) / s | 0
if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
x += s * overHot
ctx.lineWidth = 2
ctx.strokeStyle = "white"
ctx.beginPath()
ctx.strokeRect(x, y, s, s)
}
//Box highlight in inv
let overInv = Math.round(((mouseY + invScroll) - 50) / s) * perRow + Math.round((mouseX - 50) / s)
if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
x = overInv % perRow * s + 50 - s2
y = (overInv / perRow | 0) * s + 50 - s2
y -= invScroll
if(mouseY < s*9.5){
ctx.lineWidth = 2
ctx.strokeStyle = "white"
ctx.beginPath()
ctx.strokeRect(x, y, s, s)
}
}
if (inventory.holding && inventory.holding.id) {
drawIcon(mouseX, mouseY, inventory.holding.id, inventory.holding)
if(survival){
ctx2.fillStyle = "white"
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillText(inventory.holding.amount, mouseX+s2, mouseY+s2)
}
}
if(survival){
ctx2.fillStyle = "white"
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
for (let i = 0; i < invLength; i++) {
if(invItems[i] && invItems[i].id){
x = (i) % perRow * s + 50
y = ((i) / perRow | 0) * s + 50
drawIcon(x, y - invScroll, invItems[i].id, invItems[i])
if(inventory.spreaded.length && inventory.spreaded.includes(i)){
ctx.fillStyle = "rgb(180,180,180)"
ctx.fillRect(x+1-s2,y+1-s2,s-2,s-2)
}else ctx2.fillText(invItems[i].amount, x+s2, y+s2)
}
}
}else{
let invIdx = 0;
for (let i = 1; i < BLOCK_COUNT; i++) {
invIdx ++;
if(blockData[i].hidden){
while(blockData[i] && blockData[i].hidden) i++
if(!blockData[i]) break
}
x = (invIdx - 1) % perRow * s + 50
y = ((invIdx - 1) / perRow | 0) * s + 50
y -= invScroll
if(y < s*9.5 && y > 0){
drawIcon(x, y, i)
}
}
}
if(screen === "inventory"){

let offX = width - s*4
let offY = s*2
//draw grid
ctx.lineWidth = 1
ctx.strokeStyle = "black"
ctx.beginPath()
let y = s*2+offY
let x
for(x=0; x<3; x++){
ctx.moveTo(x*s+offX, offY)
ctx.lineTo(x*s+offX, y)
}
x = s*2+offX
for(y=0; y<3; y++){
ctx.moveTo(offX, y*s+offY)
ctx.lineTo(x, y*s+offY)
}
ctx.stroke()
//icons
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
for(y=0; y<2; y++){
for(x=0; x<2; x++){
let idx = (y*3) + x
if(inventory.crafting[idx] && inventory.crafting[idx].id){
let X = x*s+offX, Y = y*s+offY
drawIcon(X+s2,Y+s2, inventory.crafting[idx].id, inventory.crafting[idx])
ctx2.fillText(inventory.crafting[idx].amount, X+s, Y+s)
}
}
}
x = Math.floor((mouseX - offX) / s)
y = Math.floor((mouseY - offY) / s)
let over = (y * 3) + x
if(!(x >= 0 && x < 2 && y >= 0 && y < 2)){
over = -1
}else if(over > -1 && over < 9){
ctx.lineWidth = 2
ctx.strokeStyle = "white"
ctx.strokeRect(x*s+offX, y*s+offY, s,s)
}
x = offX + (s/2)
y = offY + (s*3)
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
ctx.lineWidth = over?2:1
ctx.strokeStyle = over?"white":"black"
ctx.strokeRect(x,y, s,s)
if(inventory.craftingRes && inventory.craftingRes.id){
drawIcon(x+s2, y+s2, inventory.craftingRes.id, inventory.craftingRes)
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
ctx2.fillText(inventory.craftingRes.amount, x+s, y+s)
}
ctx.drawImage(gl.canvas,0,0)
if(inventory.craftingRes && inventory.craftingRes.id){
let name = blockData[inventory.craftingRes.id].Name
if(name !== "" && over){
ctx.textAlign = "left"
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10, mouseY+13+2);
}
}
}
hotbar()
//hud()
ctx.drawImage(gl.canvas, 0, 0)
// show block name on hover
if (overInv >= 0 && overInv < count - (survival?0:1) && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
x = overInv % perRow
y = (overInv / perRow | 0)
var wrongidx = x+(y*perRow)+1;
var idx=1;
if(survival){
idx = wrongidx - 1
}else{
ctx2.fillStyle = "white"
ctx2.font = "14px VT323"
ctx2.textAlign = "left"
//ctx2.fillText("creativeMenu: "+p.creativeMenu,50,20)
for(var i=1; i<wrongidx; i++){
idx++;
var temp2 = false;
//if (p.creativeMenu===0) {
temp2=true;
//} else if (blockData[i+1].menu !== undefined) {
//if (blockData[i+1].menu === p.creativeMenu) {
//temp2=true;
//}
//}
if(blockData[i+1] && (blockData[i+1].hidden || temp2 === false)){
/*let i2 = idx
while(blockData[i2] && blockData[i2].hidden){
i2++
idx++
}*/
idx++
}
}
}
let name;
if(survival){
let id = invItems[idx] ? invItems[idx].id : 0
name = id ? blockData[id].Name || blockData[id].name : "";
}else{
name = blockData[idx] ? blockData[idx].Name || blockData[idx].name : "";
}
if((name !== "") && mouseY<s*9.5){
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10, mouseY+13+2);
}
}
//show name on hover for hotbar
x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
y = height - s * 1.5 + 0.5
if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
let slot = inventory.hotbar[overHot]
let name = slot && slot.id && (blockData[slot.id].Name)
name = name || ""
if(name !== ""){
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10, mouseY+13+2);
}
}
if(!nodraw)ctx.drawImage(canvas2, 0,0)
}
function clickInv(dontRedraw,mouse) {
let s = inventory.size
let s2 = s / 2
let perRow = 13
let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
if(!survival){
var idx = 0;
for(var i=1; i<over+1; i++){
if(!blockData[i]) break;
idx ++;
if(blockData[i+1] && blockData[i+1].hidden)idx++;
}
over = idx;
}
let count = survival ? invLength : BLOCK_COUNT - 1
//for crafting
let offX = width - s*4
let offY = s * 2
let craftResX = offX+(s/2)
let craftResY = offY+(s*3)
let x = width / 2 - 9 / 2 * s + 25
let y = height - s * 1.5
let overHot = (mouseX - x) / s | 0
if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
let temp = inventory.hotbar[overHot]
inventory.hotbar[overHot] = inventory.holding
inventory.holding = temp
} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
if(survival){
if(!invItems[over]) invItems[over] = {id:0,amount:0}
if(mouse === 2 && inventory.holding.amount > 1){
let holding = inventory.holding
let slot = invItems[over]
if(holding.id){
var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
if(!slot.id){
canSplit = true
slot.id = holding.id
slot.amount = 0
}
if(canSplit){
slot.amount ++
holding.amount --
if(holding.amount <= 0) holding.id = 0
}
}
}else{
if(invItems[over] && invItems[over].id){
let temp = inventory.holding
if(temp.id === invItems[over].id && temp.amount < blockData[temp.id].stackSize && invItems[over].amount < blockData[invItems[over].id].stackSize){ //stacking together
let stackSize = blockData[invItems[over].id].stackSize
while(temp.amount > 0){
temp.amount--
invItems[over].amount ++
if(invItems[over].amount >= blockData[invItems[over].id].stackSize) break
}
if(temp.amount <= 0){
temp.id = 0
}
}else{
inventory.holding = invItems[over]
if(temp && temp.id){
invItems[over] = temp
}else invItems[over] = {id:0,amount:0}
}
}else if(inventory.holding){
invItems[over] = inventory.holding
inventory.holding = 0
inventory.spreadStart = over
inventory.spreadPlace = "invSpace"
}
}
}else{
inventory.holding = {id:over + 1, amount:blockData[over+1].stackSize}
}
} else if(screen === "inventory" && mouseX>offX && mouseX<offX+(s*2) && mouseY>offY && mouseY<offY+(s*2)){
//inv crafting grid
let X = Math.floor((mouseX - offX) / s)
let Y = Math.floor((mouseY - offY) / s)
let idx = (Y*3)+X
if(mouse === 2 && inventory.holding.amount > 1){
if(!inventory.crafting[idx]) inventory.crafting[idx] = {id:0,amount:0}
let holding = inventory.holding
let slot = inventory.crafting[idx]
if(holding.id){
var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
if(!slot.id){
canSplit = true
slot.id = holding.id
slot.amount = 0
}
if(canSplit){
slot.amount ++
holding.amount --
if(holding.amount <= 0) holding.id = 0
}
}
}else{
let temp = inventory.holding
inventory.holding = inventory.crafting[idx]
inventory.crafting[idx] = temp
}
updateCraftingGrid()
}else if(screen === "inventory" && mouseX>craftResX && mouseX<craftResX+s && mouseY>craftResY && mouseY<craftResY+s && inventory.craftingRes && inventory.craftingRes.id){
//inv crafting output
var res = inventory.craftingRes
inventory.holding = {id:res.id,amount:res.amount}
for(let i=0; i<9; i++){
let block = inventory.crafting[i]
if(block && block.id){
block.amount --
if(block.amount < 1)inventory.crafting[i].id = 0
}
}
var r = inventory.holding && inventory.holding.id
if(r === blockIds.craftingTable){
achievment("Benchmaking")
}
updateCraftingGrid()
}else if(screen === "crafting" && mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){}else{
inventory.holding = 0
}
if(!dontRedraw)drawScreens.inventory()
}
function moveInv(){
let s = inventory.size
let s2 = s / 2
let perRow = 13
let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
if(!survival){
var idx = 0;
for(var i=1; i<over+1; i++){
if(!blockData[i]) break;
idx ++;
if(blockData[i+1] && blockData[i+1].hidden)idx++;
}
over = idx;
}
let count = survival ? invLength : BLOCK_COUNT - 1
//for crafting
let offX = width - s*4
let offY = s * 2
let craftResX = offX+(s/2)
let craftResY = offY+(s*3)
let x = width / 2 - 9 / 2 * s + 25
let y = height - s * 1.5
let overHot = (mouseX - x) / s | 0
if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
//hotbar
} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
if(survival){
if(!invItems[over]) invItems[over] = {id:0,amount:0}
if(inventory.spreadPlace === "invSpace" && inventory.spreadStart > -1 && invItems[inventory.spreadStart].amount > 1 && mouseDown){
inventory.spreading = true
}
if(inventory.spreading && !(invItems[over] && invItems[over].id) && over !== inventory.spreadStart && inventory.spreaded.length < invItems[inventory.spreadStart].amount){
if(inventory.spreaded.length){
invItems[over] = invItems[inventory.spreadStart]
inventory.spreaded.push(over)
}else{
invItems[over] = invItems[inventory.spreadStart]
inventory.spreaded.push(inventory.spreadStart, over)
}
}
}
}
}
function releaseInv(){
let s = inventory.size
let s2 = s / 2
let perRow = 13
let over = Math.round((mouseY + invScroll - 50) / s) * perRow + Math.round((mouseX - 50) / s)
if(!survival){
var idx = 0;
for(var i=1; i<over+1; i++){
if(!blockData[i]) break;
idx ++;
if(blockData[i+1] && blockData[i+1].hidden)idx++;
}
over = idx;
}
let count = survival ? invLength : BLOCK_COUNT - 1
//for crafting
let offX = width - s*4
let offY = s * 2
let craftResX = offX+(s/2)
let craftResY = offY+(s*3)
let x = width / 2 - 9 / 2 * s + 25
let y = height - s * 1.5
let overHot = (mouseX - x) / s | 0
if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
//hotbar
} else if (over >= 0 && over < count && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2 && mouseY < s*9.5) {
if(survival){
if(!invItems[over]) invItems[over] = {id:0,amount:0}
if(inventory.spreadPlace === "invSpace" && inventory.spreaded.length){
//a/b with remainder
var a=invItems[inventory.spreadStart].amount
var b=inventory.spreaded.length
var n=a/b
var f=floor(n)
var r=n-f
n=f
r=floor(r*b)//sometimes not precise so use floor
//n = result   r = remainder
var id = invItems[inventory.spreadStart].id
for(var i=0; i<inventory.spreaded.length; i++){
invItems[inventory.spreaded[i]] = {id:id, amount:n}
}
if(r) inventory.holding = {id:id, amount:r}
inventory.spreaded = []
}
inventory.spreadStart = -1
inventory.spreading = false
}
}
}
function drawCrafting(mouse) {
drawInv(true, mouse)
let s = inventory.size
let s2 = s/2
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
let offX = width - s*4
let offY = s * 2
//draw grid
ctx.lineWidth = 1
ctx.strokeStyle = "black"
ctx.beginPath()
let y = s*3+offY
let x
for(x=0; x<4; x++){
ctx.moveTo(x*s+offX, offY)
ctx.lineTo(x*s+offX, y)
}
x = s*3+offX
for(y=0; y<4; y++){
ctx.moveTo(offX, y*s+offY)
ctx.lineTo(x, y*s+offY)
}
ctx.stroke()
//icons
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
for(y=0; y<3; y++){
for(x=0; x<3; x++){
let idx = (y*3) + x
if(inventory.crafting[idx] && inventory.crafting[idx].id){
let X = x*s+offX, Y = y*s+offY
drawIcon(X+s2,Y+s2, inventory.crafting[idx].id, inventory.crafting[idx])
ctx2.fillText(inventory.crafting[idx].amount, X+s, Y+s)
}
}
}
x = Math.floor((mouseX - offX) / s)
y = Math.floor((mouseY - offY) / s)
let over = (y * 3) + x
if(!(x >= 0 && x < 3 && y >= 0 && y < 3)){
over = -1
}else if(over > -1 && over < 9){
ctx.lineWidth = 2
ctx.strokeStyle = "white"
ctx.strokeRect(x*s+offX, y*s+offY, s,s)
}
x = offX + (s)
y = offY + (s*4)
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
ctx.lineWidth = over?2:1
ctx.strokeStyle = over?"white":"black"
ctx.strokeRect(x,y, s,s)
if(inventory.craftingRes && inventory.craftingRes.id){
drawIcon(x+s2, y+s2, inventory.craftingRes.id, inventory.craftingRes)
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
ctx2.fillText(inventory.craftingRes.amount, x+s, y+s)
}
ctx.drawImage(gl.canvas,0,0)
if(inventory.craftingRes && inventory.craftingRes.id){
let name = blockData[inventory.craftingRes.id].Name
if(name !== "" && over){
ctx.textAlign = "left"
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10, mouseY+13+2);
}
}
ctx.drawImage(canvas2,0,0)
}
function clickCrafting(mouse) {
clickInv(true, mouse)
let s = inventory.size
let s2 = s/2
let offX = width - s*4
let offY = s * 2
let x = offX + (s)
let y = offY + (s*4)
//get thing from output
let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
if(over && inventory.craftingRes && inventory.craftingRes.id){
var res = inventory.craftingRes
inventory.holding = {id:res.id,amount:res.amount}
for(let i=0; i<9; i++){
let block = inventory.crafting[i]
if(block && block.id){
block.amount --
if(block.amount < 1)inventory.crafting[i].id = 0
}
}
//achievments
var r = inventory.holding && inventory.holding.id
if(r && blockData[r].pickaxe){
achievment("Time to Mine!")
}
if(r === blockIds.stonePickaxe){
achievment("Getting an Upgrade")
}
if(r === blockIds.bread){
achievment("Bake Bread")
}
if(r && blockData[r].sword){
achievment("Time to Strike!")
}
if(r && blockData[r].hoe){
achievment("Time to Farm!")
}
}
//grid
if(mouseX>offX && mouseX<offX+(s*3) && mouseY>offY && mouseY<offY+(s*3)){
let X = Math.floor((mouseX - offX) / s)
let Y = Math.floor((mouseY - offY) / s)
let idx = (Y*3)+X
let temp = inventory.holding
if(mouse === 2 && inventory.holding.amount > 1){
if(!inventory.crafting[idx]) inventory.crafting[idx] = {id:0,amount:0}
let holding = inventory.holding
let slot = inventory.crafting[idx]
if(holding.id){
var canSplit = holding.id === slot.id && slot.amount < blockData[slot.id].stackSize
if(!slot.id){
canSplit = true
slot.id = holding.id
slot.amount = 0
}
if(canSplit){
slot.amount ++
holding.amount --
if(holding.amount <= 0) holding.id = 0
}
}
}else{
inventory.holding = inventory.crafting[idx]
inventory.crafting[idx] = temp
}
}
updateCraftingGrid()
drawScreens.crafting()
}
function drawFurnace(){
drawInv(true)
let s = inventory.size
let s2 = s/2
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
var toPlay
var data = world.getTags(furnaceData.x, furnaceData.y, furnaceData.z)
if(!data || !(data&&data.furnace)){
var block = world.getBlock(furnaceData.x, furnaceData.y, furnaceData.z)
if(blockData[block].name === "furnace"){
data = {furnace:true, input:0, fuel:0, output:0, smeltStart:0, burnStart:0, canBurn:false, smelting:false, xp:0}
world.setTags(furnaceData.x, furnaceData.y, furnaceData.z, data)
}else toPlay = true //furnace doesn't exsist here
}
furnaceData.data = data
if(toPlay){
play()
return
}
data.smelting = data.input && data.fuel && smelts[data.input.id] && smeltFuel[data.fuel.id] && true
if(data.smelting){
var smeltTo = smelts[data.input.id]
var fuel = smeltFuel[data.fuel.id]
var seconds = (Date.now() - data.smeltStart) / 1000
var progress = seconds * 20 //ticks
var burnProgress = (Date.now() - data.burnStart) / 1000
data.progress = progress / smeltTo.time
data.burnProgress = 1-(burnProgress / fuel.time)
if(progress >= smeltTo.time){
var a = floor(progress/smeltTo.time)
for(var i=0; i<a; i++){
data.input.amount --
data.xp += smeltTo.xp
if(data.output){
data.output.amount ++
}else{
data.output = {id:smeltTo.id, amount:1}
}
if(data.input.amount <= 0){
data.input = 0
break
}
}
data.smeltStart += (a/20)*smeltTo.time*1000
world.updateTags(furnaceData.x,furnaceData.y,furnaceData.z)
}
if(burnProgress >= fuel.time){
data.canBurn = false
}
if(!data.canBurn){
var a = floor(burnProgress/fuel.time)
for(var i=0; i<a; i++){
data.fuel.amount --
if(data.fuel.amount === 0){
data.fuel = 0
break
}
}
world.updateTags(furnaceData.x,furnaceData.y,furnaceData.z)
data.burnStart += a*fuel.time*1000
data.canBurn = true
}
}
var block = world.getBlock(furnaceData.x,furnaceData.y,furnaceData.z)
var needs
if((block & SOUTH) === SOUTH){
needs = SOUTH
}else if((block & WEST) === WEST){
needs = WEST
}else if((block & EAST) === EAST){
needs = EAST
}else{
needs = NORTH
}
needs |= blockIds.furnace
if(data.smelting){
needs |= SLAB
}
if(!toPlay && block !== needs){
world.setBlock(furnaceData.x,furnaceData.y,furnaceData.z, needs, false, false, false, true)//last argument is keepTags
}
let offX = width - s*4
let offY = s * 2
ctx.font = "20px VT323"
ctx.fillStyle = "white"
ctx.textAlign = "left"
ctx.fillText("Furnace", offX, offY - s2)
//font for numbers
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
let x = offX+s2-2
let y = offY+s
fill(100)
ctx.fillRect(x,y,4,s)
if(data.burnProgress){
fill(255,data.burnProgress*255,0)
let h = data.burnProgress*s
ctx.fillRect(x,y+s-h,4,h)
}
x = offX+s
y = offY+s
ctx.strokeStyle = "black"
ctx.lineWidth = 1
ctx.beginPath()
ctx.moveTo(x+s,y+s2)
ctx.lineTo(x+s2,y)
ctx.moveTo(x+s,y+s2)
ctx.lineTo(x+s2,y+s)
ctx.stroke()
y = y+s2-2
fill(0)
ctx.fillRect(x,y,s,4)
if(data.progress){
fill(255)
ctx.fillRect(x,y,s*data.progress,4)
}
//input
x = offX
y = offY
let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
ctx.lineWidth = over?2:1
ctx.strokeStyle = over?"white":"black"
ctx.strokeRect(x,y, s,s)
if(data.input && data.input.id){
drawIcon(x+s2, y+s2, data.input.id, data.input)
ctx2.fillText(data.input.amount, x+s, y+s)
}
//fuel
x = offX
y = offY + (s*2)
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
ctx.lineWidth = over?2:1
ctx.strokeStyle = over?"white":"black"
ctx.strokeRect(x,y, s,s)
if(data.fuel && data.fuel.id){
drawIcon(x+s2, y+s2, data.fuel.id, data.fuel)
ctx2.fillText(data.fuel.amount, x+s, y+s)
}
//output
x = offX + (s*2)
y = offY + s
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
ctx.lineWidth = over?2:1
ctx.strokeStyle = over?"white":"black"
ctx.strokeRect(x,y, s,s)
if(data.output && data.output.id){
drawIcon(x+s2, y+s2, data.output.id, data.output)
ctx2.fillText(data.output.amount, x+s, y+s)
}
ctx.drawImage(gl.canvas,0,0)
if(over && data.output && data.output.id){ //this is right aligned so you can see it
let name = blockData[data.output.id].Name
if(name !== "" && over){
ctx.textAlign = "left"
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX-w-20, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10-w-20, mouseY+13+2);
}
}
ctx.drawImage(canvas2,0,0)
}
function clickFurnace(mouse){
let s = inventory.size
let s2 = s/2
let offX = width - s*4
let offY = s * 2
var data = furnaceData.data //inventory.furnaceData.data
let temp
var clicked
//input
let x = offX
let y = offY
let over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
if(over){
temp = data.input
data.input = inventory.holding
inventory.holding = temp
data.smeltStart = Date.now()
data.burnStart = Date.now()
clicked = true
}
//fuel
x = offX
y = offY + (s*2)
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
if(over){
temp = data.fuel
data.fuel = inventory.holding
inventory.holding = temp
data.burnStart = Date.now()
data.smeltStart = Date.now()
clicked = true
}
//output
x = offX + (s*2)
y = offY + s
over = mouseX>x && mouseX<x+s && mouseY>y && mouseY<y+s
if(over){
inventory.holding = data.output
if(data.output && data.output.id){
var xp = data.xp
data.xp = 0
world.addEntity(new ExperienceOrb(p.x,p.y,p.z, xp))
}
data.output = 0
clicked = true
}
if(clicked){
world.updateTags(furnaceData.x,furnaceData.y,furnaceData.z)
}else{
clickInv(true, mouse)
}
drawScreens.furnace()
}
function drawChest(){
drawInv(true)
let s = inventory.size
let s2 = s/2
var w = 9
var h = 3
var length = w*h
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
var toPlay
var data = world.getTags(chestData.x, chestData.y, chestData.z)
if(!data || !(data&&data.chest)){
var block = world.getBlock(chestData.x, chestData.y, chestData.z)
if(blockData[block].name === "chest"){
data = {chest:true, contents:new Array(length).fill(0)}
world.setTags(chestData.x, chestData.y, chestData.z, data)
}else toPlay = true //chest doesn't exsist here
}
chestData.data = data
if(toPlay){
play()
return
}
var x = 50.5 - s2
var y = 10.2*s
ctx.lineWidth = 1
ctx.strokeStyle = "black"
ctx.beginPath()
for(var lx = 0; lx < w + 1; lx++){
ctx.moveTo(x + lx*s, y)
ctx.lineTo(x + lx*s, y+h*s)
}
for(var ly = 0; ly < h + 1; ly++){
ctx.moveTo(x, y+ly*s)
ctx.lineTo(x + w*s, y+ly*s)
}
ctx.stroke()
var over = mouseX > x && mouseY > y && mouseX < x+w*s && mouseY < y+h*s ? (floor((mouseX-x)/s) + floor((mouseY-y)/s)*w) : -1
if(over >= 0 && over < length){
var ox = ((over%w)*s)+x
var oy = (floor(over/w)*s)+y
ctx.strokeStyle = "white"
ctx.lineWidth = 2
ctx.strokeRect(ox,oy,s,s)
}
ctx.fillStyle = "white"
ctx.font = "15px VT323"
ctx.textAlign = "left"
ctx.fillText("Chest & stuff", x, y-7)
ctx2.font = "14px VT323"
ctx2.textAlign = "right"
ctx2.fillStyle = "white"
if(data.contents){
for(var i=0; i<length; i++){
var item = data.contents[i]
if(!item || !item.id) continue
var ix = i%w
var iy = floor(i/w)
ix = x + ix*s
iy = y + iy*s
drawIcon(ix+s2,iy+s2, item.id, item)
if(item.amount !== 1) ctx2.fillText(item.amount, ix+s, iy+s)
}
}
ctx.drawImage(gl.canvas,0,0)
if(over >= 0 && over < length && data.contents){
var item = data.contents[over]
let name = item ? (blockData[item.id].Name) : ""
if(name !== ""){
ctx.textAlign = "left"
ctx.font = "16px VT323";
var w = ctx.measureText(name).width;
fill(0)
ctx.fillRect(mouseX, mouseY, w+20, 20);
fill(255);
ctx.fillText(name, mouseX+10, mouseY+13+2);
}
}
ctx.drawImage(canvas2,0,0)
}
function clickChest(mouse){
let s = inventory.size
let s2 = s/2
var w = 9
var h = 3
var length = w*h
var x = 50.5 - s2
var y = 10.2*s
var over = mouseX > x && mouseY > y && mouseX < x+w*s && mouseY < y+h*s ? (floor((mouseX-x)/s) + floor((mouseY-y)/s)*w) : -1
var c = chestData.data.contents
if(over >= 0 && over < length && c){
let temp = c[over]
c[over] = inventory.holding
inventory.holding = temp
world.updateTags(chestData.x,chestData.y,chestData.z)
}else clickInv(true, mouse)
drawScreens.chest()
}
let unpauseDelay = 0
function mmoved(e) {
let mouseS = settings.mouseSense / 30000
p.rx -= e.movementY * mouseS
p.ry += e.movementX * mouseS
while(p.ry > Math.PI*2) {
p.ry -= Math.PI*2
}
while(p.ry < 0) {
p.ry += Math.PI*2
}
if(p.rx > Math.PI / 2) {
p.rx = Math.PI / 2
}
if(p.rx < -Math.PI / 2) {
p.rx = -Math.PI / 2
}
}
function trackMouse(e) {
if (screen !== "play") {
cursor("")
mouseX = e.x
mouseY = e.y
if(screen !== "main menu" && !(screen === "furnace" && furnaceData.data.smelting)){
drawScreens[screen]()
Button.draw()
Slider.draw()
Slider.drag()
}
}
if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest") moveInv()
}
document.onmousemove = trackMouse
//added by me from mobile test minekhan with more code
//https://www.khanacademy.org/computer-programming/mobile-test-minekhan/5100360783052800
win.pTouch = {x: -100, y: 0};
canvas.addEventListener("touchstart", function(e) {
pTouch.x = e.changedTouches[0].pageX;
pTouch.y = e.changedTouches[0].pageY;
pTouch.touching = mouseDown=true
pTouch.touchStart = Date.now()
pTouch.moved = false
pTouch.canDig = true
}, false);
canvas.addEventListener("touchmove", function(e) {
e.movementY = -(e.changedTouches[0].pageY - pTouch.y);
e.movementX = -(e.changedTouches[0].pageX - pTouch.x);
pTouch.x = e.changedTouches[0].pageX;
pTouch.y = e.changedTouches[0].pageY;
mmoved(e);
pTouch.moved = true
if(Date.now() - pTouch.touchStart < touchMoveLimit && e.movementX < 10 && e.movementY < 10){
pTouch.canDig = false
}
e.preventDefault();
}, false);
var touchend = e => {
pTouch.touching = mouseDown = false
}
canvas.addEventListener("touchend",touchend,false)
canvas.addEventListener("touchcancel",touchend,false)
document.onpointerlockchange = function() {
if (doc.pointerLockElement === canvas) {
doc.onmousemove = mmoved
} else {
doc.onmousemove = trackMouse
if (screen === "play" && !freezeFrame) {
changeScene("pause")
unpauseDelay = Date.now() + 1000
}
}
for (let key in Key) {
Key[key] = false
}
}
canvas.onmousedown = function(e) {
mouseX = e.x
mouseY = e.y
mouseDown = true
let block, index
var mouseKey
switch(e.button) {
case 0:
mouseKey = "leftMouse"
Key.leftMouse = true
break
case 1:
mouseKey = "middleMouse"
Key.middleMouse = true
if (!hitBox.pos || survival) break
updateHUD = true
block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) & 0x3ff
index = -1
for(var i=0; i<inventory.hotbar.length; i++){
if(inventory.hotbar[i].id === block){
index = i
break
}
}
if (index >= 0) {
inventory.hotbarSlot = index
} else {
inventory.hotbar[inventory.hotbarSlot] = {id:block, amount:1}
}
break
case 2:
mouseKey = "rightMouse"
Key.rightMouse = true
break
}
if(screen === "play") {
if (doc.pointerLockElement !== canvas) {
getPointer()
p.lastBreak = Date.now()
} else {
place = false
if(mouseKey === controlMap.break.key) {
if(Key.control) {
place = true
} else if(entHitbox.ent){
holding = inventory.hotbar[inventory.hotbarSlot].id
entClick()
}else if(!survival){
changeWorldBlock(0)
}
}
holding = inventory.hotbar[inventory.hotbarSlot].id
if(mouseKey === controlMap.place.key && holding) {
place = true
}
if(place) {
p.spyglassStart = Date.now()
newWorldBlock()
}
}
} else if (screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest") {
if(mouseDown && mouseX >= width-barW){
draggingInvBar = true
invBarOffset = mouseY-map(invScroll, 0, invHeight, (barH/2), height-(barH/2))
}
if(screen === "crafting")clickCrafting(e.button)
else if(screen === "furnace")clickFurnace(e.button)
else if(screen === "chest") clickChest(e.button)
else clickInv(false, e.button)
}
Button.click()
Slider.click()
}
canvas.onmouseup = function(e) {
switch(e.button) {
case 0:
Key.leftMouse = false
break
case 1:
Key.middleMouse = false
break
case 2:
Key.rightMouse = false
break
}
mouseDown = false
Slider.release()
draggingInvBar = false
if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest") releaseInv()
}
for(var onscreencontrol in onscreenControls){
var onscreencontrolElement = onscreenControls[onscreencontrol]
onscreencontrolElement.value = onscreencontrol
onscreencontrolElement.onmousedown=function(){
canvas.onkeydown({key:this.value})
}
onscreencontrolElement.onmouseup=function(){
canvas.onkeyup({key:this.value})
}
onscreencontrolElement.addEventListener("touchstart",onscreencontrolElement.onmousedown)
onscreencontrolElement.addEventListener("touchend",onscreencontrolElement.onmouseup)
onscreencontrolElement.addEventListener("touchcancel",onscreencontrolElement.onmouseup)
}
onscreenControls[" "].addEventListener("click",function(){
if (!survival && !p.spectator) {//fly toggle
if (Date.now() < p.lastJump + 400) {
p.flying ^= true
} else {
p.lastJump = Date.now()
}
}
})
let lastForward = 0
onscreenControls.w.addEventListener("touchstart",function(){
if (Date.now() < lastForward + 400) { //sprint toggle
player.sprinting = true
} else {
lastForward = Date.now()
}
})
onscreenControls.w.addEventListener("touchend",() => p.sprinting = false)
onscreenControls.w.addEventListener("touchcancel",() => p.sprinting = false)
onscreenControls[" "].addEventListener("mousedown",function(){
Key[" "]=true
})
onscreenControls[" "].addEventListener("mouseup",function(){
Key[" "]=false
})
onscreenControls[" "].addEventListener("touchstart",function(){
Key[" "]=true
})
onscreenControls[" "].addEventListener("touchend",function(){
Key[" "]=false
})
onscreenControl_Element.onclick = e => {mouseX = e.x; mouseY = e.y}
let changeSlot = () => {
for(let i = 0; i < inventory.hotbar.length; i ++) {
let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
let y = height - inventory.size
x -= inventory.size/2
y -= inventory.size/2
if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
inventory.hotbarSlot = i
holding = inventory.hotbar[inventory.hotbarSlot].id
updateHUD = true
}
}
i ++
let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
let y = height - inventory.size
x -= inventory.size/2
y -= inventory.size/2
if((mouseX>x)&&(mouseY>y)&&(mouseX < x+inventory.size)&&(mouseY < y+inventory.size)){
changeScene("inventory")
}
}
onscreenControl_Element.addEventListener("click",changeSlot)
onscreenControl_Element.addEventListener("touchend",changeSlot)
canvas.onkeydown = function(e) {
let k = e.key.toLowerCase()
if (e.preventDefault && k === " ") {
e.preventDefault()
}
if (e.repeat || Key[k]) {
return
}
Key[k] = true
if (k === "t") {
initTextures()
}
if (k === controlMap.cycleBlockShapes.key) {
blockMode = blockMode === CUBE ? SLAB : (blockMode === SLAB ? STAIR : (blockMode === STAIR ? FENCE : (blockMode === FENCE ? WALLPOST : (blockMode === WALLPOST ? WALL : (blockMode === WALL ? WALLU : (blockMode === WALLU ? FENCQ : CUBE))))))
updateHUD = true
}
if (screen === "inventory") {
for (var temp3=0;temp3<10;temp3++) {
if (k === temp3+"") {
p.creativeMenu = temp3
}
}
}
if (screen === "play") {
if(k === controlMap.pause.key) {
releasePointer()
changeScene("pause")
}
if(k === controlMap.superBreaker.key) {
p.autoBreak = !p.autoBreak
updateHUD = true
if(survival) p.autoBreak = false
}
if(k === controlMap.hyperBuilder.key) {
p.autoBuild = !p.autoBuild
updateHUD = true
if(survival) p.autoBuild = false
}
if (k === controlMap.jump.key && !p.spectator) {
if (Date.now() < p.lastJump + 400) {
p.flying ^= true
if(survival) p.flying = false
} else {
p.lastJump = Date.now()
}
}
if (k === controlMap.zoom.key) {
p.FOV(10, 300)
}
if (k === controlMap.sneak.key && !p.flying) {
p.sneaking = true
if (p.sprinting) {
p.FOV(settings.fov, 100)
}
p.sprinting = false
p.speed = p.sneakSpeed
p.bottomH = 1.32
//p.y -= 0.3
}
if (k === controlMap.spectator.key) {
p.spectator = !p.spectator
p.flying = true
p.onGround = false
if(survival){
p.spectator = false
p.flying = false
}
updateHUD = true
}
if (k === controlMap.thirdPerson.key){
if(!p.thirdPerson){
p.thirdPerson = true
}else if(p.thirdPerson === "front"){
p.thirdPerson = false
}else{
p.thirdPerson = "front"
}
}
if (k === controlMap.inventory.key) {
changeScene("inventory")
releasePointer()
achievment("Taking Inventory")
}
if (k === ";") {
releasePointer()
freezeFrame = true
}
if(k === controlMap.chat.key){
Messages.showInput()
e.preventDefault()
}
if (k === controlMap.dropItem.key && inventory.hotbar[inventory.hotbarSlot] && inventory.hotbar[inventory.hotbarSlot].id) {
let d = p.direction
let block = holding || inventory.hotbar[inventory.hotbarSlot].id
block = block < isCube ? block | blockMode : block
world.addEntity(new Item(p.x, p.y, p.z, d.x/4, d.y/4, d.z/4, block, false, 1,inventory.hotbar[inventory.hotbarSlot].durability))
if(survival){
inventory.hotbar[inventory.hotbarSlot].amount --
updateHUD = true
}
}
if(Number(k)) {
inventory.hotbarSlot = Number(k) - 1
inventory.showName = 1.5
holding = inventory.hotbar[inventory.hotbarSlot].id
updateHUD = true
}
} else if (screen === "pause") {
if(k === controlMap.pause.key) {
play()
}
} else if (screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest") {
if (k === controlMap.inventory.key) {
if(screen === "crafting" || screen === "inventory"){
for(var i=0; i<9; i++){
if(inventory.crafting[i] && inventory.crafting[i].id){
for(var n=0; n<inventory.crafting[i].amount; n++){
if(!newInvItem(inventory.crafting[i].id)){
world.addEntity(new Item(p.x,p.y,p.z,0,0,0,inventory.crafting[i].id))
}
}
inventory.crafting[i].id = 0
}
}
inventory.craftingRes = 0
}
play()
}
if (k === controlMap.cycleBlockShapes.key) {
drawScreens.inventory()
}
}
}
canvas.onkeyup = function(e) {
let k = e.key.toLowerCase()
Key[k] = false
if(k === "escape" && (screen === "pause" || screen === "inventory" || screen === "options" && previousScreen === "pause") && Date.now() > unpauseDelay) {
play()
}
if (screen === "play") {
if (k === controlMap.zoom.key) {
p.FOV(settings.fov, 300)
}
if (k === controlMap.sneak.key && p.sneaking) {
p.sneaking = false
p.speed = p.defaultSpeed
p.bottomH = 1.62
// p.y += 0.3
}
}
}
canvas.onblur = function() {
for (let key in Key) {
Key[key] = false
}
mouseDown = false
Slider.release()
}
canvas.oncontextmenu = function(e) {
e.preventDefault()
}
window.onbeforeunload = e => { 
if (screen === "play" && Key.control) {
releasePointer()
e.preventDefault()
e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
return true
}
}
canvas.onwheel = e => {
e.preventDefault()
e.stopPropagation()
if(screen === "play"){
if (e.deltaY > 0) {
inventory.hotbarSlot++
} else if (e.deltaY < 0) {
inventory.hotbarSlot--
}
if (inventory.hotbarSlot > 8) {
inventory.hotbarSlot = 0
} else if (inventory.hotbarSlot < 0) {
inventory.hotbarSlot = 8
}
inventory.showName = 1.5
updateHUD = true
holding = inventory.hotbar[inventory.hotbarSlot].id
}
if(screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest"){
invScroll += e.deltaY
if(invScroll < 0) invScroll = 0
if(invScroll > invHeight) invScroll = invHeight
drawScreens[screen]()
}
}
document.onwheel = e => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
window.onresize = e => {
width = window.innerWidth
height = window.innerHeight
canvas.height = height
canvas.width = width
ctx.imageSmoothingEnabled = false
canvas2.width = width
canvas2.height = height
gl.canvas.height = height
gl.canvas.width = width
gl.viewport(0, 0, width, height)
initButtons()
initBackgrounds()
inventory.size = 40 * min(width, height) / 600
inventory.ts = inventory.size / 16
genIcons()
use3d()
p.FOV(p.currentFov + 0.0001)
if (screen === "play") {
play()
} else {
drawScreens[screen]()
Button.draw()
Slider.draw()
}
}
function use2d() {
gl.disableVertexAttribArray(glCache.aTexture)
gl.disableVertexAttribArray(glCache.aShadow)
gl.disableVertexAttribArray(glCache.aVertex)
gl.disableVertexAttribArray(glCache.aSkylight)
gl.disableVertexAttribArray(glCache.aBlocklight)
gl.useProgram(program2D)
gl.enableVertexAttribArray(glCache.aVertex2)
gl.enableVertexAttribArray(glCache.aTexture2)
gl.enableVertexAttribArray(glCache.aShadow2)
}
function use3d() {
gl.disableVertexAttribArray(glCache.aTexture2)
gl.disableVertexAttribArray(glCache.aShadow2)
gl.disableVertexAttribArray(glCache.aVertex2)
gl.useProgram(program3D)
gl.enableVertexAttribArray(glCache.aVertex)
gl.enableVertexAttribArray(glCache.aTexture)
gl.enableVertexAttribArray(glCache.aShadow)
gl.enableVertexAttribArray(glCache.aSkylight)
gl.enableVertexAttribArray(glCache.aBlocklight)
}
let maxLoad = 1
function startLoad() {
// Runs when the loading screen is opened; cache the player's position
p2.x = p.x
p2.y = p.y
p2.z = p.z
maxLoad = world.loadFrom.length + 9
}
function initWebglPrograms(){
modelView = new Float32Array(16)
glCache = {}
win.glCache = glCache
program3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D)
program2D = createProgramObject(gl, vertexShaderSrc2D, fragmentShaderSrc2D)
skyboxProgram = createProgramObject(gl, skyboxVertex, skyboxFragment);
programEntity = createProgramObject(gl, vertexShaderSrcEntity, fragmentShaderSrcEntity)
programParticle = createProgramObject(gl, vertexShaderSrcParticle, fragmentShaderSrcParticle)
skybox = new Skybox()
gl.useProgram(program2D)
glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")
gl.useProgram(skyboxProgram)
glCache.skyboxVertex = gl.getAttribLocation(skyboxProgram, "aVertex");
glCache.skyboxTime = gl.getUniformLocation(skyboxProgram, "time");
glCache.skyboxView = gl.getUniformLocation(skyboxProgram, "uView");
gl.useProgram(programEntity)
glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
glCache.uLightLevelEntity = gl.getUniformLocation(programEntity, "uLightLevel")
glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
glCache.harmEffectEntity = gl.getUniformLocation(programEntity, "harmEffect")
glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")
glCache.isTextureAtlasEntity = gl.getUniformLocation(programEntity, "isTextureAtlas")
glCache.tintEntity = gl.getUniformLocation(programEntity, "tint")
gl.uniform1i(glCache.isTextureAtlasEntity, 1)
gl.uniform3f(glCache.tintEntity, 1,1,1)
gl.useProgram(programParticle)
glCache.uSamplerParticle = gl.getUniformLocation(programParticle, "uSampler")
glCache.uLightLevelParticle = gl.getUniformLocation(programParticle, "uLightLevel")
glCache.uViewParticle = gl.getUniformLocation(programParticle, "uView")
glCache.aTextureParticle = gl.getAttribLocation(programParticle, "aTexture")
glCache.aVertexParticle = gl.getAttribLocation(programParticle, "aVertex")
glCache.isTextureAtlasParticle = gl.getUniformLocation(programParticle, "isTextureAtlas")
gl.uniform1i(glCache.isTextureAtlasParticle, 1)
gl.useProgram(program3D)
glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
glCache.uPos = gl.getUniformLocation(program3D, "uPos")
glCache.uDist = gl.getUniformLocation(program3D, "uDist")
glCache.uTime = gl.getUniformLocation(program3D, "uTime")
glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")
glCache.skyColor = gl.getUniformLocation(program3D, "skyColor")
glCache.inWater = gl.getUniformLocation(program3D, "inWater")
glCache.uTrans = gl.getUniformLocation(program3D, "uTrans")
glCache.tint = gl.getAttribLocation(program3D, "aTint")
glCache.isInWorld = gl.getUniformLocation(program3D, "isInWorld")
glCache.flicker = gl.getUniformLocation(program3D, "flicker")
gl.uniform1i(glCache.uTrans, 0)
gl.uniform1f(glCache.uDist, 1000)
gl.uniform1i(glCache.isInWorld, 0)
gl.uniform1i(glCache.flicker, 0)
gl.disableVertexAttribArray(glCache.tint)
gl.vertexAttrib3f(glCache.tint, 1,1,1)
}
win.initWebglPrograms = initWebglPrograms
function initWebgl() {
if (!win.gl) {
let canv = document.createElement('canvas')
canv.width = ctx.canvas.width
canv.height = ctx.canvas.height
canv.style.position = "absolute"
canv.style.zIndex = -1
canv.style.top = "0px"
canv.style.left = "0px"
gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false})
let ext = gl.getExtension('OES_element_index_uint')
if (!ext) {
alert("Please use a supported browser, or update your current browser.")
}
gl.viewport(0, 0, canv.width, canv.height)
gl.enable(gl.DEPTH_TEST)
gl.enable(gl.BLEND)
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
win.gl = gl
glExtensions = []
const availableExtensions = gl.getSupportedExtensions()
for (let i = 0; i < availableExtensions.length; i++) {
const extensionName = availableExtensions[i]
glExtensions[extensionName.replace(/[A-Z]+_/g, "")] = gl.getExtension(extensionName)
}
} else {
gl = win.gl
}
if (!document.body.contains(gl.canvas)) {
document.body.append(gl.canvas)
}
initWebglPrograms()
//Send the block textures to the GPU
initTextures()
initShapes()
/*var data = []
var rt = Math.PId/360
var s = sin(-rt), c = cos(-rt)
for(var deg=0; deg<Math.PId; deg+=rt){
var s2 = sin(deg+rt), c2 = cos(deg+rt)
data.push(s,0,c, s2,0,c, s2,1,c2, s,1,c2)
s = s2, c = c2
}*/
/*data.push(1,1,1,-1,1,1,-1,-1,1,1,-1,1)
tex.push(0,0,1,0,1,4,0,4)
data.push(-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1)
tex.push(0,0,1,0,1,4,0,4)
win.panoramaVerts = data*/
// These buffers are only used for drawing the main menu blocks
sideEdgeBuffers = {}
for (let side in shapes.cube.verts) {
let edgeBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW)
sideEdgeBuffers[side] = edgeBuffer
}
texCoordsBuffers = []
for (let t in textureCoords) {
let buff = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buff)
gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW)
texCoordsBuffers.push(buff)
}
//Bind the Vertex Array Object (VAO) that will be used to draw everything
indexBuffer = gl.createBuffer()
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)
//Tell it not to render the insides of blocks
gl.enable(gl.CULL_FACE)
gl.cullFace(gl.BACK)
gl.lineWidth(2)
blockOutlines = false
gl.enable(gl.POLYGON_OFFSET_FILL)
gl.polygonOffset(1, 1)
gl.clearColor(sky[0], sky[1], sky[2], 1.0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
}
function initBackgrounds() {
// Home screen background
const HALF_PI = Math.PI / 2
const blocks = [
7, 4, 1, 7,
7, 4, 2, 7,
7, 4, 3, 7,
7, 4, 4, 7,
7, 5, 1, 7,
7, 5, 2, 7,
7, 5, 3, 7,
6, 4, 0, 7,
6, 4, 1, 7,
6, 4, 2, 7,
6, 4, 3, 7,
6, 4, 4, 7,
6, 5, 0, 7,
6, 5, 1, 7,
6, 5, 2, 7,
6, 5, 3, 7,
6, 5, 4, 7,
6, 6, 3, 7,
6, 6, 4, 7,
6, 7, 3, 7,
5, 0, -1, 1,
5, 0, 0, 1,
5, 0, 1, 1,
5, 0, 2, 1,
5, 1, 2, 29,
5, 2, 2, 29,
5, 3, 2, 29,
5, 4, 2, 29,
5, 5, 2, 29,
5, 6, 2, 29,
5, 4, 0, 7,
5, 4, 1, 7,
5, 4, 3, 7,
5, 4, 4, 7,
5, 5, 0, 7,
5, 5, 1, 7,
5, 5, 3, 7,
5, 5, 4, 7,
5, 6, 1, 7,
5, 6, 3, 7,
5, 7, 1, 7,
5, 7, 2, 7,
5, 7, 3, 7,
4, -1, -1, 1,
4, -1, 0, 1,
4, -1, 1, 1,
4, -1, 2, 1,
4, 0, 3, 1,
4, 0, 4, 1,
4, 0, 5, 1,
4, 0, 6, 1,
4, 0, 7, 5,
4, 0, 8, 5,
4, 0, 9, 5,
4, 0, 10, 5,
4, 4, 0, 7,
4, 4, 1, 7,
4, 4, 2, 7,
4, 4, 3, 7,
4, 4, 4, 7,
4, 5, 0, 7,
4, 5, 1, 7,
4, 5, 2, 7,
4, 5, 3, 7,
4, 5, 4, 7,
4, 6, 1, 7,
4, 6, 2, 7,
4, 6, 3, 7,
4, 7, 4, 7,
3, -1, -1, 1,
3, -1, 0, 1,
3, -1, 1, 1,
3, -1, 2, 1,
3, -1, 3, 1,
3, -1, 4, 1,
3, 0, 5, 1,
3, 0, 6, 1,
3, 0, 7, 1,
3, 0, 8, 5,
3, 0, 9, 5,
3, 0, 10, 5,
3, 4, 1, 7,
3, 4, 2, 7,
3, 4, 3, 7,
3, 4, 4, 7,
3, 5, 1, 7,
3, 5, 2, 7,
3, 5, 3, 7,
2, -1, -1, 1,
2, -1, 0, 1,
2, -1, 1, 1,
2, -1, 2, 1,
2, -1, 3, 1,
2, -1, 4, 1,
2, -1, 5, 1,
2, -1, 6, 1,
2, -1, 7, 1,
2, 0, 8, 5,
2, 0, 9, 5,
2, 0, 10, 5,
1, -2, -1, 1,
1, -2, 0, 1,
1, -2, 1, 1,
1, -2, 2, 1,
1, -2, 3, 1,
1, -1, 4, 1,
1, -1, 5, 1,
1, -1, 6, 1,
1, -1, 7, 1,
1, -1, 8, 1,
1, -1, 9, 5,
1, -1, 10, 5,
0, -2, -1, 1,
0, -2, 0, 1,
0, -2, 1, 1,
0, -2, 2, 1,
0, -2, 3, 1,
0, -2, 4, 1,
0, -2, 5, 1,
0, -1, 6, 1,
0, -1, 7, 1,
0, -1, 8, 1,
0, -1, 9, 5,
0, -1, 10, 5,
-1, -2, -1, 1,
-1, -2, 0, 1,
-1, -2, 1, 1,
-1, -2, 2, 1,
-1, -2, 3, 1,
-1, -2, 4, 1,
-1, -2, 5, 1,
-1, -2, 6, 1,
-1, -2, 7, 1,
-1, -1, 8, 1,
-1, -1, 9, 1,
-1, -1, 10, 1,
-2, -2, -1, 1,
-2, -2, 0, 1,
-2, -2, 1, 1,
-2, -2, 2, 1,
-2, -2, 3, 1,
-2, -2, 4, 1,
-2, -2, 5, 1,
-2, -2, 6, 1,
-2, -2, 7, 1,
-2, -2, 8, 1,
-2, -2, 9, 1,
-2, -1, 10, 1,
-3, -2, -1, 1,
-3, -2, 0, 1,
-3, -2, 1, 1,
-3, -2, 2, 1,
-3, -2, 3, 1,
-3, -2, 4, 1,
-3, -2, 5, 1,
-3, -2, 6, 1,
-3, -2, 7, 1,
-3, -2, 8, 1,
-3, -2, 9, 1,
-3, -2, 10, 1,
-3, -2, 11, 1,
-3, -2, 12, 1,
-4, -2, -1, 1,
-4, -2, 0, 1,
-4, -2, 1, 1,
-4, -2, 2, 1,
-4, -2, 3, 1,
-4, -2, 4, 1,
-4, -2, 5, 1,
-4, -2, 6, 1,
-4, -2, 7, 1,
-4, -2, 8, 1,
-4, -2, 9, 1,
-4, -2, 10, 1,
-4, -2, 11, 1,
-4, -2, 12, 1,
-5, -2, -1, 1,
-5, -2, 0, 1,
-5, -2, 1, 1,
-5, -2, 2, 1,
-5, -2, 3, 1,
-5, -2, 4, 1,
-5, -2, 5, 1,
-5, -2, 6, 1,
-5, -2, 7, 1,
-5, -2, 8, 1,
-5, -2, 9, 1,
-5, -2, 10, 1,
-5, -2, 11, 1,
-5, -2, 12, 1,
-6, -2, -1, 1,
-6, -2, 0, 1,
-6, -2, 1, 1,
-6, -2, 2, 1,
-6, -2, 3, 1,
-6, -2, 4, 1,
-6, -2, 5, 1,
-6, -2, 6, 1,
-6, -2, 7, 1,
-6, -2, 8, 1,
-6, -2, 9, 1,
-6, -2, 10, 1,
-6, -2, 11, 1,
-7, -2, 3, 1,
-7, -2, 4, 1,
-7, -2, 5, 1,
-7, -2, 6, 1,
-7, -2, 7, 1,
-7, -2, 8, 1,
-7, -2, 9, 1,
-8, -2, 2, 1,
-8, -2, 3, 1,
-8, -2, 4, 1,
-8, -2, 5, 1,
-8, -2, 6, 1,
-8, -2, 7, 1,
-8, -2, 8, 1,
-8, -1, 8, 33,//birch tree
-8, 0, 8, 33,
-9, 1, 10, 7,
-8, 1, 10, 7,
-7, 1, 10, 7,
-10, 1, 9, 7,
-9, 1, 9, 7,
-8, 1, 9, 7,
-7, 1, 9, 7,
-6, 1, 9, 7,
-10, 1, 8, 7,
-9, 1, 8, 7,
-8, 1, 8, 7,
-7, 1, 8, 7,
-6, 1, 8, 7,
-10, 1, 7, 7,
-9, 1, 7, 7,
-8, 1, 7, 7,
-7, 1, 7, 7,
-6, 1, 7, 7,
-9, 1, 6, 7,
-8, 1, 6, 7,
-7, 1, 6, 7,
-9, 2, 10, 7,
-8, 2, 10, 7,
-7, 2, 10, 7,
-10, 2, 9, 7,
-9, 2, 9, 7,
-8, 2, 9, 7,
-7, 2, 9, 7,
-6, 2, 9, 7,
-10, 2, 8, 7,
-9, 2, 8, 7,
-8, 2, 8, 7,
-7, 2, 8, 7,
-6, 2, 8, 7,
-10, 2, 7, 7,
-9, 2, 7, 7,
-8, 2, 7, 7,
-7, 2, 7, 7,
-6, 2, 7, 7,
-9, 2, 6, 7,
-8, 2, 6, 7,
-7, 2, 6, 7,
-7, 3, 8, 7,//topper leaves
-9, 3, 8, 7,
-8, 3, 7, 7,
-8, 3, 9, 7,
-7, 4, 8, 7,
-9, 4, 8, 7,
-8, 4, 7, 7,
-8, 4, 9, 7,
3, 1, 8, 141,//cactus
3, 2, 8, 141,
];
/*var mainBG = document.createElement("canvas");
mainBG.width = gl.canvas.width;
mainBG.height = gl.canvas.height;*/
var mainBGRot = 0//-HALF_PI / 3;
win.mainBGW = 0
win.renderMainBG = function(){
//*
//mainBGRot += 0.05
mainBGRot += 0.002;
if(mainBGRot > Math.PId){
mainBGRot = 0;
}/*/
mainBGRot += 0.001;
if(mainBGRot > 1){
mainBGRot = 0;
}//*/
gl.clearColor(sky[0], sky[1], sky[2], 1.0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
//remove or add the slash to toggle comment
//can be: //* or /*
/*
gl.useProgram(program3D)
FOV(100)
initModelView(null, 1, 1.5, 5, -HALF_PI / 25, mainBGRot)//-HALF_PI / 3
gl.disableVertexAttribArray(glCache.aShadow)
gl.disableVertexAttribArray(glCache.aSkylight)
gl.disableVertexAttribArray(glCache.aBlocklight)
gl.vertexAttrib1f(glCache.aShadow, 1.0)
gl.vertexAttrib1f(glCache.aSkylight, 1.0)
gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
gl.uniform3f(glCache.skyColor, sky[0], sky[1], sky[2])
for (let i = 0; i < blocks.length; i += 4) {
block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
}
gl.enableVertexAttribArray(glCache.aShadow)
gl.enableVertexAttribArray(glCache.aSkylight)
gl.enableVertexAttribArray(glCache.aBlocklight)/*/
gl.useProgram(program3D)
//FOV(90)
initModelView(null, 0, 0, 0, 0, mainBGRot, 1,1)
gl.disableVertexAttribArray(glCache.aShadow)
gl.disableVertexAttribArray(glCache.aSkylight)
gl.disableVertexAttribArray(glCache.aBlocklight)
gl.vertexAttrib1f(glCache.aShadow, 1.0)
gl.vertexAttrib1f(glCache.aSkylight, 1.0)
gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
gl.uniform1i(glCache.uSampler, 4)
gl.bindTexture(gl.TEXTURE_2D, panoramaTexture)
vertexAttribPointer("aVertex", program3D, "aVertex", 3, panoramaVertBuffer)
vertexAttribPointer("aTexture", program3D, "aTexture", 2, panoramaTexBuffer)
gl.disable(gl.CULL_FACE)
gl.drawElements(gl.TRIANGLES, panoramaSize*6, gl.UNSIGNED_INT, 0)
gl.uniform1i(glCache.uTrans, 1)
gl.drawElements(gl.TRIANGLES, panoramaSize*6, gl.UNSIGNED_INT, 0)
gl.uniform1i(glCache.uTrans, 0)
gl.enable(gl.CULL_FACE)
gl.enableVertexAttribArray(glCache.aShadow)
gl.enableVertexAttribArray(glCache.aSkylight)
gl.enableVertexAttribArray(glCache.aBlocklight)
gl.uniform1i(glCache.uSampler, 0)
gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
//*/
}
// Dirt background
use2d()
let aspect = width / height
let stack = height / 96
let bright = 0.4
if (dirtBuffer) {
gl.deleteBuffer(dirtBuffer)
}
dirtBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
let bgCoords = new Float32Array([
-1, -1, 0, stack, bright,
1, -1, stack * aspect, stack, bright,
1, 1, stack * aspect, 0, bright,
-1, 1, 0, 0, bright
])
gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
gl.uniform1i(glCache.uSampler2, 1)
gl.clearColor(0, 0, 0, 1)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
let pixels = new Uint8Array(width * height * 4)
gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
dirtbg = ctx.createImageData(width, height)
dirtbg.data.set(pixels)
// Netherrack background
bright = 0.4
if (netherBuffer) {
gl.deleteBuffer(netherBuffer)
}
netherBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, netherBuffer)
bgCoords = new Float32Array([
-1, -1, 0, stack, bright,
1, -1, stack * aspect, stack, bright,
1, 1, stack * aspect, 0, bright,
-1, 1, 0, 0, bright
])
gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
gl.uniform1i(glCache.uSampler2, 2) //netherrack textures uses TEXTURE2 so the number is 2
gl.clearColor(0, 0, 0, 1)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
pixels = new Uint8Array(width * height * 4)
gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
netherbg = ctx.createImageData(width, height)
netherbg.data.set(pixels)
}
function initPlayer() {
p = new Camera()
p.defaultSpeed = 0.11
p.speed = 0.075
p.velocity = new PVector(0, 0, 0)
p.pos = new Float32Array(3)
p.sprintSpeed = 1.5
p.sneakSpeed = 0.05
p.flySpeed = 3.75
p.x = 8
p.y = 0
p.z = 8
p.previousX = 8
p.previousY = 1
p.previousZ = 8
p.w = 3 / 8
p.bottomH = 1.62
p.topH = 0.18
p.onGround = false
p.jumpSpeed = 0.45
p.sprinting = false
p.maxYVelocity = 1.5
p.gravityStength = -0.091
p.liquidGravityStength = -0.025
p.defaultGravityStength = -0.091
p.lastUpdate = performance.now()
p.lastBreak = Date.now()
p.lastPlace = Date.now()
p.lastJump = Date.now()
p.autoBreak = false
p.autoBuild = false
p.flying = false
p.sneaking = false
p.spectator = false
p.health = 20
p.oxygen = 20
p.food = 20
p.foodSaturation = 5
p.foodTimer = 0
p.foodExhaustion = 0
p.foodJitter = 0
p.eatStart = 0
p.eating = false
p.lastY = 0 //y the last time it touched the ground
p.character = new Character(1)
p.thirdPerson = false
p.spyglassTimer = 0
p.spyglassStart = 0
p.prevUsingSpyglass = false
p.usingSpyglass = false
p.lastXP = 0
p.XP = 0
p.level = 0
p.nextLevel = 0
p.totalXP = 0
setLevel()
p.burning = false
p.burnTime = 0
p.burnStart = 0
p.touchingBurnBlock
p.walking = false
p.punchEffect = 0
p.temperature = 10 // 0 to 20
p.lastTemperature = 10
p.creativeMenu = 0
win.player = p
win.p2 = p2
}
function respawn(){
let spawn = world.spawnPoint
p.x = spawn.x
p.z = spawn.z
/*p.y = 0
while(world.getBlock(0, p.y, 0)){
p.y ++;
if(p.y > maxHeight) break;
}*/
p.y = spawn.y
p.velocity.x = p.velocity.y = p.velocity.z = 0
p.health = 20
p.oxygen = 20
witherEffect = 0
harmEffect = 0
healEffect = 0
p.foodSaturation = 5
p.foodTimer = 0
p.foodExhaustion = 0
p.food = 20
p.lastXP = 0
p.XP = 0
p.level = 0
p.totalXP = 0
setLevel()
freezeEffect = 0
p.burnTime = 0
dieMessage = username+" died because ¯\\_(?)_/¯"
world = dimensions.overworld
}
function initWorldsMenu() {
while (window.worlds.firstChild) {
window.worlds.removeChild(window.worlds.firstChild)
}
selectedWorld = 0
window.boxCenterTop.value = ""
const deselect = () => {
let elem = document.getElementsByClassName("selected")
if (elem && elem[0]) {
elem[0].classList.remove("selected")
}
}
function addWorld(name, version, size, id, edited, thumbnail) {
let div = doc.createElement("div")
div.className = "world"
div.onclick = e => {
deselect()
div.classList.add("selected")
selectedWorld = id
}
let br = "<br>"
div.id = id
div.innerHTML = "<img class='thumbnail'"+(thumbnail ? (" src='" + thumbnail + "'") : "")+"><div class='thumbnailHover'></div>"
div.innerHTML += "<strong>" + Messages.format(name) + "</strong>" + br
if (edited){
let str = (new Date(edited).toLocaleDateString(undefined, {
year: "numeric",
month: "short",
day: "numeric",
hour: "numeric",
minute: "2-digit"
}))
div.innerHTML += str + br
}
div.innerHTML += version + br
div.innerHTML += `${size.toLocaleString()} bytes used`
window.worlds.appendChild(div)
}
worlds = {}
if (loadString) {
try {
let tempWorld = new World()
tempWorld.loadSave(loadString)
let now = Date.now()
addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
worlds[now] = {
code: loadString,
id: now
}
}
catch(e) {
console.log("Unable to load hardcoded save.")
console.error(e)
}
}
loadFromDB().then(res => {
if(res && res.length) {
let index = res.findIndex(obj => obj.id === "settings")
if (index >= 0) {
Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
p.FOV(settings.fov)
loadControls()
selectVoiceFromList(settings.narratorVoice)
res.splice(index, 1)
}
}
if (res && res.length) {
res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
for (let data of res) {
addWorld(data.name, data.version, (data.code.length + 60), data.id, data.edited, data.thumbnail)
worlds[data.id] = data
}
}
window.worlds.onclick = Button.draw
window.boxCenterTop.onkeyup = Button.draw
}).catch(e => console.error(e))
superflat = false
trees = true
caves = true
survival = false
}
var servers = {}
async function initServersMenu() {
while (window.servers.firstChild) {
window.servers.removeChild(window.servers.firstChild)
}
selectedWorld = null
const deselect = () => {
let elem = document.getElementsByClassName("selected")
if (elem && elem[0]) {
elem[0].classList.remove("selected")
}
}
function addWorld(name, id, host, players) {
let div = doc.createElement("div")
div.className = "world"
div.onclick = e => {
deselect()
div.classList.add("selected")
selectedWorld = id
}
let br = "<br>"
div.id = id
div.innerHTML = "<div class='ping'>Pinging...</div>"
div.innerHTML += "<strong>" + Messages.format(name)+ "</strong>" + br
div.innerHTML += "World Owner: "+host + br
div.innerHTML += players.length+" player"+(players.length===1 ? "" : "s")+" online"
servers[id] = {
id:id,
name:name,
host:host
}
window.servers.appendChild(div)
}
var worlds;
await getWorlds(pings => {
if(screen !== "multiplayer menu") return
var elems = window.servers.querySelectorAll(".world")
for(var i=0; i<elems.length; i++){
var el = elems[i]
var p = el.querySelector(".ping")
var ping = pings[el.id]
if(typeof ping === "number"){
var y
if(ping > 800) y = -56
else if(ping > 600) y = -42
else if(ping > 400) y = -28
else if(ping > 200) y = -14
else y = 0
p.innerHTML = ping+" miliseconds <div class='img' style='background-position:0 "+y+"px;'></div>"
}else if(ping === "timeout"){
p.innerHTML = "Ping timed out"
}else{
p.innerHTML = "Error"
}
}
}).then(r => worlds=r)
if(worlds === "notLoggedIn") return changeScene("main menu")
if(worlds === "offline") return window.servers.innerHTML = "<div class='message'>You are offline. Connect to the internet first.</div>"
worlds.forEach(r => addWorld(r.name, r.id, r.host, r.players))
var pingStart = Date.now()
function addPingMsg(msg){
var div = document.createElement("div")
div.classList.add("message")
div.innerHTML = msg
window.servers.prepend(div)
}
fetch("https://server.thingmaker.repl.co/test").then(r => r.text()).then(r => {
if(r !== "test"){
console.log(r)
throw "The server didn't respond correctly."
}
var ping = Date.now() - pingStart
var y
if(ping > 800) y = -56
else if(ping > 600) y = -42
else if(ping > 400) y = -28
else if(ping > 200) y = -14
else y = 0
addPingMsg("Your ping: "+ping+" miliseconds <div class='pingImg' style='background-position:0 "+y+"px;'></div>")
}).catch(e => {
addPingMsg("Something went wrong when pinging: "+e)
console.log(e)
})
window.servers.onclick = Button.draw
superflat = false
trees = true
caves = true
survival = false
}
let marketplace = {}; win.marketplaceData = null
async function initMarketplace(){
marketplaceData = await fetch("maps.json").then(r => r.json())
await fetch("https://minekhan.repl.co/server/maps").then(r => r.json()).then(data => {
for(var m in data){
var v = data[m]
v.fetchUrl = "https://minekhan.repl.co/server/map/"+v.name
marketplaceData.push(v)
}
})
marketplace = {}
window.marketplace.innerHTML = ""
const deselect = () => {
let elem = document.getElementsByClassName("selected")
if (elem && elem[0]) {
elem[0].classList.remove("selected")
}
}
function addWorld(name, version, size, id, by, edited) {
let div = doc.createElement("div")
div.className = "world"
div.onclick = e => {
deselect()
div.classList.add("selected")
selectedWorld = id
}
let br = "<br>"
div.id = id
div.innerHTML = "<strong>" + Messages.format(name) + "</strong>" + br
if (edited){
let str = (new Date(edited).toLocaleDateString(undefined, {
year: "numeric",
month: "short",
day: "numeric",
hour: "numeric",
minute: "2-digit"
}))
div.innerHTML += str + br
}
if(version) div.innerHTML += version + br
div.innerHTML += `${size.toLocaleString()} bytes used`
if(by) div.innerHTML += br+"By: "+by
window.marketplace.appendChild(div)
superflat = false
trees = true
caves = true
survival = false
}
var prevSeed = worldSeed //this should fix seed always the same
let tempWorld = new World()
marketplaceData.forEach((data,i) => {
let id = i
if(data.fetchUrl){
addWorld(data.name, "", data.bytes, id, data.user, data.created)
marketplace[id] = data
}else{
let loadString, mod
if(typeof data === "object"){
loadString = data.loadString
mod = data.mod
}else loadString = data
tempWorld.loadSave(loadString)
addWorld(tempWorld.name, tempWorld.version, loadString.length, id)
marketplace[id] = {
code: loadString,
id: id,
name: tempWorld.name,
version: tempWorld.version,
mod: mod,
}
}
})
setSeed(prevSeed)
window.marketplace.onclick = Button.draw
}
function saveFromMarketplace(){
let save = marketplace[selectedWorld]
if(save.fetchUrl){
changeScene("savingFromMarketplace")
fetch(save.fetchUrl).then(r => r.json()).then(data => {
try{
var loadString
if(data.file){
data.file = JSON.parse(data.file)
loadString = data.file.code
}else{
loadString = data.code
}
var id = Date.now()
if(data.file){
data.file.id = id
data.file.edited = Date.now()
if(data.file.name !== data.name) data.file.name = data.name+" ("+data.file.name+")"
saveToDB(id, data.file)
}else{
var tempWorld = new World()
tempWorld.loadSave(loadString)
saveToDB(id, {
id: id,
edited: Date.now(),
name: tempWorld.name === data.name ? data.name : data.name+" ("+tempWorld.name+")",
version: tempWorld.version,
code: data.code,
mod: (data.file && data.file.mod) || null
})
}
initWorldsMenu()
changeScene("loadsave menu")
}catch(e){
console.error(e)
alert("Error saving map: "+e)
changeScene("marketplace")
}
}).catch(e => {
alert("Error fetching map: "+e)
changeScene("marketplace")
})
}else{
save.id = Date.now()
saveToDB(save.id, {
id: save.id,
edited: Date.now(),
name: save.name,
version: save.version,
code: save.code,
mod: save.mod
})
initWorldsMenu()
changeScene("loadsave menu")
}
}
var sounds = {
click: "click.ogg",
damage: {
bigfall: "damage/fallbig.ogg",
smallfall: "damage/fallsmall.ogg",
hit1: "damage/hit1.ogg",
hit2: "damage/hit2.ogg",
hit3: "damage/hit3.ogg",
drown1: "damage/drown1.ogg",
drown2: "damage/drown2.ogg",
drown3: "damage/drown3.ogg",
drown4: "damage/drown4.ogg",
freeze1: "damage/freeze1.ogg",
freeze2: "damage/freeze2.ogg",
freeze3: "damage/freeze3.ogg",
freeze4: "damage/freeze4.ogg",
freeze5: "damage/freeze5.ogg",
classic_hurt: "damage/classic_hurt.ogg",
},
block: {
grass: {
dig1: "grass/dig1.ogg",
dig2: "grass/dig2.ogg",
dig3: "grass/dig3.ogg",
dig4: "grass/dig4.ogg",
step1: "grass/step1.ogg",
step2: "grass/step2.ogg",
step3: "grass/step3.ogg",
step4: "grass/step4.ogg",
step5: "grass/step5.ogg",
step6: "grass/step6.ogg",
},
stone: {
dig1: "stone/dig1.ogg",
dig2: "stone/dig2.ogg",
dig3: "stone/dig3.ogg",
dig4: "stone/dig4.ogg",
step1: "stone/step1.ogg",
step2: "stone/step2.ogg",
step3: "stone/step3.ogg",
step4: "stone/step4.ogg",
step5: "stone/step5.ogg",
step6: "stone/step6.ogg",
},
gravel: {
dig1: "gravel/dig1.ogg",
dig2: "gravel/dig2.ogg",
dig3: "gravel/dig3.ogg",
dig4: "gravel/dig4.ogg",
step1: "gravel/step1.ogg",
step2: "gravel/step2.ogg",
step3: "gravel/step3.ogg",
step4: "gravel/step4.ogg",
},
sand: {
dig1: "sand/dig1.ogg",
dig2: "sand/dig2.ogg",
dig3: "sand/dig3.ogg",
dig4: "sand/dig4.ogg",
step1: "sand/step1.ogg",
step2: "sand/step2.ogg",
step3: "sand/step3.ogg",
step4: "sand/step4.ogg",
step5: "sand/step5.ogg",
},
basalt: {
dig1: "basalt/dig1.ogg",
dig2: "basalt/dig2.ogg",
dig3: "basalt/dig3.ogg",
dig4: "basalt/dig4.ogg",
dig5: "basalt/dig5.ogg",
step1: "basalt/step1.ogg",
step2: "basalt/step2.ogg",
step3: "basalt/step3.ogg",
step4: "basalt/step4.ogg",
step5: "basalt/step5.ogg",
step6: "basalt/step6.ogg",
},
chain: {
dig1: "chain/dig1.ogg",
dig2: "chain/dig2.ogg",
dig3: "chain/dig3.ogg",
dig4: "chain/dig4.ogg",
step1: "chain/step1.ogg",
step2: "chain/step2.ogg",
step3: "chain/step3.ogg",
step4: "chain/step4.ogg",
step5: "chain/step5.ogg",
step6: "chain/step6.ogg",
},
cloth: {
dig1: "cloth/dig1.ogg",
dig2: "cloth/dig2.ogg",
dig3: "cloth/dig3.ogg",
dig4: "cloth/dig4.ogg",
step1: "cloth/step1.ogg",
step2: "cloth/step2.ogg",
step3: "cloth/step3.ogg",
step4: "cloth/step4.ogg",
},
fungus: {
dig1: "fungus/dig1.ogg",
dig2: "fungus/dig2.ogg",
dig3: "fungus/dig3.ogg",
dig4: "fungus/dig4.ogg",
dig5: "fungus/dig3.ogg",
dig6: "fungus/dig4.ogg",
},
glass: {
dig1: "glass/dig1.ogg",
dig2: "glass/dig2.ogg",
dig3: "glass/dig3.ogg",
},
lantern: {
dig1: "lantern/dig1.ogg",
dig2: "lantern/dig2.ogg",
dig3: "lantern/dig3.ogg",
dig4: "lantern/dig4.ogg",
dig5: "lantern/dig5.ogg",
dig6: "lantern/dig6.ogg",
place1: "lantern/place1.ogg",
place2: "lantern/place2.ogg",
place3: "lantern/place3.ogg",
place4: "lantern/place4.ogg",
place5: "lantern/place5.ogg",
place6: "lantern/place6.ogg",
},
nether_bricks: {
dig1: "nether_bricks/dig1.ogg",
dig2: "nether_bricks/dig2.ogg",
dig3: "nether_bricks/dig3.ogg",
dig4: "nether_bricks/dig4.ogg",
dig5: "nether_bricks/dig5.ogg",
dig6: "nether_bricks/dig6.ogg",
step1: "nether_bricks/step1.ogg",
step2: "nether_bricks/step2.ogg",
step3: "nether_bricks/step3.ogg",
step4: "nether_bricks/step4.ogg",
step5: "nether_bricks/step5.ogg",
step6: "nether_bricks/step6.ogg",
},
nether_ore: {
dig1: "nether_ore/dig1.ogg",
dig2: "nether_ore/dig2.ogg",
dig3: "nether_ore/dig3.ogg",
dig4: "nether_ore/dig4.ogg",
step1: "nether_ore/step1.ogg",
step2: "nether_ore/step2.ogg",
step3: "nether_ore/step3.ogg",
step4: "nether_ore/step4.ogg",
step5: "nether_ore/step5.ogg",
},
nether_sprouts: {
dig1: "nether_sprouts/dig1.ogg",
dig2: "nether_sprouts/dig2.ogg",
dig3: "nether_sprouts/dig3.ogg",
dig4: "nether_sprouts/dig4.ogg",
step1: "nether_sprouts/step1.ogg",
step2: "nether_sprouts/step2.ogg",
step3: "nether_sprouts/step3.ogg",
step4: "nether_sprouts/step4.ogg",
step5: "nether_sprouts/step5.ogg",
},
netherite: {
dig1: "netherite/dig1.ogg",
dig2: "netherite/dig2.ogg",
dig3: "netherite/dig3.ogg",
dig4: "netherite/dig4.ogg",
step1: "netherite/step1.ogg",
step2: "netherite/step2.ogg",
step3: "netherite/step3.ogg",
step4: "netherite/step4.ogg",
step5: "netherite/step5.ogg",
step6: "netherite/step6.ogg",
},
netherrack: {
dig1: "netherrack/dig1.ogg",
dig2: "netherrack/dig2.ogg",
dig3: "netherrack/dig3.ogg",
dig4: "netherrack/dig4.ogg",
dig5: "netherrack/dig5.ogg",
dig6: "netherrack/dig6.ogg",
step1: "netherrack/step1.ogg",
step2: "netherrack/step2.ogg",
step3: "netherrack/step3.ogg",
step4: "netherrack/step4.ogg",
step5: "netherrack/step5.ogg",
step6: "netherrack/step6.ogg",
},
netherwart: {
dig1: "netherwart/dig1.ogg",
dig2: "netherwart/dig2.ogg",
dig3: "netherwart/dig3.ogg",
dig4: "netherwart/dig4.ogg",
dig5: "netherwart/dig5.ogg",
dig6: "netherwart/dig6.ogg",
step1: "netherwart/step1.ogg",
step2: "netherwart/step2.ogg",
step3: "netherwart/step3.ogg",
step4: "netherwart/step4.ogg",
step5: "netherwart/step5.ogg",
},
nylium: {
dig1: "nylium/dig1.ogg",
dig2: "nylium/dig2.ogg",
dig3: "nylium/dig3.ogg",
dig4: "nylium/dig4.ogg",
dig5: "nylium/dig5.ogg",
dig6: "nylium/dig6.ogg",
step1: "nylium/step1.ogg",
step2: "nylium/step2.ogg",
step3: "nylium/step3.ogg",
step4: "nylium/step4.ogg",
step5: "nylium/step5.ogg",
step6: "nylium/step6.ogg",
},
roots: {
dig1: "roots/dig1.ogg",
dig2: "roots/dig2.ogg",
dig3: "roots/dig3.ogg",
dig4: "roots/dig4.ogg",
dig5: "roots/dig5.ogg",
dig6: "roots/dig6.ogg",
step1: "roots/step1.ogg",
step2: "roots/step2.ogg",
step3: "roots/step3.ogg",
step4: "roots/step4.ogg",
step5: "roots/step5.ogg",
},
shroomlight: {
dig1: "shroomlight/dig1.ogg",
dig2: "shroomlight/dig2.ogg",
dig3: "shroomlight/dig3.ogg",
dig4: "shroomlight/dig4.ogg",
dig5: "shroomlight/dig5.ogg",
step1: "shroomlight/step1.ogg",
step2: "shroomlight/step2.ogg",
step3: "shroomlight/step3.ogg",
step4: "shroomlight/step4.ogg",
step5: "shroomlight/step5.ogg",
step6: "shroomlight/step6.ogg",
},
soul_sand: {
dig1: "soul_sand/dig1.ogg",
dig2: "soul_sand/dig2.ogg",
dig3: "soul_sand/dig3.ogg",
dig4: "soul_sand/dig4.ogg",
dig5: "soul_sand/dig5.ogg",
dig6: "soul_sand/dig6.ogg",
dig7: "soul_sand/dig7.ogg",
dig8: "soul_sand/dig8.ogg",
dig9: "soul_sand/dig9.ogg",
step1: "soul_sand/step1.ogg",
step2: "soul_sand/step2.ogg",
step3: "soul_sand/step3.ogg",
step4: "soul_sand/step4.ogg",
step5: "soul_sand/step5.ogg",
},
stem: {
dig1: "stem/dig1.ogg",
dig2: "stem/dig2.ogg",
dig3: "stem/dig3.ogg",
dig4: "stem/dig4.ogg",
dig5: "stem/dig5.ogg",
dig6: "stem/dig6.ogg",
step1: "stem/step1.ogg",
step2: "stem/step2.ogg",
step3: "stem/step3.ogg",
step4: "stem/step4.ogg",
step5: "stem/step5.ogg",
step6: "stem/step6.ogg",
},
wood: {
dig1: "wood/dig1.ogg",
dig2: "wood/dig2.ogg",
dig3: "wood/dig3.ogg",
dig4: "wood/dig4.ogg",
step1: "wood/step1.ogg",
step2: "wood/step2.ogg",
step3: "wood/step3.ogg",
step4: "wood/step4.ogg",
step5: "wood/step5.ogg",
step6: "wood/step6.ogg",
},
anvil: {
land: "random/anvil_land.ogg"
},
amethyst: {
dig1: "amethyst/break1.ogg",
dig2: "amethyst/break2.ogg",
dig3: "amethyst/break3.ogg",
dig4: "amethyst/break4.ogg",
place1: "amethyst/place1.ogg",
place2: "amethyst/place2.ogg",
place3: "amethyst/place3.ogg",
place4: "amethyst/place4.ogg",
step1: "amethyst/step1.ogg",
step2: "amethyst/step2.ogg",
step3: "amethyst/step3.ogg",
step4: "amethyst/step4.ogg",
step5: "amethyst/step5.ogg",
step6: "amethyst/step6.ogg",
step7: "amethyst/step7.ogg",
step8: "amethyst/step8.ogg",
step9: "amethyst/step9.ogg",
step10: "amethyst/step10.ogg",
step11: "amethyst/step11.ogg",
step12: "amethyst/step12.ogg",
step13: "amethyst/step13.ogg",
step14: "amethyst/step14.ogg",
},
amethyst_cluster: {
dig1: "amethyst_cluster/break1.ogg",
dig2: "amethyst_cluster/break2.ogg",
dig3: "amethyst_cluster/break3.ogg",
dig4: "amethyst_cluster/break4.ogg",
place1: "amethyst_cluster/place1.ogg",
place2: "amethyst_cluster/place2.ogg",
place3: "amethyst_cluster/place3.ogg",
place4: "amethyst_cluster/place4.ogg",
},
deepslate:{
dig1:"deepslate/break1.ogg",
dig2:"deepslate/break2.ogg",
dig3:"deepslate/break3.ogg",
dig4:"deepslate/break4.ogg",
place1:"deepslate/place1.ogg",
place2:"deepslate/place2.ogg",
place3:"deepslate/place3.ogg",
place4:"deepslate/place4.ogg",
place5:"deepslate/place5.ogg",
place6:"deepslate/place6.ogg",
step1:"deepslate/step1.ogg",
step2:"deepslate/step2.ogg",
step3:"deepslate/step3.ogg",
step4:"deepslate/step4.ogg",
step5:"deepslate/step5.ogg",
step6:"deepslate/step6.ogg",
},
deepslate_bricks:{
place1:"deepslate_bricks/place1.ogg",
place2:"deepslate_bricks/place2.ogg",
place3:"deepslate_bricks/place3.ogg",
place4:"deepslate_bricks/place4.ogg",
place5:"deepslate_bricks/place5.ogg",
place6:"deepslate_bricks/place6.ogg",
step1:"deepslate_bricks/step1.ogg",
step2:"deepslate_bricks/step2.ogg",
step3:"deepslate_bricks/step3.ogg",
step4:"deepslate_bricks/step4.ogg",
step5:"deepslate_bricks/step5.ogg",
},
end_portal:{
eyeplace1:"end_portal/eyeplace1.ogg",
eyeplace2:"end_portal/eyeplace2.ogg",
eyeplace3:"end_portal/eyeplace3.ogg"
},
portal:{
portal:"portal/portal.ogg",
travel:"portal/travel.ogg",
trigger:"portal/trigger.ogg",
},
fire:{
fire:"fire/fire.ogg",
ignite:"fire/ignite.ogg"
},
},
entity: {
generic: {
explode1: "random/explode1.ogg",
explode2: "random/explode2.ogg",
explode3: "random/explode3.ogg",
explode4: "random/explode4.ogg",
},
tnt: {
fuse: "random/fuse.ogg"
},
item: {
pickup: "random/plop.ogg",
break: "random/break.ogg"
},
cow:{
hurt1:"cow/hurt1.ogg",
hurt2:"cow/hurt2.ogg",
hurt3:"cow/hurt3.ogg",
say1:"cow/say1.ogg",
say2:"cow/say2.ogg",
say3:"cow/say3.ogg",
say4:"cow/say4.ogg",
step1:"cow/step1.ogg",
step2:"cow/step2.ogg",
step3:"cow/step3.ogg",
step4:"cow/step4.ogg",
},
witch:{
ambient1:"witch/ambient1.ogg",
ambient2:"witch/ambient2.ogg",
ambient3:"witch/ambient3.ogg",
ambient4:"witch/ambient4.ogg",
ambient5:"witch/ambient5.ogg",
celebrate:"witch/celebrate.ogg",
},
ender_dragon:{
end:"ender_dragon/end.ogg",
},
},
item:{
spyglass:{
use:"spyglass/use.ogg",
stop:"spyglass/stop.ogg"
}
},
experience:{
orb:"random/orb.ogg",
levelup:"random/levelup.ogg"
},
liquid:{
enter: "liquid/enter.ogg",
exit: "liquid/exit.ogg",
splash: "liquid/splash.ogg"
},
eat: {
1: "random/eat1.ogg",
2: "random/eat2.ogg",
3: "random/eat3.ogg",
burp:"random/burp.ogg"
}
}
var soundVolumes = {
}
win.sounds = sounds
var music = {
menu:{
1:"menu/menu1.ogg",
2:"menu/menu2.ogg",
3:"menu/menu3.ogg",
4:"menu/menu4.ogg",
},
game:{
creative:{
1:"game/creative/creative1.ogg",
2:"game/creative/creative2.ogg",
3:"game/creative/creative3.ogg",
4:"game/creative/creative4.ogg",
5:"game/creative/creative5.ogg",
6:"game/creative/creative6.ogg",
}
}
}
win.music = music
function loadSoundBuffer(url){
return new Promise((resolve, reject) => {
var request = new XMLHttpRequest();
request.open('GET', url, true);
request.responseType = 'arraybuffer';
request.onerror = reject
request.onload = function() {
audioCtx.decodeAudioData(request.response, function(buffer) {
resolve(buffer)
}, reject);
}
request.send();
})
}
async function initAudioCtx(){
try{
window.AudioContext = window.AudioContext || window.webkitAudioContext;
audioCtx = new AudioContext();
win.audioCtx = audioCtx
}catch(e) {
alert('Web Audio API is not supported in this browser');
return
}
async function loadSoundsObj(obj){
for(var i in obj){
if(typeof obj[i] === "object"){
loadSoundsObj(obj[i])
}else{
var url
if(obj[i].startsWith("https://")){
url = obj[i]
}else{
url = "https://data.thingmaker.repl.co/sounds/"+obj[i]
}
let loadIt = true
if(loadIt){
await loadSoundBuffer(url).then(buffer => {
obj[i] = buffer
loadDone()
}).catch(() => {
loadDone()
})
}else loadDone()
}
}
}
function loadMusicObj(obj){
for(var i in obj){
if(typeof obj[i] === "object"){
loadMusicObj(obj[i])
}else{
var url = "https://music.minekhan.repl.co/"+obj[i]
var audio = new Audio(url)
audio.crossOrigin = ""
var source = audioCtx.createMediaElementSource(audio)
var gainNode = audioCtx.createGain();
source.connect(gainNode);
gainNode.gain.value = 1
gainNode.connect(audioCtx.destination);
obj[i] = {
audio,
source,
gainNode,
gain: gainNode.gain
}
}
}
}
loadSoundsObj(sounds)
loadMusicObj(music)
}
function playSound(name, start, volume, pitch, onend, loop, getSourceFunc){ //from https://www.html5rocks.com/en/tutorials/webaudio/intro/
if(!settings.volume) return
var sound
var soundVol
if(name.includes(".")){
sound = sounds
soundVol = soundVolumes
name = name.split(".")
for(var i=0; i<name.length; i++){
var n = name[i]
if(sound[n]){
sound = sound[n]
}else return
if(soundVol[n]){soundVol = soundVol[n]}
}
}else{
sound = sounds[name]
soundVol = soundVolumes[name]
if(!sound) return
}
if(!volume && volume !== 0) volume = 1
if((typeof soundVol === "object") || (!soundVol && soundVol !== 0)) soundVol = 1
volume *= soundVol
volume *= settings.volume
var buffer = sound
if(audioCtx && (typeof buffer !== "string") && volume > 0){
var source = audioCtx.createBufferSource();
source.buffer = buffer;
var gainNode
if(((!(volume || volume === 0)) || volume === 1) && !getSourceFunc){
source.connect(audioCtx.destination);
}else{
gainNode = audioCtx.createGain();
source.connect(gainNode);
gainNode.connect(audioCtx.destination);
gainNode.gain.value = volume;
}
if(pitch) {
if(Array.isArray(pitch)){
pitch = rand(pitch[0],pitch[1])
}
source.playbackRate.value = pitch
}
if(onend) source.onended = onend
if(loop) source.loop = true
source.start(start ? audioCtx.currentTime + (start/1000) : 0);
if(getSourceFunc) getSourceFunc(source, gainNode)
return true
}
}
win.playSound = playSound
function blockSound(blockID, type, x,y,z, volume){
var block = blockData[blockID]
if(!(volume || volume === 0)) volume = posSound(x,y,z)
var sound
switch(type){
case "place":
sound = block.placeSound || block.digSound
break;
case "dig":
sound = block.digSound
break;
case "step":
sound = block.stepSound
break;
case "breaking":
sound = block.stepSound
break;
case "land":
sound = block.landSound || block.digSound
}
if(typeof sound === "function") return sound()
if(Array.isArray(sound)){
sound = sound[Math.floor(Math.random()*sound.length)]
}
if(sound){
playSound(sound, 0, volume)
if(multiplayer) send({type:"playSound", data:sound, x:x,y:y,z:z})
}
}
win.blockSound = blockSound
function hitSound(){
var i = Math.ceil(Math.random()*3)
playSound("damage.hit"+i)
if(multiplayer) send({type:"playSound", data:"damage.hit"+i, x:p.x,y:p.y,z:p.z})
}
win.hitSound = hitSound
function drownHurtSound(){
var i = Math.ceil(Math.random()*4)
playSound("damage.drown"+i)
if(multiplayer) send({type:"playSound", data:"damage.drown"+i, x:p.x,y:p.y,z:p.z})
}
function freezeHurtSound(){
var i = Math.ceil(Math.random()*5)
playSound("damage.freeze"+i)
if(multiplayer) send({type:"playSound", data:"damage.freeze"+i, x:p.x,y:p.y,z:p.z})
}
function oofSound(){
playSound("damage.classic_hurt")
if(multiplayer) send({type:"playSound", data:"damage.classic_hurt", x:p.x,y:p.y,z:p.z})
}
var explodeSounds = ["entity.generic.explode1", "entity.generic.explode2", "entity.generic.explode3", "entity.generic.explode4"]
function explodeSound(x,y,z){
var sound = explodeSounds[Math.floor(Math.random()*explodeSounds.length)]
playSound(sound, 0, posSound(x,y,z))
if(multiplayer) send({type:"playSound", data:sound, x:x,y:y,z:z})
}
win.explodeSound = explodeSound
function posSound(x,y,z){
var volume = 1
if((x || x===0) && (y || y===0) && (z || z===0)){
var falloff = volume > 16 ? 16*volume : 16
var dist = dist3(x,y,z, p2.x, p2.y, p2.z)
volume = dist > falloff ? volume - ((dist - falloff) / 10) : volume
if(volume < 0) volume = 0
}
return volume
}
function eatSound(){
var i = Math.ceil(Math.random()*3)
playSound("eat."+i)
if(multiplayer) send({type:"playSound", data:"eat."+i, x:p.x,y:p.y,z:p.z})
}
function playMusic(a, onend = null){
var audio = a.audio
audio.currentTime = 0
audio.onended = function(){
audio.onended = null
if(onend) onend()
}
audio.play().catch(console.warn)
return a
}
win.playMusic = playMusic
win.menuMusicVolume = 1
win.menuMusicIdx = 0
win.currentMusic = null
function updateMusic(){
if(screen === "play" || screen === "pause" || screen === "inventory" || screen === "crafting" || screen === "furnace" || screen === "chest"){
if(menuMusicVolume > 0) menuMusicVolume -= 0.01
if(menuMusicVolume < 0) menuMusicVolume = 0
if(currentMusic && menuMusicVolume === 0){
currentMusic.audio.pause()
console.log("stop menu music")
currentMusic = null
}
}else{
if(menuMusicVolume < 1) menuMusicVolume += 0.01
if(menuMusicVolume > 1) menuMusicVolume = 1
if(!currentMusic){
menuMusicIdx ++
if(!music.menu[menuMusicIdx]) menuMusicIdx = 1
currentMusic = playMusic(music.menu[menuMusicIdx], function(){currentMusic = null})
console.log("play menu music",menuMusicIdx)
}
}
if(currentMusic){
currentMusic.gain.value = menuMusicVolume * settings.volume
}
}
function tryPlayMusic(){
currentMusic.audio.play()
audioCtx.resume()
document.removeEventListener("mousedown", tryPlayMusic)
console.log("%cTry Play Music!", "background:#0a0;color:white;padding:10px 20px;")
}
document.addEventListener("mousedown", tryPlayMusic)
document.body.onmousedown = e => {if(e.target && e.target.tagName.toLowerCase() === "button") playSound("click")}
let maxStartLoad = 0, loaded = 0
win.allLoaded = false
function findObjValueAmount(obj){
for(var i in obj){
if(typeof obj[i] === "object"){
findObjValueAmount(obj[i])
}else maxStartLoad ++
}
}
findObjValueAmount(sounds)
for(var image in images) maxStartLoad ++
maxStartLoad ++ // fetch the account
loadProg.innerHTML = `0% 0/${maxStartLoad}`
function loadDone(){
loaded ++
let prog = loaded * 100 / maxStartLoad
let percent = Math.floor(prog)
loadProg.innerHTML = `${percent}% ${loaded}/${maxStartLoad}`
loadBar.style.width = prog+"%"
if(loaded === maxStartLoad){
allLoaded = true
changeScene("main menu")
}
if(loaded > maxStartLoad){
console.log("loaded > maxStartLoad\nloaded = "+loaded)
}
}
function createNewWorld(){
playersInv = {}
dimensions = {
overworld: new World(),
nether: new World("nether")
}
world = dimensions.overworld
world.id = Date.now()
let name = boxCenterTop.value || "World"
let number = ""
while(true) {
let match = false
for (let id in worlds) {
if (worlds[id].name === name + number) {
match = true
break
}
}
if (match) {
number = number ? number + 1 : 1
} else {
name = name + number
break
}
}
world.name = name.replace(/;/g, "\u037e")
world.loadChunks()
world.chunkGenQueue.sort(sortChunks)
cheats = !survival
p.x = p.z = 8
if(survival) {
setHotbar([0,0,0,0,0,0,0,0,0])
clearInv()
}
changeScene("loading")
}
function playSelectedWorld(){
dimensions = {
overworld: new World(),
nether: new World("nether")
}
world = dimensions.overworld
let code
let inv
let surviv
let mod
let nether
let ent
let tags
if (!selectedWorld && !boxCenterTop.value.startsWith("JSON")) {
code = boxCenterTop.value
} else {
let data = worlds[selectedWorld]
if(boxCenterTop.value.startsWith("JSON")){
data = boxCenterTop.value.replace("JSON","")
try{
data = JSON.parse(data)
}catch(e){
alert(e)
}
}
if (data) {
code = data.code
world.id = data.id
world.edited = data.edited
inv = data.inv
surviv = data.surviv
nether = data.nether
ent = data.ent
tags = data.tags
if(data.achievments) achievments = data.achievments
playersInv = data.playersInv || {}
try{
world.mod = data.mod
mod = Function("return "+data.mod)()
}catch(e){console.log("error loading mod: "+e)}
if(data.settings){
worldSettings = data.settings
}else{
Object.assign(worldSettings, defaultWorldSettings)
}
}
}
if (code) {
try {
world.loadSave(code)
world.id = world.id || Date.now()
}
catch(e) {
alert("Unable to load save. Error: "+e)
return
}
}
if (nether) {
let world = dimensions.nether
try {
world.loadSave(nether)
world.id = world.id || Date.now()
}
catch(e) {
alert("Unable to load save. Error: "+e)
return
}
}
if(inv){
world.loadInv(inv)
}else if(survival) {
setHotbar([0,0,0,0,0,0,0,0,0])
clearInv()
}
if(surviv){world.loadSurvivStr(surviv)}else{cheats = !survival}
if(ent){
for(var i=0; i<ent.length; i++){
let world = getWorld(ent[i].dimension)
world.posEntity(ent[i])
}
}
world.editedTagsToLoad = tags
if(mod){
try{mod()}catch(e){console.log(e)}
}
changeScene("loading")
}
function setupHelp(){
//Setup images
var divs = document.querySelectorAll("div[img]")
for(var i=0; i<divs.length; i++){
var d = divs[i]
d.style.backgroundSize = "100%"
d.style.imageRendering = "pixelated"
d.style.display = "inline-block"
d.style.verticalAlign = "middle"
var img = d.getAttribute("img")
var w, h
if(img === "heart"){
w = h = 18
d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAXElEQVQoU3XQQRKAIAiF4Z97ua8j19572UCSTytWjHwCgzGi9dQAzfEHj/YrwOJXgFqhFGl8pw4GepUXdADbBzqBvXeKnVaYwE0uPkEFuZcOio4+QqY8J5igAi9cnpgXB7uKmTQAAAAASUVORK5CYII=)"
}else if(img === "halfHeart"){
w = h = 18
d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAY0lEQVQoU4WOwQ3AMAgDzS50i/zbkTtAxmCXVLiBoKhS+YDMYSxYNeYoAOoMF7xGVVWVopl5E14R6B1ojctjQgEuqPz9hG4A5w/ETBUMp5opPBJ0KAAmL1/S8XrF3O0Qwf34AVFaJQc+FQukAAAAAElFTkSuQmCC)"
}else if(img === "deadHeart"){
w = h = 18
d.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAT0lEQVQoU62OwQ3AMAwCz1N4//E8RSqjuiVRn/ULocMQvLduGYBr2uhbmSlRVbgGQqkx7esjO/QvtG3yyq6aTeNv2wYQdYwV6MAXpOozfAGB1SIH1uYKrgAAAABJRU5ErkJggg==)"
}
var a = parseInt(d.getAttribute("amount"))
if(a){
d.style.backgroundSize = (100/a)+"% 100%"
d.style.width = (w * a)+"px"
}else d.style.width = w+"px"
d.style.height = h+"px"
}
//Setup collapsibles
var coll = document.getElementsByClassName("collapsible");
for (var i = 0; i < coll.length; i++) {
var c = coll[i]
var title = document.createElement("div")
title.classList.add("title")
title.innerHTML = c.getAttribute("title")
var content = document.createElement("div")
content.classList.add("content")
content.innerHTML = c.innerHTML
c.innerHTML = ""
c.appendChild(title)
c.appendChild(content)
content.style.maxHeight = "0px"
title.addEventListener("click", function() {
var content = this.nextElementSibling
this.classList.toggle("active")
if (content.style.maxHeight !== "0px"){
content.style.maxHeight = "0px";
} else {
content.style.maxHeight = content.scrollHeight + "px";
}
})
}
//Set recipes collapsible
var recipes = document.querySelector("#recipes .content")
var size = inventory.size
var s2 = size/2
var icons = {}
var ix = -s2, iy = s2
function addIcon(id){
ix += size
if(ix > gl.canvas.width - s2){
ix = s2
iy += size
}
drawIcon(ix, iy, id)
icons[id] = [ix,iy]
}
use3d()
FOV(90)
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
var ic = document.createElement("canvas")
ic.width = ic.height = size
var ictx = ic.getContext("2d")
var rhtml = ""
for(var c in crafts){
var r = crafts[c]
if(r.hidden) continue
var arr = c.split(",")
rhtml += "<div class='recipe'>"
rhtml +=  blockData[r.id].Name+"<br><br>"
rhtml += "<div class='grid'>"
//Grid
for(var a=0; a<arr.length; a++){
var id = parseInt(arr[a])
if(id) {
if(!icons[id]){
addIcon(id)
var xy = icons[id]
ictx.clearRect(0,0,size,size)
ictx.drawImage(gl.canvas, xy[0]-s2,xy[1]-s2, size,size, 0,0,size,size)
icons[id] = ic.toDataURL()
}
var img = icons[id]
rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].Name+"'>"
}else{
rhtml += "<div style='width:"+size+"px;height:"+size+"px;'></div>"
}
if(a%3===2 && a !== 8){
rhtml += "<br>"
}
}
rhtml += "</div>"
//Result
var id = r.id
if(!icons[id]){
addIcon(id)
var xy = icons[id]
ictx.clearRect(0,0,size,size)
ictx.drawImage(gl.canvas, xy[0]-s2,xy[1]-s2, size,size, 0,0,size,size)
icons[id] = ic.toDataURL()
}
var img = icons[id]
rhtml += "<br><div class='result' style='margin-left:"+size+"px;margin-top:"+size+"px;'>"
rhtml += "<img src='"+img+"' style='width:"+size+"px;height:"+size+"px;' title='"+blockData[id].Name+"'>"
rhtml += "<div class='number'>"+r.amount+"</div>"
rhtml += "</div><br><br>"
if(r.shapeless){
rhtml += "Shapeless"
}else if(r.shaped){
rhtml += "Shaped"
}else{
rhtml += "Fixed"
}
rhtml += "</div>"
}
recipes.innerHTML = rhtml
}
function initPanorama(){
const shape = shapes.panorama
const shapeVerts = shape.verts
const shapeTexVerts = shape.texVerts
const size = shape.size
var ts = 16
let blockSides = Object.keys(Block)
let texNum = 0
let texture = []
let index = 0
for (let n = 0; n < 6; n++) {
let side = blockSides[n]
let directionalFaces = shapeVerts[Sides[side]]
for (let facei = 0; facei < directionalFaces.length; facei++) {
let texShapeVerts = shapeTexVerts[n][facei]
texture[index    ] = texShapeVerts[0]*ts
texture[index + 1] = texShapeVerts[1]*ts*8
texture[index + 2] = texShapeVerts[2]*ts
texture[index + 3] = texShapeVerts[3]*ts*8
texture[index + 4] = texShapeVerts[4]*ts
texture[index + 5] = texShapeVerts[5]*ts*8
texture[index + 6] = texShapeVerts[6]*ts
texture[index + 7] = texShapeVerts[7]*ts*8
index += 8
}
texNum++
}
panoramaVertBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, panoramaVertBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Float32Array(shapeVerts.flat(Infinity))), gl.STATIC_DRAW)
panoramaTexBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, panoramaTexBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Float32Array(texture)), gl.STATIC_DRAW)
panoramaSize = size
}
function initEverything() {
console.log("Initializing world.")
changeScene("initLoading")
generatedChunks = 0
crack.shape = shapes.cube
initWebgl()
constVersion(version)
initPlayer()
fetch("https://server.thingmaker.repl.co/account",{credentials:'include'}).then(r => r.json()).then(r => {
updateUserTo(r)
loadDone()
}).catch(e => {
console.log(e)
loadDone()
})
setSeed(Math.random() * 2000000000 | 0)
win.islandGenerator = new Generator();
message.innerHTML = ".>a/<etisbew ym>'oc.lper.rekamgniht.www//:sptth'=ferh a< tuo kcehc oslA>rb<>a/<etisbew s'draliW no nahKeniM ot kniL>'nahkenim/nuf.dralliw//:sptth'=ferh a<>rb<.>a<etisbew s'dralliW>'nuf.dralliw//:sptth'=ferh a< tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>\"wen_\"=tegrat \"8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth\"=ferh a< fo>rb<ffo-nips a si margorp sihT".split("").reverse().join("")
crack.entity = new crackEntity("crack1",0,0,0)
for(var i=0; i<crack.length; i++){crack.entity.cacheTexture(crack[i])}
entityFire = new EntityFire()
initBackgrounds()
initParticles()
initPanorama()
drawScreens[screen]()
Button.draw()
Slider.draw()
p.FOV(settings.fov)
initWorldsMenu()
initMarketplace()
initButtons()
initAudioCtx()
updateControls()
setupHelp()
}
function finishedLoading(){
// See if a user followed a link here.
if (urlParams.has("target")) {
changeScene("multiplayer menu")
loggedIn().then(logged => {
if(logged){
initMultiplayer(urlParams.get("target"))
}
})
}
}
// Define all the scene draw functions
let clear,dirt,nether
(function() {
var splashs = [
"Multiplayer!",
"Survival!",
"Flowers? Make a garden!",
//"Also go to my website:\nwww.thingmaker.repl.co",
"Nether!",
"Can't break bedrock.",
"Chat with a slash!",
"Watch out from\nthe falling sand!",
"Hard Parkour!",
"MineKhan is on youtube!",
"Original by Willard.",
"Log => 4 planks\n2 Planks => 4 sticks\n1 stick + 1 coal\n=\ntorch",
"Annoying cactus!",
"Nice looking flowers.",
"I like watermelon.",
"Have you played\nMinecraft?",
"So, you read splash text.",
document.documentElement.outerHTML.split("\n").length+" lines of code.",
"Island world type\nhas a volcano.",
"Have you realized\npunching wood\nhurts your hand?",
"Don't make a tnt\ncube over\nsomeone's mansion.",
"Awesome!",
"Fun!",
"Build!",
"Mine!",
"Craft!",
"Would you like a potion of fun?",
"Falling anvils are\neven more annoying\nthan sand!",
"No tnt!!!",
"Don't mess\naround with\nuranium!!!",
"Why does my\nhouse have a\nhole in the\nroof???",
//"www.thingmaker.repl.co",
"§1C§2o§3l§4o§5r§6m§7a§8t§9i§ac",
"Using WebGL!",
"Who has awesome hair?",
"Supercalifragilisticexpialidocious!",
"Really really fun!",
"Not kidding",
"Punch diamonds!",
"Very long useless text,\nglorbouirewsoytuderkoilsykrojeticfilistikmensuiklit",
"Play for 10 hours!",
"Also try VVVVVV!",
"Also try Super Meat Boy!",
"Also try Terraria!",
"Also try Undertale!",
"Also try Mount And Blade!",
"Also try Project Zomboid!",
"Also try World of Goo!",
"Also try Limbo!",
"Also try Pixeljunk Shooter!",
"Also try Braid!",
"Why are you reading this???",
"Really. You read\n splash text.",
"Umm... Why are\nthe trees floating?",
"No robots",
"Kick 'em up!",
"Gotta eat some soup!",
"Disgusting soup.",
"This is a very\ncool splash.",
"Hey, you!", "Can render 400,000 blocks!", "Updates incoming", "No hidden fees!", "Hippopotamus!", "Gotta catch them all!", "Not greyscale", "Nope.", "Sometimes, having a giant monitor is really helpful.", "Also try GameChiefCraft", "Also try Ultimate Platformer", "What's the opposite of right? Wrong!", "Feeling snackish? I know the feeling.", "Hey look! It's invisible!", "LG logo is pacman!", "Don't mine bedrock", "Cross-platform, if you build the platform",
"I have a nice\nhouse!",
"TNT can be satisfying!",
//"Griefing could be fun!" //don't want people griefing
"Bamboo exsists in this game!",
"The jungle has big trees!",
"If you have Minecraft,\nthen why would you play this?",
"More than 4000 users!",
"If you don't eat the apple,\nwhat's it for?",
"you should play this\n\ndude",
"Lifeboat! Mineplex! Cubecraft! Mineville!",
"Particularly amusing!",
"Tastes like chicken!",
"What if there were 55 more days of the year?",
"9+10!",
"This line of text is without\nthe first symbol of the\nEnglish terminology!",
"An alternative to touching grass!",
"Ancient Debris!",
"No Villagers!",
"Doesn't include the Backrooms!",
"Controversial Opinion:\nQueen Elizabeth has a Totem of Undying",
"The customer is (sometimes) right!",
"repeat was here",
"thingMaker was here"
]
let splash = ""
function rdmSplash(){
splash = splashs[Math.floor(Math.random()*splashs.length)]
}
win.rdmSplash = rdmSplash
win.setSplash = function(s){
splash = splashs[s]
}
win.setSplashText = function(str){
splash = str
}
rdmSplash()
setInterval(() => rdmSplash(), 60000)
function drawTitle() {
let title = "MINEKHAN"
let titleWidth = images.minekhan.width*1.6
let titleHeight = images.minekhan.height*1.6
let subtext = "JAVASCRIPT EDITION"
let font = "VT323,monospace"
strokeWeight(1)
ctx.textAlign = 'center'
/*
ctx.font = "bold 110px " + font
fill(/*30*-/70)
text(title, width / 2, 158)
//fill(40)
text(title, width / 2, 155)
ctx.font = "bold 111px " + font
//fill(50)
text(title, width / 2, 152)
//fill(70)
text(title, width / 2, 150)
//fill(90)
ctx.font = "bold 112px " + font
text(title, width / 2, 148)
fill(110)
text(title, width / 2, 145)*/
ctx.drawImage(images.minekhan, width/2 - (titleWidth/2), 145 - titleHeight, titleWidth,titleHeight)
ctx.font = "bold 32px " + font
fill(50)
text(subtext, width / 2-1, 180)
text(subtext, width / 2+1, 180)
text(subtext, width / 2, 179)
text(subtext, width / 2, 181)
ctx.font = "bold 32px " + font
fill(150)
text(subtext, width / 2, 180)
fill(230,220,0)
ctx.translate(width/2 + 280,170)
ctx.rotate(-Math.PI/8);
var s = (size/40)*6+25
ctx.font = "bold "+s+"px " + font
text(splash, 0,0, s)
ctx.rotate(Math.PI/8);
ctx.translate(-(width/2+280),-170)
}
clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
dirt = () => ctx.putImageData(dirtbg, 0, 0)
nether = () => ctx.putImageData(netherbg, 0, 0)
drawScreens["initLoading"] = () => {}
var size = 0
var sizes = 0
var sizess = 1
drawScreens["main menu"] = () => {
clear()
sizes += sizess
if((sizes > 5) || (sizes < -5)){
sizess = -sizess
}
size += sizes
drawTitle()
fill(220)
ctx.font = "18px VT323"
ctx.textAlign = 'left'
text("MineKhan " + version, 2, height - 2)
ctx.textAlign = "right"
text("Do not plagarize.", width - 2, height - 2)
}
drawScreens.play = () => {
ctx2.clearRect(0,0,width,height)
var now = Date.now()
tick = false
if(now - lastTick > tickTime){
lastTick = Math.floor(now / 50) * 50
tick = true
}
if(tick && rand() > 0.2){
gl.uniform1i(glCache.flicker, rand() > 0.9)
}
p.rz = 0
if(survival && p.y < 0){
if(now-lastBlockHarm > 500){
lastBlockHarm = now
damage(4, username+" fell out of the world.")
}
}
if(controlMap.place.pressed && holding && blockData[holding].edible && (blockData[holding].eatWhenFull||(!survival) ? true : p.food < 20)){
var block = blockData[holding]
if(p.eating){
var time = now - p.eatStart
if(now - eatSoundTimer > 250){
eatSoundTimer = now
eatSound()
}
if(time > 1610){
p.eating = false
p.food += block.food
p.foodSaturation += block.saturation
if(survival && inventory.hotbar[inventory.hotbarSlot]){
inventory.hotbar[inventory.hotbarSlot].amount --;
if(block.eatResult && !newInvItem(blockIds[block.eatResult])) {
world.addEntity(new Item(p.x,p.y,p.z,0,0,0,blockIds[block.eatResult]))
}
updateHUD = true
}
if(p.food >= 20){
playSound("eat.burp")
if(multiplayer) send({type:"playSound", data:"eat.burp", x:p.x,y:p.y,z:p.z})
}
}
}else{
p.eating = true
p.eatStart = now
}
}else if(p.eating) p.eating = false
if(p.sneaking || p.eating || p.usingSpyglass){
p.sprinting = false
p.speed = p.sneakSpeed
if(p.sneaking)p.bottomH = 1.32
}else if(!p.sprinting){
p.sneaking = false
p.speed = p.defaultSpeed
p.bottomH = 1.62
}
for(var i=0; i<9; i++){
if(inventory.hotbar[i].id && inventory.hotbar[i].amount < 1){
inventory.hotbar[i] = 0
holding = inventory.hotbar[inventory.hotbarSlot].id
updateHUD = true
}
if(inventory.hotbar[i].id && inventory.hotbar[i].animation > 1){
inventory.hotbar[i].animation -= 0.04
if(inventory.hotbar[i].animation < 1) inventory.hotbar[i].animation = 1
updateHUD = true
}
if(inventory.hotbar[i] && (blockData[inventory.hotbar[i].id].pickaxe || blockData[inventory.hotbar[i].id].sword || blockData[inventory.hotbar[i].id].shovel || blockData[inventory.hotbar[i].id].axe || blockData[inventory.hotbar[i].id].hoe || inventory.hotbar[i].id===blockIds.flintAndSteel)){
if(inventory.hotbar[i].durability <= 0){
inventory.hotbar[i] = 0
holding = inventory.hotbar[inventory.hotbarSlot].id
playSound("entity.item.break")
if(multiplayer) send({type:"playSound", data:"entity.item.break", x:p.x,y:p.y,z:p.z})
updateHUD = true
}else if(!inventory.hotbar[i].durability){
inventory.hotbar[i].durability = blockData[inventory.hotbar[i].id].durability
}
}
}
if((now - attackCooldownStart) / 1000 * 20 > attackCooldownTime){
if(attackCooldown !== 0) updateHUD = true
attackCooldown = 0
}else{
let prog = (now - attackCooldownStart) / 1000 * 20
attackCooldown = prog / attackCooldownTime
updateHUD = true
}
p.prevUsingSpyglass = p.usingSpyglass
p.usingSpyglass = false
if(controlMap.place.pressed && holding && blockData[holding].spyglass){
p.spyglassTimer = Date.now() - p.spyglassStart
p.usingSpyglass = p.spyglassTimer < 60000
}
if(!p.prevUsingSpyglass && p.usingSpyglass){
p.FOV(settings.fov/10, 300)
playSound("item.spyglass.use")
if(multiplayer) send({type:"playSound", data:"item.spyglass.use", x:p.x,y:p.y,z:p.z})
}else if(p.prevUsingSpyglass && !p.usingSpyglass){
p.FOV(settings.fov, 300)
playSound("item.spyglass.stop")
if(multiplayer) send({type:"playSound", data:"item.spyglass.stop", x:p.x,y:p.y,z:p.z})
}
if(p.usingSpyglass || p.prevUsingSpyglass){
updateHUD = true
}
standingOn = world.getBlock(p2.x,p2.y-2,p2.z)
if(tick) controls()
if(tick) runGravity()
if(survival){
cracks()
}
if(witherEffect>0){
witherEffect --;
if(survival && now-lastBlockHarm > witherTime){
lastBlockHarm = now
damage(witherDamage, username+" got withered. Ew.")
}
}
if(survival && tick){
if(powder){
freezeEffect ++
if(freezeEffect > 140){
freezeEffect = 140
if(now - lastFreezeHealth > 2000 && survival){
lastFreezeHealth = now
damage(1,username+" froze to death.", false, "freeze")
}
}else{
lastFreezeHealth = now
updateHUD = true
}
}else if(freezeEffect > 0){
freezeEffect --
updateHUD = true
}
}
/*if(now - lastHeal > healTime) {
lastHeal = now
if(p.health < 20){
p.health += 1
healEffect = 40
updateHUD = true
}
}*/
if(survival){
if(p.foodSaturation > p.food) p.foodSaturation = p.food
/*if(p.food > 17 || p.food === 0){
var timer = now - p.foodTimer
if(timer >= 4000){
p.foodTimer = now
if(p.food === 0){
p.health --
harmEffect = 40
hitSound()
updateHUD = true
}else if(p.foodSaturation > 0 && p.health < 20){
p.health ++
healEffect = 40
updateHUD = true
}
}*/
/*if((timer === 500 || timer === 0) && p.food >= 20 && p.health < 20 && p.foodExhaustion > 0){
var heal = min(p.foodSaturation/6, 1)
p.health += heal
if(p.food > 18){
p.foodExhaustion += heal*6
}
healEffect = 40
updateHUD = true
}
}*/
var healTimer = now-lastHeal
if(p.health < 20){
var heal
if(p.foodSaturation > 0 && p.food === 20 && healTimer >= 500){
heal = 1
}else if(p.food >= 18 && healTimer >= 4000){
heal = 1
}
if(heal){
lastHeal = now
p.health += heal
healEffect = 40
updateHUD = true
}
if(p.food < 18 && p.food > 0) lastHeal = now
}
if(p.health > 1 && p.food <= 0 && healTimer >= 4000){
lastHeal = now
damage(1, username+" starved to death.")
}
if(p.foodExhaustion >= 4){
p.foodExhaustion = 0
p.foodSaturation --
if(p.foodSaturation <= 0){
p.food --
}
}
if(p.food > 20) p.food = 20
if(p.food < 0) p.food = 0
if(p.foodSaturation < 0) p.foodSaturation = 0
if(tick){
if(p.foodSaturation <= 0 || p.foodJitter > -1){
p.foodJitter ++
if(p.foodJitter > 10) p.foodJitter = -1
updateHUD = true
}else{
p.foodJitter = -1
}
}
}
if(p.touchingBurnBlock){
p.burnStart = now
p.burnTimer += 0.1
}
if(wet || freezeEffect > 0) p.burnTimer = 0
if(survival && p.burnTimer > 0){
if(now - p.burnStart > 500){
p.burnStart = now
p.burnTimer --
damage(1, username+" was burnt to a crisp.")
}
}
p.burning = p.burnTimer > 0
if(!survival) p.burnTimer = 0
var blockHere = world.getBlock(p2.x, p2.y, p2.z)
inWater = 0
if(blockHere === blockIds.Water) inWater = 1
if(blockHere === blockIds.Lava) inWater = 2
var blockAtFeet = world.getBlock(p2.x, round(p.y-p.bottomH), p2.z)
if(!p.flying && ((blockHere && blockData[blockHere].ladder) || (blockAtFeet && blockData[blockAtFeet].ladder))){
if(controlMap.jump.pressed){
p.velocity.y = 0.2
}else if(!p.onGround && p.velocity.y < 0){
p.velocity.y *= 0.8
}
}
if(survival){
if(liquid && blockHere === blockIds.Water){
if(p.oxygen > 0){
var time = floor(p.oxygen / 2) * 2 === p.oxygen ? 1000 : 125
if(now - lastLoseOxygen > time){
p.oxygen --
lastLoseOxygen = now
updateHUD = true
}
}else{
if(now-lastBlockHarm > 500){
lastBlockHarm = now
damage(1, username+" drowned.",false, "drown")
}
}
}else if(p.oxygen < 20 && now - lastGetOxygen > 300){
lastGetOxygen = now
p.oxygen = (Math.floor(p.oxygen/2)*2) + 2
updateHUD = true
}
}
if(p.health > 20) {
p.health = 20;
}
if(p.oxygen > 20) {
p.oxygen = 20;
}
if(harmEffect > 0){
harmEffect --
p.rz = max(harmEffect-20,0) / 200
p.character.harmEffect = harmEffect
updateHUD = true
}
if(healEffect > 0){
healEffect --
updateHUD = true
}
if(loseHealthEffect > 0){
loseHealthEffect --
updateHUD = true
}
if(p.punchEffect > 0){
p.punchEffect --
}
if(p.punchEffect < 0) p.punchEffect = 0
if(tick){
var pTouchingPortal = touchingPortal
touchingPortal = false
resolveContactsAndUpdatePosition(now)
if(!pTouchingPortal && touchingPortal){
if(portalTriggerSound){
portalTriggerSound.stop()
}
playSound("block.portal.trigger", 0, 0.01, null, null, false, portalTriggerSoundStart)
}
if(portalTriggerSoundGain){
portalTriggerSoundGain.gain.value = portalEffect / 100
}
}
//Temperature calculation
if(tick){
var biome = world.getBiome(p2.x,p2.y,p2.z)
var temp = getBiomeTemperature(biome)
if(p.burning){
temp += p.burnTimer / 2
}
if(freezeEffect > 0){
temp -= freezeEffect / 16
}else if(wet){
temp -= 2
}
//Darker places are colder
const skysLight = world.getLight(p2.x, p2.y, p2.z, 0)
const lightLevel = min((skysLight * skyLight / 15) * 0.9 + 0.1, 1.0)
temp -= (1 - lightLevel) * 4
p.temperature = temp
if(p.lastTemperature !== round(p.temperature)){
p.lastTemperature = round(p.temperature)
updateHUD = true
}
}
if(p.health < 5 && tick) updateHUD = true //for hearts shaking
if (updateHUD) {
clear()
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
hud()
ctx.drawImage(gl.canvas, 0, 0)
updateHUD = false
freezeFrame = false
gl.clearColor(sky[0], sky[1], sky[2], 1.0)
}
defineWorld(tick)
if(tick) updateAmbient()
if(harmEffect > 0){
fill(255,0,0, harmEffect)
ctx.fillRect(0,0,width,height)
}
if(p.burning && !p.thirdPerson){
updateHUD = true
}
if(portalEffect > 0){
if(tick){
portalEffect --
}
updateHUD = true
/*fill(255,0,255, portalEffect)
ctx.fillRect(0,0,width,height)*/
//portal texture update in updateTextures
//code in hud
}
if(mouseDown && touchScreen){
ctx.beginPath()
fill(255)
strokeWeight(2)
ellipse(pTouch.x, pTouch.y, 70,70)
ctx.stroke()
if(pTouch.digProg > 0){
ctx.beginPath()
let r = pTouch.digProg * 70
ellipse(pTouch.x, pTouch.y, r,r)
ctx.fill()
}
updateHUD=true
}
if(survival)ctx.drawImage(canvas2,0,0)
if(p.health < 1){
die()
drawScreens.dead()
Button.draw()
Slider.draw()
}
if(titleOpacity > 0){
titleOpacity --
let alpha = titleOpacity/100
ctx.font = "80px VT323"
ctx.textAlign = "center"
ctx.fillStyle = titleColor
ctx.globalAlpha = alpha > 1 ? 1 : alpha
text(title, width/2, height/2, 80)
if(subtitle){
ctx.font = "40px VT323"
text(subtitle, width/2, height/2+50, 40)
}
ctx.globalAlpha = 1
updateHUD = true
}
if(sideMessageTime > 0){
sideMessageTime --
var x
var w = 200
if(sideMessageTime > 540){
x = 1 - ((sideMessageTime - 540) / 60)
}else if(sideMessageTime > 60){
x = 1
}else{
x = sideMessageTime / 60
}
x = width - (x * w)
ctx.clearRect(width-w,0,w,50)
ctx.fillStyle = "#223"
ctx.fillRect(x, 0,w,50)
ctx.textBaseline = "top"
ctx.fillStyle = "white"
ctx.font = "10px VT323"
ctx.fillText(sideMessageTitle, x+5, 5, w-10)
ctx.fillStyle = "#aaa"
ctx.fillText(sideMessageContent, x+5, 20, w-10)
ctx.textBaseline = "alphabetic"
}
if(inventory.showName > 0){
inventory.showName -= 0.02
updateHUD = true
}
if(p.walking && p.onGround){
let limit = 500
if(p.sprinting) limit = 250
if(now - lastStepSound > limit){
lastStepSound = now
blockSound(standingOn, "step", p.x,p.y,p.z, 1)
}
}
if(multiplayer && multiplayer.sendPos && tick) multiplayer.sendPos()
if(typeof win.eachFrame === "function") win.eachFrame()
}
drawScreens.dead = () => {
ctx.drawImage(gl.canvas, 0, 0)
ctx.fillStyle = "rgba(255,0,0,50%)"
ctx.fillRect(0,0,width,height)
fill(0)
ctx.font = "50px Arial"
ctx.textAlign = "center"
ctx.fillText("You died", width/2, 100)
ctx.font = "20px Arial"
ctx.fillText(dieMessage, width/2, 140)
ctx.fillText("Score: "+p.totalXP, width/2, 160)
}
drawScreens.loading = () => {
world = dimensions.overworld
// This is really stupid, but it basically works by teleporting the player around to each chunk I'd like to load.
// If chunks loaded from a save aren't generated, they're deleted from the save, so this loads them all.
let frameStart = win.performance.now()+1
let sub = maxLoad - world.loadFrom.length - 9
if (superflat === "island" && win.islandGenerator.stage < 10) {
if (!win.islandGenerator.seedSet) {
win.islandGenerator.SetSeed(noiseProfile.seed)
}
win.islandGenerator.Generate(frameStart);
} else {
let standing = true
if (world.loadFrom.length) {
let load = world.loadFrom[0]
p.x = load.x * 16
p.y = load.y * 16
p.z = load.z * 16
standing = false
} else {
p.x = p2.x
p.y = p2.y
p.z = p2.z
let cx = p.x >> 4
let cz = p.z >> 4
for (let x = cx - 1; x <= cx + 1; x++) {
for (let z = cz - 1; z <= cz + 1; z++) {
if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
standing = false
} else {
sub++
}
}
}
}
if (standing) {
if(world.editedTagsToLoad) world.loadEditedTags(world.editedTagsToLoad)
world.hasLoaded = true
play()
return
}
world.tick()
}
let progress = Math.round( (superflat==="island"?45:100) * sub / maxLoad)
if(superflat === "island")progress += Math.round((win.islandGenerator.stage/9.0+win.islandGenerator.h/win.islandGenerator.size*3/9)*50)
dirt()
fill(255)
textSize(25)
ctx.textAlign = "center"
text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
}
drawScreens.netherLoading = () => {
world = dimensions.nether
let frameStart = win.performance.now()+1
let sub = maxLoad - world.loadFrom.length - 9
let standing = true
if (world.loadFrom.length) {
let load = world.loadFrom[0]
p.x = load.x * 16
p.y = load.y * 16
p.z = load.z * 16
standing = false
} else {
p.x = p2.x
p.y = p2.y
p.z = p2.z
let cx = p.x >> 4
let cz = p.z >> 4
for (let x = cx - 1; x <= cx + 1; x++) {
for (let z = cz - 1; z <= cz + 1; z++) {
if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
standing = false
} else {
sub++
}
}
}
}
if (standing) {
if(world.editedTagsToLoad) world.loadEditedTags(world.editedTagsToLoad)
world.hasLoaded = true
play()
return
}
world.tick()
let progress = Math.round(100 * sub / maxLoad)
nether()
fill(255)
textSize(25)
ctx.textAlign = "center"
text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
}
drawScreens.inventory = drawInv
drawScreens.crafting = drawCrafting
drawScreens.furnace = drawFurnace
drawScreens.chest = drawChest
drawScreens.pause = () => {
strokeWeight(1)
clear()
textSize(50)
fill(0, 0, 0)
ctx.textAlign = 'center'
text("Paused", width / 2, 60)
}
drawScreens.options = () => {
clear()
}
drawScreens["options worldSettings"] = () => {
clear()
}
drawScreens["options controls"] = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text(false ? "So, I hear you want to change some controls." : "Controls", width / 2, 20)
}
drawScreens["options narrator"] = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text("Narrator stuff (it basically reads chat)", width / 2, 25)
}
drawScreens.help = () => {
dirt()
ctx.textAlign = 'center'
textSize(25)
fill(255)
text("Help", width / 2, 40)
}
drawScreens["creation menu"] = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text("Create New World", width / 2, 20)
}
drawScreens["loadsave menu"] = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text("Select World", width / 2, 20)
}
drawScreens["broken world"] = () => {
dirt()
ctx.textAlign = 'center'
fill(255)
textSize(25)
text("This world is an old world.\nIt might be broken.\nAre you sure you want to load it?", width / 2, height / 2 - 50, 25)
}
drawScreens["multiplayer menu"] = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text("Select server", width / 2, 20)
}
drawScreens["multiplayer connecting"] = () => {
dirt()
ctx.textAlign = 'center'
fill(255)
textSize(25)
text("Connecting...", width / 2, height / 2)
}
drawScreens["multiplayer lost"] = () => {
dirt()
ctx.textAlign = 'center'
fill(255)
textSize(25)
text("Connection lost!", width / 2, height / 2 - 40)
if(multiplayerError){
if(typeof multiplayerError !== "string"){
multiplayerError = multiplayerError.toString()
}
textSize(18)
text(multiplayerError, width / 2, height / 2)
}
}
drawScreens.editworld = dirt
drawScreens.marketplace = () => {
dirt()
ctx.textAlign = 'center'
textSize(18)
fill(255)
text("Marketplace", width / 2, 20)
}
drawScreens.savingFromMarketplace = () => {
dirt()
ctx.textAlign = 'center'
fill(255)
textSize(25)
text("Downloading...", width / 2, height / 2)
}
})()
// Give the font time to load and redraw the homescreen
setTimeout(e => {
drawScreens[screen]()
Button.draw()
Slider.draw()
}, 100)
let debugMenu = false
function gameLoop() {
let frameStart = performance.now()
if (!gl) {
initEverything()
releasePointer()
}
if(allLoaded){
if(screen === "options"){
if(beforeOptionsScreen === "main menu"){
if(analytics.frames % 2 === 0)renderMainBG()
}
}
if(screen === "main menu"){
if(analytics.frames % 2 === 0)renderMainBG()
drawScreens[screen]()
Button.draw()
Slider.draw()
}
if (screen === "play" || screen === "loading" || screen === "netherLoading") {
drawScreens[screen]()
if(touchScreen && screen === "play") Button.draw()
}
if(screen === "furnace" && furnaceData.data.smelting){
drawScreens[screen]()
}
}
updateMusic()
if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1)
analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
analytics.fps = round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate))
analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
analytics.frames = 0
analytics.totalRenderTime = 0
analytics.totalTickTime = 0
analytics.totalFrameTime = 0
analytics.worstFrameTime = 0
analytics.lastUpdate = Date.now()
updateHUD = true
}
analytics.frames++
analytics.totalFrameTime += performance.now() - frameStart
analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
win.raf = requestAnimationFrame(gameLoop)
}
return gameLoop
}
var init = MineKhan()
if (window.parent.raf) {
window.cancelAnimationFrame(window.parent.raf)
console.log("Canceled", window.parent.raf)
}
init()
function hcyl(bottom, height, radius, id) {
let radsq = radius * radius
let innerRadsq = (radius - 1.2) * (radius - 1.2)
height += bottom
for (let x = -radius; x <= radius; x++) {
for (let y = bottom; y < height; y++) {
for (let z = -radius; z <= radius; z++) {
let d = x * x + z * z
if (d < radsq && d >= innerRadsq) {
world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
}
}
}
}
}
function cyl(bottom, height, radius, id) {
let radsq = radius * radius
height += bottom
for (let x = -radius; x <= radius; x++) {
for (let y = bottom; y < height; y++) {
for (let z = -radius; z <= radius; z++) {
let d = x * x + z * z
if (d < radsq) {
world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
}
}
}
}
}
function sphereoid(w, h, d, id) {
let w2 = w * w
let h2 = h * h
let d2 = d * d
let w3 = (w - 1.5) * (w - 1.5)
let h3 = (h - 1.5) * (h - 1.5)
let d3 = (d - 1.5) * (d - 1.5)
for (let y = -h; y < h; y++) {
for (let x = -w; x <= w; x++) {
for (let z = -d; z <= d; z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
let n2 = x * x / w3 + y * y / h3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
}
}
}
}
}
function sphereoidAt(X,Y,Z,w, h, d, id) {
let w2 = w * w
let h2 = h * h
let d2 = d * d
let w3 = (w - 1.5) * (w - 1.5)
let h3 = (h - 1.5) * (h - 1.5)
let d3 = (d - 1.5) * (d - 1.5)
for (let y = -h; y < h; y++) {
for (let x = -w; x <= w; x++) {
for (let z = -d; z <= d; z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
let n2 = x * x / w3 + y * y / h3 + z * z / d3
if (n < 1 && n2 >= 1) {
world.setBlock(X + x, Y + y, Z + z, id)
}
}
}
}
}
function ball(X,Y,Z,w, h, d, id) {
let w2 = w * w
let h2 = h * h
let d2 = d * d
for (let y = -h; y < h; y++) {
for (let x = -w; x <= w; x++) {
for (let z = -d; z <= d; z++) {
let n = x * x / w2 + y * y / h2 + z * z / d2
if (n < 1) {
world.setBlock(X + x, Y + y, Z + z, id)
}
}
}
}
}
function lookAt(x,y,z){
var p = player
var {atan2, PId, PI2,PI} = Math
p.ry = atan2(z - p.z, x - p.x) + PI2+PI
var adjacent = dist2(p.x,p.z,x,z)
p.rx = atan2(y - p.y, adjacent)
}
if (("serviceWorker" in navigator) && location.origin === "https://minekhan.thingmaker.repl.co") {
window.addEventListener("load", function() {
navigator.serviceWorker
.register("/sw.js")
.then(res => console.log("service worker registered"))
.catch(err => console.log("service worker not registered", err))
})
}
function scrollToEl(id){
var el = document.getElementById(id)
if(el) el.scrollIntoView()
}
</script>
</body>
</html>
